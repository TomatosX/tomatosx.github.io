<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python 学习笔记（一）【基础语法学习】</title>
    <url>/2018/01/10/2018-01-10-Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%90%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E3%80%91/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br></pre></td></tr></table></figure>

<p>如果想让代码中可以输入中文，必须要加上这一句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_function</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="built_in">print</span> c</span><br></pre></td></tr></table></figure>

<p>Python 中定义一个函数用 <code>def</code> 关键字，函数没有大括号，用tab空格代表方法体。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">100</span></span><br><span class="line">tempC = <span class="string">&quot;Number: &quot;</span></span><br><span class="line"><span class="built_in">print</span> tempC + `num`</span><br><span class="line"><span class="built_in">print</span> tempC + <span class="built_in">str</span>(num)</span><br><span class="line"><span class="built_in">print</span> tempC + <span class="built_in">repr</span>(num)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>str和repr结果都一样，区别： str是 <code>对象类型</code> ；repr是 <code>函数</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;one is %s&quot;</span>%num</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;tempA: %s, tempB: %s&quot;</span>%(tempA, tempB)</span><br></pre></td></tr></table></figure>

<p>如果是两个占位符，要写在括号内，用逗号隔开。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wordsA = <span class="string">&quot; this is a book &quot;</span></span><br><span class="line"><span class="built_in">print</span> wordsA[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span> wordsA[-<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取字符串</span></span><br><span class="line"><span class="built_in">print</span> wordsA[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span> wordsA[<span class="number">1</span>:] <span class="comment"># 表示从a[1]开始，一直到字符串的最后</span></span><br><span class="line"><span class="built_in">print</span> wordsA[:] <span class="comment"># 表示截取全部</span></span><br><span class="line"><span class="built_in">print</span> wordsA[:<span class="number">4</span>] <span class="comment"># 表示从字符串开头一直到a[4]前结束</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> wordsA.strip()</span><br><span class="line"><span class="built_in">print</span> wordsA.lstrip()</span><br><span class="line"><span class="built_in">print</span> wordsA.rstrip()</span><br></pre></td></tr></table></figure>

<p><code>strip()</code> 去掉字符串左右的空格，<code>lstrip()</code> 去掉左侧的空格，<code>rstrip()</code> 去掉右侧的空格。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="built_in">divmod</span>(<span class="number">5</span>, <span class="number">2</span>) <span class="comment"># 输出(2, 1)</span></span><br></pre></td></tr></table></figure>

<p>表示5除以2，返回了商和余数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="number">10</span> ** <span class="number">2</span> <span class="comment"># 100</span></span><br><span class="line"><span class="built_in">print</span> <span class="number">9</span> // <span class="number">2</span> <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>

<p><code>**</code> 幂 - 返回 x 的 y 次幂<br><code>//</code> 取整除 - 返回商的整数部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 布尔运算，与、或、非</span></span><br><span class="line"><span class="built_in">print</span> <span class="number">4</span> &gt; <span class="number">3</span> <span class="keyword">and</span> <span class="number">4</span> &lt; <span class="number">2</span> <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span> <span class="number">4</span> &gt; <span class="number">3</span> <span class="keyword">or</span> <span class="number">4</span> &lt; <span class="number">2</span> <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span> <span class="keyword">not</span>(<span class="number">4</span> &lt; <span class="number">2</span>) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>与 <code>and</code> ，或 <code>or</code> ，非 <code>not</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">4</span> &gt; <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;4 &gt; 2&quot;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="number">4</span> == <span class="number">2</span>: <span class="comment"># 注意这里的else if</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;4 == 2&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;4 &lt; 2&quot;</span></span><br></pre></td></tr></table></figure>

<p>python 中的 else if 写成 <code>elif</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(ary) <span class="comment"># &lt;type &#x27;list&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>python 的数组叫做 <code>list</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ary.append(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> ary</span><br><span class="line">ary2 = [<span class="string">&quot;Test1&quot;</span>, <span class="string">&quot;ddd&quot;</span>]</span><br><span class="line">ary.extend(ary2)</span><br><span class="line"><span class="built_in">print</span> ary</span><br></pre></td></tr></table></figure>

<p>python list 类型添加一个元素 <code>append()</code> ，合并两个 list <code>extend()</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> ary.count(<span class="string">&quot;ddd&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> ary[<span class="number">4</span>:]</span><br><span class="line"><span class="built_in">print</span> ary[<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span> ary.index(<span class="string">&quot;ddd&quot;</span>)</span><br><span class="line">ary.insert(<span class="number">2</span>, <span class="number">2.3</span>)</span><br><span class="line"><span class="built_in">print</span> ary</span><br></pre></td></tr></table></figure>

<p><code>count()</code> 用于计算某个元素出现的次数，这里计算 <code>ddd</code> 出现了几次。<br><code>index()</code> 查看 <code>ddd</code> 的下标。<br><code>insert()</code> 在指定地方插入元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">2.3</span> <span class="keyword">in</span> ary:</span><br><span class="line">    ary.remove(<span class="number">2.3</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;2.3在list中:&quot;</span></span><br><span class="line">    <span class="built_in">print</span> ary</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;2.3不在list中&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 </span></span><br><span class="line"><span class="comment"># 2.3在list中:</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, &#x27;Test&#x27;, &#x27;Test1&#x27;, &#x27;ddd&#x27;]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ary.pop()</span><br><span class="line"><span class="built_in">print</span> ary</span><br><span class="line">ary.pop(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span> ary</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, &#x27;Test&#x27;, &#x27;Test1&#x27;]</span></span><br><span class="line"><span class="comment"># [1, 2, 3, &#x27;Test&#x27;, &#x27;Test1&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><code>pop()</code> 删除list中的最后一个元素。<br><code>pop(3)</code> 删除list中3这个元素，如果有多个，就删除最前面的一个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="built_in">range</span>(<span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>, <span class="number">2</span>) <span class="comment"># step=2,每个元素等于start + i * step</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">100</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">range</span>(<span class="number">0</span>, -<span class="number">9</span>, -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><code>range(start, stop[, step])</code><br>start：开始数值，默认为0,也就是如果不写这项，就是认为start=0<br>stop：结束的数值，必须要写的。<br>step：变化的步长，默认是1,也就是不写，就是认为步长为1。坚决不能为0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 排序</span></span><br><span class="line">number = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br><span class="line">number.sort()</span><br><span class="line"><span class="built_in">print</span> number</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">sorted</span>(number)</span><br><span class="line">number.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span> number</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">sorted</span>(number, reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p><code>reverse=True</code> 倒序排列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">power = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    power.append(x ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>在Python中，上面的代码可以改成如下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br></pre></td></tr></table></figure>

<p>类似的，还有如下的形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> [n <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">100</span>) <span class="keyword">if</span> n % <span class="number">3</span> == <span class="number">0</span>] <span class="comment"># 被3整除的正整数 </span></span><br><span class="line"></span><br><span class="line">mybag = [<span class="string">&#x27; glass&#x27;</span>,<span class="string">&#x27; apple&#x27;</span>,<span class="string">&#x27;green leaf &#x27;</span>]              </span><br><span class="line"><span class="built_in">print</span> [one.strip() <span class="keyword">for</span> one <span class="keyword">in</span> mybag] <span class="comment"># 去掉每个元素前后的空格     </span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">weak = [<span class="string">&quot;周一&quot;</span>, <span class="string">&quot;周二&quot;</span>, <span class="string">&quot;周三&quot;</span>, <span class="string">&quot;周四&quot;</span>, <span class="string">&quot;周五&quot;</span>, <span class="string">&quot;周六&quot;</span>, <span class="string">&quot;周日&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> (idx, item) <span class="keyword">in</span> <span class="built_in">enumerate</span>(weak):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;idx: &quot;</span> + <span class="built_in">str</span>(idx) + <span class="string">&quot;; item: &quot;</span> + item</span><br></pre></td></tr></table></figure>

<p>list中的迭代器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dicNum = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(dicNum)</span><br><span class="line">dicNum[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">dicNum[<span class="number">1</span>] = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">dicNum[<span class="number">2</span>] = <span class="number">90</span></span><br><span class="line"><span class="built_in">print</span> dicNum</span><br></pre></td></tr></table></figure>

<p>字典类型，用大括号表示。<br>也可以这样创建字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = ([<span class="string">&quot;first&quot;</span>, <span class="string">&quot;Google&quot;</span>], [<span class="string">&quot;second&quot;</span>, <span class="string">&quot;Yahoo&quot;</span>])</span><br><span class="line">webSite = <span class="built_in">dict</span>(name)</span><br><span class="line"><span class="built_in">print</span> webSite		</span><br><span class="line"><span class="comment"># &#123;&#x27;second&#x27;: &#x27;Yahoo&#x27;, &#x27;first&#x27;: &#x27;Google&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">webSiteTest = &#123;&#125;.fromkeys((<span class="string">&quot;third&quot;</span>, <span class="string">&quot;forth&quot;</span>), <span class="string">&quot;facebook&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> webSiteTest</span><br><span class="line"><span class="comment"># &#123;&#x27;forth&#x27;: &#x27;facebook&#x27;, &#x27;third&#x27;: &#x27;facebook&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">dict</span>(one=<span class="number">1</span>, two=<span class="number">2</span>, three=<span class="number">3</span>)</span><br><span class="line">b = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">c = <span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">d = <span class="built_in">dict</span>([(<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;three&#x27;</span>, <span class="number">3</span>)])</span><br><span class="line">e = <span class="built_in">dict</span>(&#123;<span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="built_in">print</span> a		<span class="comment"># &#123;&#x27;three&#x27;: 3, &#x27;two&#x27;: 2, &#x27;one&#x27;: 1&#125;</span></span><br><span class="line"><span class="built_in">print</span> b		<span class="comment"># &#123;&#x27;three&#x27;: 3, &#x27;two&#x27;: 2, &#x27;one&#x27;: 1&#125;</span></span><br><span class="line"><span class="built_in">print</span> c		<span class="comment"># &#123;&#x27;three&#x27;: 3, &#x27;two&#x27;: 2, &#x27;one&#x27;: 1&#125;</span></span><br><span class="line"><span class="built_in">print</span> d		<span class="comment"># &#123;&#x27;three&#x27;: 3, &#x27;two&#x27;: 2, &#x27;one&#x27;: 1&#125;</span></span><br><span class="line"><span class="built_in">print</span> e		<span class="comment"># &#123;&#x27;one&#x27;: 1, &#x27;three&#x27;: 3, &#x27;two&#x27;: 2&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dicNum.update(webSiteTest)</span><br></pre></td></tr></table></figure>

<p>将 webSiteTest 合并到 dicNum。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">123</span>, <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="comment"># (1, 3, 4, 123, &#x27;test&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>自动封装成元组类型，元组类型是不可变的。</p>
<p><strong>元组的使用：</strong></p>
<p>一般认为,tuple有这类特点,并且也是它使用的情景:</p>
<ul>
<li>Tuple 比 list 操作速度快。如果您定义了一个值的常量集，并且唯一要用它做的是不断地遍历它，请使用 tuple 代替 list。</li>
<li>如果对不需要修改的数据进行 “写保护”，可以使代码更安全。使用 tuple 而不是 list 如同拥有一个隐含的 assert 语句，说明这一数据是常量。如果必须要改变这些值，则需要执行 tuple 到 list 的转换 (需要使用一个特殊的函数)。</li>
<li> Tuples 可以在 dictionary 中被用做 key，但是 list 不行。实际上，事情要比这更复杂。Dictionary key 必须是不可变的。Tuple 本身是不可改变的，但是如果您有一个 list 的 tuple，那就认为是可变的了，用做 dictionary key 就是不安全的。只有字符串、整数或其它对 dictionary 安全的 tuple 才可以用作 dictionary key。</li>
<li>Tuples 可以用在字符串格式化中，后面会用到。</li>
</ul>
<p><strong>set可以用{}定义；</strong></p>
<ol>
<li>元素没有序列，不能重复（类似于dict）；</li>
<li>可以原处修改，但是不能通过下标的方式修改（类似于list，事实上是一种特别的set可以原处修改，另一种是不可以的）；</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = <span class="built_in">set</span>(<span class="string">&quot;qiwsir&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> s1</span><br></pre></td></tr></table></figure>

<p>输出内容：<code>set([&#39;q&#39;, &#39;i&#39;, &#39;s&#39;, &#39;r&#39;, &#39;w&#39;]) </code><br>将字符串拆开，并且没有重复的字母。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s3 = &#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;21&quot;</span>, <span class="number">33</span>&#125;</span><br><span class="line"><span class="built_in">print</span> s3</span><br><span class="line"></span><br><span class="line">s4 = &#123;&#125; <span class="comment"># 这样建立的是dict，并不是set</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s6 = <span class="built_in">set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">s7 = <span class="built_in">set</span>([<span class="string">&#x27;github&#x27;</span>, <span class="string">&#x27;qiwsir&#x27;</span>])</span><br><span class="line">s6.update(s7)</span><br></pre></td></tr></table></figure>

<p>合并s7到s6, s7不变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> s6.pop()</span><br></pre></td></tr></table></figure>

<p>从set中任意选择一个删除，并返回该值， <code>pop()</code> 不能有参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&quot;github&quot;</span> <span class="keyword">in</span> s6:</span><br><span class="line">    s6.remove(<span class="string">&quot;github&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> s6</span><br></pre></td></tr></table></figure>

<p>想要删除特定的元素，需要使用 <code>remove(obj)</code> 函数。<br>并且obj必须在set中是存在的，否则报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s6.discard(<span class="string">&quot;github&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>discard(obj)</code> 跟remove类似，不同之处在于，如果删除的元素在set中不存在则 <code>discard(obj)</code> 函数什么也不做。</p>
<p>在Python中变量有如下特殊的赋值方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name, web = <span class="string">&quot;qiwsir&quot;</span>, <span class="string">&quot;qiwsir.github.io&quot;</span> <span class="comment"># 多个变量，按照顺序依次赋值，少了或者多了，都会报错</span></span><br><span class="line"></span><br><span class="line">one, two, three, four = <span class="string">&quot;good&quot;</span> <span class="comment"># 拆分</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Python学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习笔记（二）【文件的简单操作】</title>
    <url>/2018/01/15/2018-01-15-Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%90%E6%96%87%E4%BB%B6%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%E3%80%91/</url>
    <content><![CDATA[<p>在 python 中简单的打开一个文件可以用 <code>open(name, model)</code> 的方式<br><code>name</code> 文件路径。<br><code>model</code> 打开的方式。</p>
<p><code>model</code> 参数如下：</p>
<p>![](./my_pictures/2018-01-15-Python 学习笔记（二）【文件的简单操作】.png)</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;散文.txt&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">    <span class="built_in">print</span> line,</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n\n第二次读取:&quot;</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">    <span class="built_in">print</span> line,</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n\n第二次读取结束。\n\n&quot;</span></span><br></pre></td></tr></table></figure>

<p>第二次读取没有内容，是因为第二次读取是从第一次读取的结束开始，那么自然就没有数据。<br>相当于文件的指针指向了文件的末尾，再从某未开始读取，自然就没有数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file.seek(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">    <span class="built_in">print</span> line,</span><br><span class="line">file.close() <span class="comment"># 关闭文件</span></span><br></pre></td></tr></table></figure>

<p>加上 <code>seek()</code> 这个方法，这时我们就能读取到数据了。<br>这个方法将指针移到了文件的开头。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file2 = <span class="built_in">open</span>(<span class="string">&quot;散文.txt&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">file2.write(<span class="string">&quot;这是新添加的内容。&quot;</span>)</span><br><span class="line">file2.close()</span><br></pre></td></tr></table></figure>

<p>写完必须关闭，这样才能保存到文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">file_state = os.stat(<span class="string">&quot;散文.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> file_state</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">posix.stat_result(st_mode=<span class="number">33188</span>, st_ino=<span class="number">3496826</span>, st_dev=<span class="number">16777220</span>, st_nlink=<span class="number">1</span>, st_uid=<span class="number">501</span>, st_gid=<span class="number">20</span>, st_size=<span class="number">566</span>, st_atime=<span class="number">1510210604</span>, st_mtime=<span class="number">1510207603</span>, st_ctime=<span class="number">1510207603</span>)</span><br></pre></td></tr></table></figure>

<p>我们将信息格式化一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="built_in">print</span> time.localtime(file_state.st_ctime)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">11</span>, tm_mday=<span class="number">9</span>, tm_hour=<span class="number">14</span>, tm_min=<span class="number">6</span>, tm_sec=<span class="number">43</span>, tm_wday=<span class="number">3</span>, tm_yday=<span class="number">313</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>读取文件有很多方法，系统提供了 <code>read()</code> ，<code>readline()</code> ，<code>readlines</code> 。这些方法都是将内容读入至内存中。在读取大文件的时候最好用下面的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fpb = <span class="built_in">open</span>(<span class="string">&quot;散文.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> fpb:</span><br><span class="line">    <span class="built_in">print</span> item,</span><br><span class="line">fpb.close()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Python学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian 下 Shadowsocks-libev 一键安装脚本</title>
    <url>/2018/01/29/2018-01-29-Debian%20%E4%B8%8B%20Shadowsocks-libev%20%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="本脚本适用环境："><a href="#本脚本适用环境：" class="headerlink" title="本脚本适用环境："></a>本脚本适用环境：</h2><hr>
<p>系统支持：Debian/Ubuntu<br>内存要求：≥128M<br>日期：2018 年 06 月 01 日</p>
<h2 id="关于本脚本："><a href="#关于本脚本：" class="headerlink" title="关于本脚本："></a>关于本脚本：</h2><hr>
<p>Debian 或 Ubuntu 下一键安装 libev 版的 Shadowsocks 最新版本。该版本的特点是内存占用小（600k左右），使用 libev 和 C 编写，低 CPU 消耗，甚至可以安装在基于 OpenWRT 的路由器上。<br>友情提示：如果你有问题，请先参考这篇《Shadowsocks Troubleshooting》后再问。</p>
<a id="more"></a>

<h2 id="默认配置："><a href="#默认配置：" class="headerlink" title="默认配置："></a>默认配置：</h2><hr>
<p>服务器端口：自己设定（如不设定，默认从 9000-19999 之间随机生成）<br>密码：自己设定（如不设定，默认为 teddysun.com）<br>加密方式：自己设定（如不设定，默认为 aes-256-gcm）</p>
<h2 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h2><hr>
<p>使用root用户登录，运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-libev-debian.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev-debian.sh</span><br><span class="line">chmod +x shadowsocks-libev-debian.sh</span><br><span class="line">./shadowsocks-libev-debian.sh 2&gt;&amp;1 | tee shadowsocks-libev-debian.log</span><br></pre></td></tr></table></figure>

<p>安装完成后，脚本提示如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Congratulations, Shadowsocks-libev server install completed!</span><br><span class="line">Your Server IP        :your_server_ip</span><br><span class="line">Your Server Port      :your_server_port</span><br><span class="line">Your Password         :your_password</span><br><span class="line">Your Encryption Method:your_encryption_method</span><br><span class="line"></span><br><span class="line">Welcome to visit:https://teddysun.com/358.html</span><br><span class="line">Enjoy it!</span><br></pre></td></tr></table></figure>

<h2 id="卸载方法："><a href="#卸载方法：" class="headerlink" title="卸载方法："></a>卸载方法：</h2><hr>
<p>使用 root 用户登录，运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./shadowsocks-libev-debian.sh uninstall</span><br></pre></td></tr></table></figure>

<h2 id="其他事项："><a href="#其他事项：" class="headerlink" title="其他事项："></a>其他事项：</h2><hr>
<p>客户端配置的参考链接： <a href="https://teddysun.com/339.html">https://teddysun.com/339.html</a><br>本脚本安装完成后，已将 Shadowsocks-libev 加入开机自启动。</p>
<h2 id="使用命令："><a href="#使用命令：" class="headerlink" title="使用命令："></a>使用命令：</h2><hr>
<p>启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/shadowsocks start</span><br></pre></td></tr></table></figure>

<p>停止：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/shadowsocks stop</span><br></pre></td></tr></table></figure>

<p>重启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/shadowsocks restart</span><br></pre></td></tr></table></figure>

<p>查看状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/shadowsocks status</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 下 Shadowsocks-libev 一键安装脚本</title>
    <url>/2018/01/29/2018-01-29-CentOS%20%E4%B8%8B%20Shadowsocks-libev%20%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="本脚本适用环境："><a href="#本脚本适用环境：" class="headerlink" title="本脚本适用环境："></a>本脚本适用环境：</h2><hr>
<p>系统支持：CentOS<br>内存要求：≥128M<br>日期：2018 年 06 月 01 日</p>
<h2 id="关于本脚本："><a href="#关于本脚本：" class="headerlink" title="关于本脚本："></a>关于本脚本：</h2><hr>
<p>一键安装 libev 版的 Shadowsocks 最新版本。该版本的特点是内存占用小（600k左右），低 CPU 消耗，甚至可以安装在基于 OpenWRT 的路由器上。<br>友情提示：如果你有问题，请先参考这篇<a href="https://teddysun.com/399.html">《Shadowsocks Troubleshooting》</a>后再问。</p>
<a id="more"></a>

<h2 id="默认配置："><a href="#默认配置：" class="headerlink" title="默认配置："></a>默认配置：</h2><hr>
<p>服务器端口：自己设定（如不设定，默认从 9000-19999 之间随机生成）<br>密码：自己设定（如不设定，默认为 teddysun.com）<br>加密方式：自己设定（如不设定，默认为 aes-256-gcm）</p>
<h2 id="Shadowsocks-for-Windows-客户端下载："><a href="#Shadowsocks-for-Windows-客户端下载：" class="headerlink" title="Shadowsocks for Windows 客户端下载："></a>Shadowsocks for Windows 客户端下载：</h2><hr>
<p><a href="https://github.com/shadowsocks/shadowsocks-windows/releases">https://github.com/shadowsocks/shadowsocks-windows/releases</a></p>
<h2 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h2><hr>
<p>如果没有安装 <code>wget</code> 请先安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure>

<p>使用root用户登录，运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-libev.sh https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocks-libev.sh</span><br><span class="line">chmod +x shadowsocks-libev.sh</span><br><span class="line">.&#x2F;shadowsocks-libev.sh 2&gt;&amp;1 | tee shadowsocks-libev.log</span><br></pre></td></tr></table></figure>

<p>安装完成后，脚本提示如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Congratulations, Shadowsocks-libev server install completed!</span><br><span class="line">Your Server IP        :your_server_ip</span><br><span class="line">Your Server Port      :your_server_port</span><br><span class="line">Your Password         :your_password</span><br><span class="line">Your Encryption Method:your_encryption_method</span><br><span class="line"></span><br><span class="line">Welcome to visit:https://teddysun.com/357.html</span><br><span class="line">Enjoy it!</span><br></pre></td></tr></table></figure>

<h2 id="卸载方法："><a href="#卸载方法：" class="headerlink" title="卸载方法："></a>卸载方法：</h2><hr>
<p>使用 root 用户登录，运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;shadowsocks-libev.sh uninstall</span><br></pre></td></tr></table></figure>

<h2 id="其他事项："><a href="#其他事项：" class="headerlink" title="其他事项："></a>其他事项：</h2><hr>
<p>客户端配置的参考链接：<a href="https://teddysun.com/339.html">https://teddysun.com/339.html</a></p>
<p>安装完成后即已后台启动 Shadowsocks-libev ，运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks status</span><br></pre></td></tr></table></figure>

<p>可以查看进程是否启动。<br>本脚本安装完成后，会将 Shadowsocks-libev 加入开机自启动。</p>
<h2 id="使用命令："><a href="#使用命令：" class="headerlink" title="使用命令："></a>使用命令：</h2><hr>
<p>启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/shadowsocks start</span><br></pre></td></tr></table></figure>

<p>停止：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/shadowsocks stop</span><br></pre></td></tr></table></figure>

<p>重启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/shadowsocks restart</span><br></pre></td></tr></table></figure>

<p>查看状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/shadowsocks status</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>Shadowsocks Python 版一键安装脚本</title>
    <url>/2018/01/29/2018-01-29-Shadowsocks%20Python%20%E7%89%88%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="本脚本适用环境："><a href="#本脚本适用环境：" class="headerlink" title="本脚本适用环境："></a>本脚本适用环境：</h3><p>系统支持：CentOS 6，7，Debian，Ubuntu<br>内存要求：≥128M<br>日期：2017 年 07 月 21 日</p>
<h3 id="关于本脚本："><a href="#关于本脚本：" class="headerlink" title="关于本脚本："></a>关于本脚本：</h3><p>一键安装 Python 版 Shadowsocks 的最新版。</p>
<h3 id="默认配置："><a href="#默认配置：" class="headerlink" title="默认配置："></a>默认配置：</h3><p>服务器端口：自己设定（如不设定，默认为 8989）<br>密码：自己设定（如不设定，默认为 teddysun.com）<br>加密方式：自己设定（如不设定，默认为 aes-256-gcm）<br>备注：脚本默认创建单用户配置文件，如需配置多用户，安装完毕后参照下面的教程示例手动修改配置文件后重启即可。</p>
<a id="more"></a>

<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><p>使用root用户登录，运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks.sh https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocks.sh</span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line">.&#x2F;shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure>

<h3 id="安装完成后，脚本提示如下："><a href="#安装完成后，脚本提示如下：" class="headerlink" title="安装完成后，脚本提示如下："></a>安装完成后，脚本提示如下：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Congratulations, Shadowsocks-python server install completed!</span><br><span class="line">Your Server IP        :your_server_ip</span><br><span class="line">Your Server Port      :your_server_port</span><br><span class="line">Your Password         :your_password</span><br><span class="line">Your Encryption Method:your_encryption_method</span><br><span class="line"></span><br><span class="line">Welcome to visit:https:&#x2F;&#x2F;teddysun.com&#x2F;342.html</span><br><span class="line">Enjoy it!</span><br></pre></td></tr></table></figure>

<h3 id="卸载方法："><a href="#卸载方法：" class="headerlink" title="卸载方法："></a>卸载方法：</h3><p>使用root用户登录，运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;shadowsocks.sh uninstall</span><br></pre></td></tr></table></figure>

<p>单用户配置文件示例（2015 年 08 月 28 日修正）：<br>配置文件路径：<code>/etc/shadowsocks.json</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;server_port&quot;:your_server_port,</span><br><span class="line">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;your_password&quot;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;your_encryption_method&quot;,</span><br><span class="line">    &quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多用户多端口配置文件示例（2015 年 08 月 28 日修正）：<br>配置文件路径：<code>/etc/shadowsocks.json</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;port_password&quot;:&#123;</span><br><span class="line">         &quot;8989&quot;:&quot;password0&quot;,</span><br><span class="line">         &quot;9001&quot;:&quot;password1&quot;,</span><br><span class="line">         &quot;9002&quot;:&quot;password2&quot;,</span><br><span class="line">         &quot;9003&quot;:&quot;password3&quot;,</span><br><span class="line">         &quot;9004&quot;:&quot;password4&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;your_encryption_method&quot;,</span><br><span class="line">    &quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用命令（2015 年 08 月 28 日修正）：</p>
<p>启动：<code>/etc/init.d/shadowsocks start</code></p>
<p>停止：<code>/etc/init.d/shadowsocks stop</code></p>
<p>重启：<code>/etc/init.d/shadowsocks restart</code></p>
<p>状态：<code>/etc/init.d/shadowsocks status</code></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark 邮箱账号同步问题</title>
    <url>/2018/01/29/2018-01-29-Spark%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="Shadowrocket-设置"><a href="#Shadowrocket-设置" class="headerlink" title="Shadowrocket 设置"></a>Shadowrocket 设置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DOMAIN-SUFFIX,hockeyapp.net,Group &#x2F;&#x2F;Spark</span><br><span class="line">DOMAIN-SUFFIX,firebaseio.com,Group &#x2F;&#x2F;Spark</span><br><span class="line">DOMAIN,usage.readdle.com,Group &#x2F;&#x2F; spark</span><br><span class="line">DOMAIN,api.amplitude.com,Group &#x2F;&#x2F; spark</span><br><span class="line">DOMAIN,app.smartmailcloud.com,Group &#x2F;&#x2F; spark</span><br></pre></td></tr></table></figure>

<p>上面的 URL 都需要被代理。其中前两个是泛型的，后面三个是精准的。 </p>
<a id="more"></a>

<h3 id="ShadowsocksX-设置"><a href="#ShadowsocksX-设置" class="headerlink" title="ShadowsocksX 设置"></a>ShadowsocksX 设置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.firebaseio.com</span><br><span class="line">.hockeyapp.net</span><br><span class="line">||usage.readdle.com</span><br><span class="line">||api.amplitude.com</span><br><span class="line">||app.smartmailcloud.com</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>App日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 使用 warning</title>
    <url>/2018/01/29/2018-01-29-Swift%20%E4%BD%BF%E7%94%A8%20warning/</url>
    <content><![CDATA[<p>在 Swift 中无法使用 <code>#warning</code> ，Swift 中有如下的标记：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">FIXME:</span> - 待修复</span></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> - 接下来要做的事情</span></span><br><span class="line"><span class="comment">//MARK: - 标记</span></span><br><span class="line">注: 添加<span class="string">&quot;-&quot;</span> 可以显示分割线-----<span class="type">Swift3</span>下有效</span><br></pre></td></tr></table></figure>

<p>接下来给 <code>TODO:</code> 和 <code>FIXME:</code> 加上警告，实现类似的效果：</p>
<p>Build Phases —&gt;  add a new Build Phases —&gt; New run script phase</p>
<a id="more"></a>

<p>添加如下的代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">TAGS=<span class="string">&quot;TODO:|FIXME:&quot;</span></span><br><span class="line">echo <span class="string">&quot;searching $&#123;SRCROOT&#125; for $&#123;TAGS&#125;&quot;</span></span><br><span class="line">find <span class="string">&quot;$&#123;SRCROOT&#125;&quot;</span> \( -name <span class="string">&quot;*.swift&quot;</span> \) -print0 | xargs -<span class="number">0</span> egrep --<span class="keyword">with</span>-filename --line-number --only-matching <span class="string">&quot;($TAGS).*\$&quot;</span> | perl -p -e <span class="string">&quot;s/($TAGS)/ warning: \$1/&quot;</span></span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p>![](/my_pictures/Swift 使用 warning-1.png)</p>
<p>![](/my_pictures/Swift 使用 warning-2.png)</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>iOS工作日志</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS开启允许所有来源</title>
    <url>/2018/01/29/2018-01-29-macOS%E5%BC%80%E5%90%AF%E5%85%81%E8%AE%B8%E6%89%80%E6%9C%89%E6%9D%A5%E6%BA%90/</url>
    <content><![CDATA[<p>输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>系统设置</category>
      </categories>
      <tags>
        <tag>环境设置</tag>
      </tags>
  </entry>
  <entry>
    <title>你应该定期更新 Homebrew</title>
    <url>/2018/01/29/2018-01-29-%E4%BD%A0%E5%BA%94%E8%AF%A5%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0%20Homebrew/</url>
    <content><![CDATA[<h3 id="为什么要定期更新"><a href="#为什么要定期更新" class="headerlink" title="为什么要定期更新"></a>为什么要定期更新</h3><hr>
<p>我发现不少人都不会经常更新，或者只在必须用某个工具的新版本的时候才更新。他们的看法是，更新有可能产生一些意外的问题，反正当前环境足够稳定可以用，干嘛自找麻烦呢？<br>这个看法对也不对。对是因为，更新产生的潜在问题不可避免。不对是因为总有一天你需要升级的，也许是为了某个工具的新特性，也许是为了修复软件的漏洞，也许你安装的包非要依赖另一个包的新版本，等等。如果隔了很长一段时间才升级，那潜在的小问题可能就会变成大问题。<br>另一个有意思的现象是，当碰到比较破坏性的事情，比如 Mac OS 大版本更新后，很多人会选择重装 Homebrew 然后顺带安装最新版的包。很少人会去装一个指定的旧版本（除了特殊项目需要）。这说明他们不是不想用新版本，而是不想痛苦地更新。<br>既然总有一天需要更新，而更新带来问题不可避免，那为什么不更新得频繁点呢？这个道理跟 Git 的冲突解决有相似性。长时间不 pull/push 的代码更容易产生冲突，一个解决方法就是频繁地 commit &amp; merge 。<br>我现在试着一个月更新一次，两次下来发现这些好处：</p>
<a id="more"></a>

<ul>
<li>每次更新的包很少，更新风险也小。</li>
<li>更容易发现不需要的包，便于清理，不为不需要的东西买单。</li>
<li>定期清理旧版本，释放空间。<br>更新流程其实都差不多，下面列一下我常用的命令。</li>
</ul>
<h3 id="更新-Homebrew"><a href="#更新-Homebrew" class="headerlink" title="更新 Homebrew"></a>更新 Homebrew</h3><hr>
<p>要获取最新的包的列表，首先得更新 Homebrew 自己。这可以用 <code>brew update</code> 办到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure>

<p>完后会显示可以更新的包列表，其中打钩的是已经安装的包。输出类似下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Updated Homebrew from fe93aa3 to 6ae64c3.</span><br><span class="line">Updated 1 tap (homebrew&#x2F;versions).</span><br><span class="line">&#x3D;&#x3D;&gt; Updated Formulae</span><br><span class="line">awscli      cmake ✔     homebrew&#x2F;versions&#x2F;libmongoclient-legacy</span><br></pre></td></tr></table></figure>

<h3 id="更新包-formula"><a href="#更新包-formula" class="headerlink" title="更新包 (formula)"></a>更新包 (formula)</h3><hr>
<p>更新之前，我会用 <code>brew outdated</code> 查看哪些包可以更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew outdated</span><br></pre></td></tr></table></figure>

<p>然后就可以用 <code>brew upgrade</code> 去更新了。Homebrew 会安装新版本的包，但旧版本仍然会保留。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew upgrade             # 更新所有的包</span><br><span class="line">brew upgrade $FORMULA    # 更新指定的包</span><br></pre></td></tr></table></figure>

<h3 id="清理旧版本"><a href="#清理旧版本" class="headerlink" title="清理旧版本"></a>清理旧版本</h3><hr>
<p>一般情况下，新版本安装了，旧版本就不需要了。我会用 <code>brew cleanup</code> 清理旧版本和缓存文件。Homebrew 只会清除比当前安装的包更老的版本，所以不用担心有些包没更新但被删了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cleanup             # 清理所有包的旧版本</span><br><span class="line">brew cleanup $FORMULA    # 清理指定包的旧版本</span><br><span class="line">brew cleanup -n          # 查看可清理的旧版本包，不执行实际操作</span><br></pre></td></tr></table></figure>

<p>这样一套下来，该更新的都更新了，旧版本也被清理了。</p>
<h3 id="锁定不想更新的包"><a href="#锁定不想更新的包" class="headerlink" title="锁定不想更新的包"></a>锁定不想更新的包</h3><hr>
<p>如果经常更新的话， <code>brew update</code> 一次更新所有的包是非常方便的。但我们有时候会担心自动升级把一些不希望更新的包更新了。数据库就属于这一类，尤其是 PostgreSQL 跨 minor 版本升级都要迁移数据库的。我们更希望找个时间单独处理它。这时可用 <code>brew pin</code> 去锁定这个包，然后 <code>brew update</code> 就会略过它了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew pin $FORMULA      # 锁定某个包</span><br><span class="line">brew unpin $FORMULA    # 取消锁定</span><br></pre></td></tr></table></figure>

<h3 id="其他几个常用命令"><a href="#其他几个常用命令" class="headerlink" title="其他几个常用命令"></a>其他几个常用命令</h3><hr>
<p><code>brew info</code> 可以查看包的相关信息，最有用的应该是包依赖和相应的命令。比如 Nginx 会提醒你怎么加 <code>launchctl</code> ，PostgreSQL 会告诉你如何迁移数据库。这些信息会在包安装完成后自动显示，如果忘了的话可以用这个命令很方便地查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew info $FORMULA    # 显示某个包的信息</span><br><span class="line">brew info             # 显示安装了包数量，文件数量，和总占用空间</span><br></pre></td></tr></table></figure>

<p><code>brew deps</code> 可以显示包的依赖关系，我常用它来查看已安装的包的依赖，然后判断哪些包是可以安全删除的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew deps --installed --tree # 查看已安装的包的依赖，树形显示</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elixir (required dependencies)</span><br><span class="line">└── :erlang</span><br><span class="line"></span><br><span class="line">wxmac (required dependencies)</span><br><span class="line">├── jpeg</span><br><span class="line">├── libpng</span><br><span class="line">│   └── xz</span><br><span class="line">└── libtiff</span><br><span class="line">    └── jpeg</span><br></pre></td></tr></table></figure>

<p>还有很多有用的命令和参数，没事 <code>man brew</code> 一下可以涨不少知识。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>不想更新 Homebrew 往往有两个原因，害怕潜在的风险和对工具的不熟悉，我之前也是这样。写这篇文章最开始是为了帮我记录常用的命令方便以后查阅的。希望它也能帮到你。</p>
]]></content>
      <categories>
        <category>系统设置</category>
      </categories>
      <tags>
        <tag>环境设置</tag>
      </tags>
  </entry>
  <entry>
    <title>安装CocoaPods</title>
    <url>/2018/01/29/2018-01-29-%E5%AE%89%E8%A3%85CocoaPods/</url>
    <content><![CDATA[<h4 id="更新系统的gem"><a href="#更新系统的gem" class="headerlink" title="更新系统的gem"></a>更新系统的gem</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gem update --system</span><br></pre></td></tr></table></figure>

<h4 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods"></a>安装CocoaPods</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure>

<h4 id="这时候可能会出现下面的错误"><a href="#这时候可能会出现下面的错误" class="headerlink" title="这时候可能会出现下面的错误"></a>这时候可能会出现下面的错误</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR:  While executing gem ... (Errno::EPERM)</span><br><span class="line">    Operation not permitted - &#x2F;usr&#x2F;bin&#x2F;fuzzy_match</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为在<code>OS X El Capitan</code>版本之后，之前的命令就不适用了，我们可以用如下的命令来安装CocoaPods</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gem install -n &#x2F;usr&#x2F;local&#x2F;bin cocoapods</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>系统设置</category>
      </categories>
      <tags>
        <tag>环境设置</tag>
      </tags>
  </entry>
  <entry>
    <title>终端命令启动Sublime Text 3 和 VS Code</title>
    <url>/2018/01/29/2018-01-29-%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E5%90%AF%E5%8A%A8Sublime%20Text%203%20%E5%92%8C%20VS%20Code/</url>
    <content><![CDATA[<p>加入软连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 如果你是sublime 2</span><br><span class="line">sudo ln -s <span class="string">&quot;/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl&quot;</span> /usr/<span class="built_in">local</span>/bin/subl </span><br><span class="line"></span><br><span class="line">// 如果你是sublime 3</span><br><span class="line">sudo ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/<span class="built_in">local</span>/bin/subl</span><br><span class="line"></span><br><span class="line">// vs code</span><br><span class="line">sudo ln -s /Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code /usr/<span class="built_in">local</span>/bin/code</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>系统设置</category>
      </categories>
      <tags>
        <tag>环境设置</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac中切换默认终端为zsh</title>
    <url>/2018/01/29/2018-01-29-%E5%88%87%E6%8D%A2%E9%BB%98%E8%AE%A4%E7%BB%88%E7%AB%AF%E4%B8%BAzsh/</url>
    <content><![CDATA[<p>mac os 系统默认的终端为bash，切换该终端为zsh，可以用以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>

<p>如过要切回默认终端bash则使用以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/bash</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>环境设置</tag>
      </tags>
  </entry>
  <entry>
    <title>终端制作Mac的安装U盘</title>
    <url>/2018/01/29/2018-01-29-%E5%88%B6%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85U%E7%9B%98/</url>
    <content><![CDATA[<p>制作安装U盘，只需执行如下命令：</p>
<p><code>san</code> 是你U盘的名字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;Applications&#x2F;Install\ macOS\ High\ Sierra.app&#x2F;Contents&#x2F;Resources&#x2F;createinstallmedia --volume &#x2F;Volumes&#x2F;san --applicationpath &#x2F;Applications&#x2F;Install\ macOS\ High\ Sierra.app --nointeraction</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>重装系统提示没有 Git 的解决方式</title>
    <url>/2018/01/29/2018-01-29-%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E6%8F%90%E7%A4%BA%E6%B2%A1%E6%9C%89%20Git%20%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>执行 git 命令后，提示信息如下：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br></pre></td></tr></table></figure>

<p>运行如下命令：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>

<p>等安装好了之后，git 就又可以用了。</p>
<p>如果不行可以试试下面的命令：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">xcode-select --reset</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>系统设置</category>
      </categories>
      <tags>
        <tag>环境设置</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduction to RxTest - tasanobu tech blog</title>
    <url>/2018/01/30/2018-01-30-Introduction%20to%20RxTest%20-%20tasanobu%20tech%20blog/</url>
    <content><![CDATA[<p>I had a <a href="https://speakerdeck.com/tasanobu/rxtestru-men">presentation (in Japanese)</a> about RxTest at <a href="https://connpass.com/event/41478/">RxSwift Meetup</a> held at Tokyo.<br>There does not seem to be lots of RxTest related materials on the web so I decided to translate the presentation into English and to write this post.</p>
<p> <strong>Notes</strong> </p>
<ul>
<li><p>This post is based on</p>
<ul>
<li>Xcode 8.1 / Swift 3.0</li>
<li>RxSwift 3.0.0</li>
<li>RxTest 3.0.0</li>
</ul>
</li>
<li><p>The code shown in this post is published on my GitHub repository <a href="https://github.com/tasanobu/RxTest-Samples">here</a> .</p>
</li>
</ul>
<a id="more"></a>

<h1 id="What-is-RxTest"><a href="#What-is-RxTest" class="headerlink" title="What is RxTest?"></a>What is RxTest?</h1><ul>
<li>RxTest is a test framework published at RxSwift repository.</li>
<li>Most(All?) of the unit testing in RxSwift is implemented with RxTest</li>
<li>RxTest is available for third-party like normal app developers and it’s easy to add it to your test target with Cocoapods by adding the code like below to your podfile.</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">target <span class="string">&#x27;RxTest-SampleTests&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    pod <span class="string">&#x27;RxTest&#x27;</span>,     <span class="string">&#x27;~&gt; 3.0&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;RxSwift&#x27;</span>,    <span class="string">&#x27;~&gt; 3.0&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;RxCocoa&#x27;</span>,    <span class="string">&#x27;~&gt; 3.0&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h1 id="Main-classes-of-RxTest"><a href="#Main-classes-of-RxTest" class="headerlink" title="Main classes of RxTest"></a>Main classes of RxTest</h1><h5 id="TestScheduler"><a href="#TestScheduler" class="headerlink" title="TestScheduler"></a>TestScheduler</h5><ul>
<li>is a scheduler in which virtual time is implemented.</li>
<li>emits events and executes arbitrary closures based on virtual time.</li>
<li>has factory methods to instantiate <code>TestableObserver</code> and <code>TestObservable</code></li>
</ul>
<h5 id="TestableObservable"><a href="#TestableObservable" class="headerlink" title="TestableObservable"></a>TestableObservable</h5><ul>
<li>is an observable sequence which has events sent to observer at the designated virtual time and records subscriptions(subscribe/unsubscribe) during its lifetime</li>
</ul>
<h5 id="TestableObserver"><a href="#TestableObserver" class="headerlink" title="TestableObserver"></a>TestableObserver</h5><ul>
<li>is an observer which records all emitted events together with virtual time when they were received.</li>
</ul>
<h1 id="Samples"><a href="#Samples" class="headerlink" title="Samples"></a>Samples</h1><p>Let’s see how to use the classes introduced above.</p>
<p><strong>map operator</strong></p>
<p>The following is the test code of map operetor in RxSwift (I simplified a little.)</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_map</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. Instantiate TestScheduler by designating virtual time 0</span></span><br><span class="line">    <span class="keyword">let</span> scheduler = <span class="type">TestScheduler</span>(initialClock: <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 2. Instantiate TestableObservable&lt;Int&gt;</span></span><br><span class="line">    <span class="comment">// by designating value together with virtual time.</span></span><br><span class="line">    <span class="keyword">let</span> observable = scheduler.createHotObservable([</span><br><span class="line">        next(<span class="number">150</span>, <span class="number">1</span>),  <span class="comment">// (virtual time, value)</span></span><br><span class="line">        next(<span class="number">210</span>, <span class="number">0</span>),</span><br><span class="line">        next(<span class="number">240</span>, <span class="number">4</span>),</span><br><span class="line">        completed(<span class="number">300</span>)</span><br><span class="line">        ])</span><br><span class="line">    <span class="comment">// 3. Instantiate TestableObserver&lt;Int&gt;</span></span><br><span class="line">    <span class="keyword">let</span> observer = scheduler.createObserver(<span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="comment">// 4. Make `observer` subscribe `observable` at virtual time 200</span></span><br><span class="line">    scheduler.scheduleAt(<span class="number">200</span>) &#123;</span><br><span class="line">        observable.<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">2</span> &#125;</span><br><span class="line">            .subscribe(observer)</span><br><span class="line">            .addDisposableTo(<span class="keyword">self</span>.disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. Start `scheduler`</span></span><br><span class="line">    scheduler.start()</span><br><span class="line">    <span class="keyword">let</span> expectedEvents = [</span><br><span class="line">        next(<span class="number">210</span>, <span class="number">0</span> * <span class="number">2</span>),</span><br><span class="line">        next(<span class="number">240</span>, <span class="number">4</span> * <span class="number">2</span>),</span><br><span class="line">        completed(<span class="number">300</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// 6-1. Compare the events which `observer` received</span></span><br><span class="line">    <span class="type">XCTAssertEqual</span>(observer.events, expectedEvents)</span><br><span class="line">    <span class="keyword">let</span> expectedSubscriptions = [</span><br><span class="line">        <span class="type">Subscription</span>(<span class="number">200</span>, <span class="number">300</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// 6-2. Compare the virtual times when `observable` was subscribed/unsubscribed</span></span><br><span class="line">    <span class="type">XCTAssertEqual</span>(observable.subscriptions, expectedSubscriptions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ViewModel-of-Github-follower-search-view"><a href="#ViewModel-of-Github-follower-search-view" class="headerlink" title="ViewModel of Github follower search view"></a>ViewModel of Github follower search view</h2><p>As a more practical example, let’s see the view model for Github follower search view.</p>
<p> <strong>ViewModel</strong></p>
<p>The following class is the view model for the view and it is the test target.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    <span class="comment">// api call status: .loading, .loaded, .error</span></span><br><span class="line">    <span class="keyword">var</span> state: <span class="type">Variable</span>&lt;<span class="type">State</span>&gt;  = <span class="type">Variable</span>(.loaded([]))</span><br><span class="line">    <span class="comment">// followers list</span></span><br><span class="line">    <span class="keyword">var</span> users: <span class="type">Variable</span>&lt;[<span class="type">User</span>]&gt; = <span class="type">Variable</span>([])</span><br><span class="line">    <span class="comment">// Client which has a web API logic</span></span><br><span class="line">    <span class="keyword">let</span> client: <span class="type">Client</span></span><br><span class="line">    <span class="keyword">init</span>(client: <span class="type">Client</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.client = client</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Action method to search followers</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">searchFollowers</span><span class="params">(ofUser user: String)</span></span> &#123;</span><br><span class="line">        state.value = .loading</span><br><span class="line">        client.fetchFollowers(ofUser: user)</span><br><span class="line">            .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">switch</span> event &#123;</span><br><span class="line">                <span class="keyword">case</span> .next(<span class="keyword">let</span> users) :</span><br><span class="line">                    <span class="keyword">self</span>.state.value = .loaded(users)</span><br><span class="line">                    <span class="keyword">self</span>.users.value = users</span><br><span class="line">                <span class="keyword">case</span> .error(<span class="keyword">let</span> e):</span><br><span class="line">                    <span class="keyword">self</span>.state.value = .error(e <span class="keyword">as</span>? <span class="type">Client</span>.<span class="type">Error</span> ?? .unknown)</span><br><span class="line">                    <span class="keyword">self</span>.users.value = []</span><br><span class="line">                <span class="keyword">default</span>: <span class="comment">// ignore `.completed`</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .addDisposableTo(disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There are 2 important points from unit testing perspective.</p>
<ol>
<li>Pass a <code>Client</code> object to <code>SearchModelView</code> ‘s initializer</li>
<li>Call <code>Client.fetchFollowers()</code> inside <code>SearchViewModel</code></li>
</ol>
<p><strong>Mock Client</strong></p>
<p>The following class is the mock object of <code>Client</code> which is used for unit testing.</p>
<p>The mock class inherits <code>Client</code> (in order to simplify the sample).<br>It has a property <code>response</code> which is a <code>TestableObservable</code> used as API response and overrides <code>fetchFollowers()</code> and returns <code>response</code> from it.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockClient</span>: <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Observable used as API response</span></span><br><span class="line">    <span class="keyword">let</span> response: <span class="type">TestableObservable</span>&lt;[<span class="type">User</span>]&gt;</span><br><span class="line">    <span class="keyword">init</span>(response: <span class="type">TestableObservable</span>&lt;[<span class="type">User</span>]&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.response = response</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">fetchFollowers</span><span class="params">(ofUser user: String)</span></span> -&gt; <span class="type">Observable</span>&lt;[<span class="type">User</span>]&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> response.asObservable()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Test-code-SearchViewModel-state"><a href="#Test-code-SearchViewModel-state" class="headerlink" title="Test code: SearchViewModel.state"></a>Test code: <code>SearchViewModel.state</code></h3><p>Below is the test sample of <code>SearchViewModel.state</code>.<br>The value of the property changes in response to <code>searchFollowers()</code> which causes network request.</p>
<p>The overall flow is almost the same as the previous example of <code>map</code> operator.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_state_when_searchFollowers_succeeded</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> users = [<span class="type">User</span>(id: <span class="number">12091114</span>, name: <span class="string">&quot;tunepolo&quot;</span>)]</span><br><span class="line">    <span class="comment">// 1. Instantiate TestableObserver</span></span><br><span class="line">    <span class="keyword">let</span> observer = scheduler.createObserver(<span class="type">State</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="comment">// 2. Instantiate TestableObservable</span></span><br><span class="line">    <span class="keyword">let</span> observable = scheduler.createColdObservable([</span><br><span class="line">        next(<span class="number">100</span>, users)</span><br><span class="line">        ])</span><br><span class="line">    <span class="comment">// 3. Instantiate MockClient with the observable</span></span><br><span class="line">    <span class="keyword">let</span> client = <span class="type">MockClient</span>(response: observable)</span><br><span class="line">    <span class="comment">// 4. Instantiate SearchViewModel with MockClient</span></span><br><span class="line">    <span class="keyword">let</span> viewModel = <span class="type">SearchViewModel</span>(client: client)</span><br><span class="line">    <span class="comment">// 5. Make `observer` subscribe `observable` at virtual time 100</span></span><br><span class="line">    scheduler.scheduleAt(<span class="number">100</span>) &#123;</span><br><span class="line">      viewModel.state.asObservable()</span><br><span class="line">          .subscribe(observer)</span><br><span class="line">          .addDisposableTo(<span class="keyword">self</span>.disposeBag)</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="comment">// 6. Call `viewModel.searchFollowers()` at virtual time 200</span></span><br><span class="line">    scheduler.scheduleAt(<span class="number">200</span>) &#123;</span><br><span class="line">        viewModel.searchFollowers(ofUser: <span class="string">&quot;tasanobu&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. Start `scheduler`</span></span><br><span class="line">    scheduler.start()</span><br><span class="line">    <span class="comment">// 8. Inspect the events that the observer received</span></span><br><span class="line">    <span class="keyword">let</span> expectedEvents = [</span><br><span class="line">        next(<span class="number">100</span>, <span class="type">State</span>.loaded([])),</span><br><span class="line">        next(<span class="number">200</span>, <span class="type">State</span>.loading),</span><br><span class="line">        next(<span class="number">300</span>, <span class="type">State</span>.loaded(users))</span><br><span class="line">    ]</span><br><span class="line">    <span class="type">XCTAssertEqual</span>(observer.events, expectedEvents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Wrap-up"><a href="#Wrap-up" class="headerlink" title="Wrap up"></a>Wrap up</h1><p>This post describes the overview of RxTest and the examples of unit testing with RxTest.<br>You might think it’s hard to get into unit testing of features implemented with RxSwift.<br>However, it’s doable to write such test code by following the steps below.</p>
<ol>
<li>Instantiate TestScheduler</li>
<li>As TestableObservable, instantiate an event sequence which you want to inspect</li>
<li>Instantiate TestableObserver which records events to be inspected</li>
<li>Make TestableObserver subscribe TestableObservable</li>
<li>Start TestScheduler</li>
<li>Inspect TestableObserver.events or TestableObservable.subscriptions depending on your test needs.</li>
</ol>
<p><strong>From:</strong> </p>
<ul>
<li><a href="https://tasanobu.github.io/blog/2016/11/19/introduction-to-rxtest/">Introduction to RxTest - tasanobu tech blog</a></li>
</ul>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
        <tag>RxTest</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习笔记（三）【基础补全】</title>
    <url>/2018/02/05/2018-02-05-Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%90%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%A8%E3%80%91/</url>
    <content><![CDATA[<h2 id="Python-基础语法"><a href="#Python-基础语法" class="headerlink" title="Python 基础语法"></a>Python 基础语法</h2><h3 id="Python-标识符"><a href="#Python-标识符" class="headerlink" title="Python 标识符"></a>Python 标识符</h3><hr>
<ul>
<li>在 Python 里，标识符由字母、数字、下划线组成。</li>
<li>在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。</li>
<li>Python 中的标识符是区分大小写的。</li>
<li>以下划线开头的标识符是有特殊意义的。以单下划线开头<code> _foo</code> 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用<code>from xxx import *</code> 而导入；</li>
<li>以双下划线开头的 <code>__foo</code> 代表类的私有成员；以双下划线开头和结尾的 <code>__foo__</code> 代表 Python 里特殊方法专用的标识，如 <code>__init__()</code> 代表类的构造函数。</li>
<li>Python 可以同一行显示多条语句，方法是用分号 <code>;</code> 分开，如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">&#x27;hello&#x27;</span>;<span class="built_in">print</span> <span class="string">&#x27;runoob&#x27;</span>;</span><br><span class="line">hello</span><br><span class="line">runoob</span><br></pre></td></tr></table></figure>

<a id="more"></a>


<h3 id="Python-引号"><a href="#Python-引号" class="headerlink" title="Python 引号"></a>Python 引号</h3><hr>
<ul>
<li>Python 可以使用引号( ‘ )、双引号( “ )、三引号( ‘’’ 或 “”” ) 来表示字符串，引号的开始与结束必须的相同类型的。</li>
<li>其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">word = <span class="string">&#x27;word&#x27;</span></span><br><span class="line">sentence = <span class="string">&quot;这是一个句子。&quot;</span></span><br><span class="line">paragraph = <span class="string">&quot;&quot;&quot;这是一个段落。</span></span><br><span class="line"><span class="string">包含了多个语句&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>


<h3 id="Python注释"><a href="#Python注释" class="headerlink" title="Python注释"></a>Python注释</h3><hr>
<ul>
<li>python 中多行注释使用三个单引号(‘’’)或三个双引号(“””)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment"># 文件名：test.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>


<h2 id="Python-变量类型"><a href="#Python-变量类型" class="headerlink" title="Python 变量类型"></a>Python 变量类型</h2><h3 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h3><hr>
<ul>
<li>在内存中存储的数据可以有多种类型。</li>
<li>例如，一个人的年龄可以用数字来存储，他的名字可以用字符来存储。</li>
<li>Python 定义了一些标准类型，用于存储各种类型的数据。</li>
<li>Python有五个标准的数据类型：<ol>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Dictionary（字典）</li>
</ol>
</li>
</ul>
<h3 id="Python数字"><a href="#Python数字" class="headerlink" title="Python数字"></a>Python数字</h3><hr>
<ul>
<li>数字数据类型用于存储数值。</li>
<li><strong>他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。</strong></li>
<li>当你指定一个值时，Number对象就会被创建：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var1 = <span class="number">1</span></span><br><span class="line">var2 = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>您也可以使用del语句删除一些对象的引用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del语句的语法是：</span><br><span class="line">del var1[,var2[,var3[....,varN]]]]</span><br></pre></td></tr></table></figure>

<ul>
<li>您可以通过使用del语句删除单个或多个对象的引用。例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> var</span><br><span class="line"><span class="keyword">del</span> var_a, var_b</span><br></pre></td></tr></table></figure>

<ul>
<li>Python支持四种不同的数字类型：<ol>
<li>int（有符号整型）</li>
<li>long（长整型[也可以代表八进制和十六进制]）</li>
<li>float（浮点型）</li>
<li>complex（复数）</li>
</ol>
</li>
<li>实例<br>一些数值类型的实例：<br>![](/my_pictures/2018-02-5-Python 学习笔记（三）【基础补全】-1.png)</li>
<li>长整型也可以使用小写 l，但是还是建议您使用大写 L，避免与数字 1 混淆。Python使用 L 来显示长整型。</li>
<li>Python 还支持复数，复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。</li>
</ul>
<h3 id="Python字符串"><a href="#Python字符串" class="headerlink" title="Python字符串"></a>Python字符串</h3><hr>
<ul>
<li>加号（+）是字符串连接运算符，星号（*）是重复操作。如下实例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>           <span class="comment"># 输出完整字符串</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">0</span>]        <span class="comment"># 输出字符串中的第一个字符</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>]      <span class="comment"># 输出字符串中第三个至第五个之间的字符串</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">2</span>:]       <span class="comment"># 输出从第三个字符开始的字符串</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span> * <span class="number">2</span>       <span class="comment"># 输出字符串两次</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span> + <span class="string">&quot;TEST&quot;</span>  <span class="comment"># 输出连接的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">Hello World!</span><br><span class="line">H</span><br><span class="line">llo</span><br><span class="line">llo World!</span><br><span class="line">Hello World!Hello World!</span><br><span class="line">Hello World!TEST</span><br></pre></td></tr></table></figure>


<h3 id="Python列表"><a href="#Python列表" class="headerlink" title="Python列表"></a>Python列表</h3><hr>
<ul>
<li>List（列表） 是 Python 中使用最频繁的数据类型。</li>
<li>列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。</li>
<li>列表用 [ ] 标识，是 python 最通用的复合数据类型。</li>
<li>列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。</li>
<li>加号 + 是列表连接运算符，星号 * 是重复操作。如下实例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>               <span class="comment"># 输出完整列表</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">0</span>]            <span class="comment"># 输出列表的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>]          <span class="comment"># 输出第二个至第三个元素 </span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span>[<span class="number">2</span>:]           <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="built_in">print</span> tinylist * <span class="number">2</span>       <span class="comment"># 输出列表两次</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">list</span> + tinylist    <span class="comment"># 打印组合的列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># [&#x27;runoob&#x27;, 786, 2.23, &#x27;john&#x27;, 70.2]</span></span><br><span class="line"><span class="comment"># runoob</span></span><br><span class="line"><span class="comment"># [786, 2.23]</span></span><br><span class="line"><span class="comment"># [2.23, &#x27;john&#x27;, 70.2]</span></span><br><span class="line"><span class="comment"># [123, &#x27;john&#x27;, 123, &#x27;john&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;runoob&#x27;, 786, 2.23, &#x27;john&#x27;, 70.2, 123, &#x27;john&#x27;]</span></span><br></pre></td></tr></table></figure>


<h3 id="Python元组"><a href="#Python元组" class="headerlink" title="Python元组"></a>Python元组</h3><hr>
<p>元组是另一个数据类型，类似于List（列表）。<br>元组用”()”标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>               <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">0</span>]            <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">3</span>]          <span class="comment"># 输出第二个至第三个的元素 </span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span>[<span class="number">2</span>:]           <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="built_in">print</span> tinytuple * <span class="number">2</span>       <span class="comment"># 输出元组两次</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">tuple</span> + tinytuple   <span class="comment"># 打印组合的元组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># (&#x27;runoob&#x27;, 786, 2.23, &#x27;john&#x27;, 70.2)</span></span><br><span class="line"><span class="comment"># runoob</span></span><br><span class="line"><span class="comment"># (786, 2.23)</span></span><br><span class="line"><span class="comment"># (2.23, &#x27;john&#x27;, 70.2)</span></span><br><span class="line"><span class="comment"># (123, &#x27;john&#x27;, 123, &#x27;john&#x27;)</span></span><br><span class="line"><span class="comment"># (&#x27;runoob&#x27;, 786, 2.23, &#x27;john&#x27;, 70.2, 123, &#x27;john&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>以下是元组无效的，因为元组是不允许更新的。而列表是允许更新的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> )</span><br><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;runoob&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line"><span class="built_in">tuple</span>[<span class="number">2</span>] = <span class="number">1000</span>    <span class="comment"># 元组中是非法应用</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">1000</span>     <span class="comment"># 列表中是合法应用</span></span><br></pre></td></tr></table></figure>


<h3 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h3><hr>
<p>![](/my_pictures/2018-02-5-Python 学习笔记（三）【基础补全】-2.png)</p>
<h2 id="Python-运算符"><a href="#Python-运算符" class="headerlink" title="Python 运算符"></a>Python 运算符</h2><h3 id="Python算术运算符"><a href="#Python算术运算符" class="headerlink" title="Python算术运算符"></a>Python算术运算符</h3><hr>
<p>![](/my_pictures/2018-02-5-Python 学习笔记（三）【基础补全】-3.png)</p>
<p><strong>注意：Python2.x 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1.0</span>/<span class="number">2</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="built_in">float</span>(<span class="number">2</span>)</span><br><span class="line"><span class="number">0.5</span></span><br></pre></td></tr></table></figure>


<h3 id="Python位运算符"><a href="#Python位运算符" class="headerlink" title="Python位运算符"></a>Python位运算符</h3><hr>
<p>按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：<br>下表中变量 a 为 60，b 为 13，二进制格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = 0011 <span class="number">1100</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">0000</span> <span class="number">1101</span></span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">a&amp;b = <span class="number">0000</span> <span class="number">1100</span></span><br><span class="line"></span><br><span class="line">a|b = 0011 <span class="number">1101</span></span><br><span class="line"></span><br><span class="line">a^b = 0011 0001</span><br><span class="line"></span><br><span class="line">~a  = <span class="number">1100</span> 0011</span><br></pre></td></tr></table></figure>

<p>![](/my_pictures/2018-02-5-Python 学习笔记（三）【基础补全】-4.png)</p>
<h3 id="Python逻辑运算符"><a href="#Python逻辑运算符" class="headerlink" title="Python逻辑运算符"></a>Python逻辑运算符</h3><hr>
<p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p>
<p>![](/my_pictures/2018-02-5-Python 学习笔记（三）【基础补全】-5.png)</p>
<h3 id="Python成员运算符"><a href="#Python成员运算符" class="headerlink" title="Python成员运算符"></a>Python成员运算符</h3><hr>
<p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p>
<p>![](/my_pictures/2018-02-5-Python 学习笔记（三）【基础补全】-6.png)</p>
<h2 id="Python身份运算符"><a href="#Python身份运算符" class="headerlink" title="Python身份运算符"></a>Python身份运算符</h2><hr>
<p>身份运算符用于比较两个对象的存储单元</p>
<p>![](/my_pictures/2018-02-5-Python 学习笔记（三）【基础补全】-7.png)</p>
<p><strong>is 与 == 区别：</strong><br>is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b == a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b == a</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Python学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Pod Search 出现 JSON ParserError 错误</title>
    <url>/2018/02/07/2018-02-07-Pod%20Search%20%E5%87%BA%E7%8E%B0%20JSON%20ParserError%20%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>今天执行 <code>pod search</code> 命令的时候出现了 <code>JSON ParserError</code> 的错误，类似于如下：</p>
<h3 id="Report"><a href="#Report" class="headerlink" title="Report"></a>Report</h3><ul>
<li>Run pod search PureLayout</li>
<li>List the search result</li>
<li>can not get the result list, and shows JSON::ParserError - A JSON text must at least contain two octets!</li>
</ul>
<a id="more"></a>

<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CocoaPods : 1.0.0.beta.8</span><br><span class="line">        Ruby : ruby 2.3.0p0 (2015-12-25 revision 53290) [x86_64-darwin15]</span><br><span class="line">    RubyGems : 2.5.1</span><br><span class="line">        Host : Mac OS X 10.11.4 (15E65)</span><br><span class="line">       Xcode : 7.3 (7D175)</span><br><span class="line">         Git : git version 2.6.4 (Apple Git-63)</span><br><span class="line">Ruby lib dir : /Users/name/.rvm/rubies/ruby-2.3.0/lib</span><br><span class="line">Repositories : master - https://github.com/CocoaPods/Specs.git @ d8648f8172b778faf0b1fab50c1026c4d7dfa36a</span><br></pre></td></tr></table></figure>

<h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cocoapods-deintegrate : 1.0.0.beta.1</span><br><span class="line">cocoapods-plugins     : 1.0.0.beta.1</span><br><span class="line">cocoapods-search      : 1.0.0.beta.2</span><br><span class="line">cocoapods-stats       : 1.0.0.beta.4</span><br><span class="line">cocoapods-trunk       : 1.0.0.beta.4</span><br><span class="line">cocoapods-try         : 1.0.0.beta.4</span><br></pre></td></tr></table></figure>

<h3 id="Podfile"><a href="#Podfile" class="headerlink" title="Podfile"></a>Podfile</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Uncomment this line to define a global platform for your project</span></span><br><span class="line">platform :ios, <span class="string">&#x27;8.0&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;MapleStory&#x27;</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">&#x27;AFNetworking&#x27;</span>, <span class="string">&#x27;~&gt; 3.1.0&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;SDWebImage&#x27;</span>, <span class="string">&#x27;~&gt; 3.7.5&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;SVProgressHUD&#x27;</span>, <span class="string">&#x27;~&gt; 2.0.2&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;PureLayout&#x27;</span>, <span class="string">&#x27;~&gt; 3.0.1&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;MJRefresh&#x27;</span>, <span class="string">&#x27;~&gt; 3.1.0&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;UICKeyChainStore&#x27;</span>, <span class="string">&#x27;~&gt; 2.1.0&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;ReactiveCocoa&#x27;</span>, <span class="string">&#x27;~&gt; 2.5&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;JSONModel&#x27;</span>, <span class="string">&#x27;~&gt; 1.2.0&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;DZNEmptyDataSet&#x27;</span>, <span class="string">&#x27;~&gt; 1.7.3&#x27;</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;MapleStoryTests&#x27;</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;MapleStoryUITests&#x27;</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">JSON::ParserError - A JSON text must at least contain two octets!</span><br><span class="line">/Users/name/.rvm/rubies/ruby-2.3.0/lib/ruby/2.3.0/json/common.rb:156:<span class="keyword">in</span> `initialize<span class="string">&#x27;</span></span><br><span class="line"><span class="string">/Users/name/.rvm/rubies/ruby-2.3.0/lib/ruby/2.3.0/json/common.rb:156:in `new&#x27;</span></span><br><span class="line">/Users/name/.rvm/rubies/ruby-2.3.0/lib/ruby/2.3.0/json/common.rb:156:<span class="keyword">in</span> `parse<span class="string">&#x27;</span></span><br><span class="line"><span class="string">/Users/name/.rvm/gems/ruby-2.3.0/gems/cocoapods-core-1.0.0.beta.8/lib/cocoapods-core/source/manager.rb:251:in `stored_search_index&#x27;</span></span><br><span class="line">/Users/name/.rvm/gems/ruby-2.3.0/gems/cocoapods-core-1.0.0.beta.8/lib/cocoapods-core/<span class="built_in">source</span>/manager.rb:187:<span class="keyword">in</span> `updated_search_index<span class="string">&#x27;</span></span><br><span class="line"><span class="string">/Users/name/.rvm/gems/ruby-2.3.0/gems/cocoapods-core-1.0.0.beta.8/lib/cocoapods-core/source/manager.rb:118:in `search_by_name&#x27;</span></span><br><span class="line">/Users/name/.rvm/gems/ruby-2.3.0/gems/cocoapods-search-1.0.0.beta.2/lib/cocoapods-search/<span class="built_in">command</span>/search.rb:85:<span class="keyword">in</span> `local_search<span class="string">&#x27;</span></span><br><span class="line"><span class="string">/Users/name/.rvm/gems/ruby-2.3.0/gems/cocoapods-search-1.0.0.beta.2/lib/cocoapods-search/command/search.rb:61:in `run&#x27;</span></span><br><span class="line">/Users/name/.rvm/gems/ruby-2.3.0/gems/claide-1.0.0.beta.3/lib/claide/command.rb:334:<span class="keyword">in</span> `run<span class="string">&#x27;</span></span><br><span class="line"><span class="string">/Users/name/.rvm/gems/ruby-2.3.0/gems/cocoapods-1.0.0.beta.8/lib/cocoapods/command.rb:50:in `run&#x27;</span></span><br><span class="line">/Users/name/.rvm/gems/ruby-2.3.0/gems/cocoapods-1.0.0.beta.8/bin/pod:44:<span class="keyword">in</span> `&lt;top (required)&gt;<span class="string">&#x27;</span></span><br><span class="line"><span class="string">/Users/name/.rvm/gems/ruby-2.3.0/bin/pod:23:in `load&#x27;</span></span><br><span class="line">/Users/name/.rvm/gems/ruby-2.3.0/bin/pod:23:<span class="keyword">in</span> `&lt;main&gt;<span class="string">&#x27;</span></span><br><span class="line"><span class="string">/Users/name/.rvm/gems/ruby-2.3.0/bin/ruby_executable_hooks:15:in `eval&#x27;</span></span><br><span class="line">/Users/name/.rvm/gems/ruby-2.3.0/bin/ruby_executable_hooks:15:<span class="keyword">in</span> `&lt;main&gt;<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p>解决方式也十分的简单：</p>
<h3 id="删除检索文件即可"><a href="#删除检索文件即可" class="headerlink" title="删除检索文件即可"></a>删除检索文件即可</h3><ul>
<li>查看 <code>~/Library/Caches/CocoaPods</code>  目录下是否有 <code>search_index.json</code> 文件，删除即可。</li>
<li>或者执行下面的命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rm ~/Library/Caches/CocoaPods/search_index.json</span><br></pre></td></tr></table></figure>

<ul>
<li>之后再次执行 <code>pod search xxx</code> 命令即可。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://github.com/CocoaPods/CocoaPods/issues/5172">pod search not work JSON ParserError · Issue #5172 · CocoaPods/CocoaPods</a></li>
</ul>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>iOS工作日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习笔记（五）【函数】</title>
    <url>/2018/02/07/2018-02-07-Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%90%E5%87%BD%E6%95%B0%E3%80%91/</url>
    <content><![CDATA[<h3 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h3><hr>
<p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p>
<ul>
<li>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。</li>
<li>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li>
<li>函数内容以冒号起始，并且缩进。</li>
<li>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li>
</ul>
<a id="more"></a>

<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><hr>
<p>在 python 中，类型属于对象，变量是没有类型的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a = <span class="string">&quot;Runoob&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。</strong></p>
<h3 id="可更改-mutable-与不可更改-immutable-对象"><a href="#可更改-mutable-与不可更改-immutable-对象" class="headerlink" title="可更改(mutable)与不可更改(immutable)对象"></a>可更改(mutable)与不可更改(immutable)对象</h3><hr>
<p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p>
<ul>
<li><em>不可变类型</em>：变量赋值 a=5 后再赋值 a=10，<strong>这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。</strong></li>
<li><em>可变类型</em>：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li>
</ul>
<p>python 函数的参数传递：</p>
<ul>
<li><strong>不可变类型</strong>：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</li>
<li><strong>可变类型</strong>：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</li>
</ul>
<p><strong>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</strong></p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><hr>
<h5 id="必备参数"><a href="#必备参数" class="headerlink" title="必备参数"></a>必备参数</h5><p>必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。<br>调用printme()函数，你必须传入一个参数，不然会出现语法错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span>(<span class="params"> <span class="built_in">str</span> </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> <span class="built_in">str</span>;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printme函数</span></span><br><span class="line">printme();</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    printme();</span><br><span class="line">TypeError: printme() takes exactly <span class="number">1</span> argument (<span class="number">0</span> given)</span><br></pre></td></tr></table></figure>

<h5 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h5><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。<br><strong>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</strong><br>以下实例在函数 printme() 调用时使用参数名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span>(<span class="params"> <span class="built_in">str</span> </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> <span class="built_in">str</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printme函数</span></span><br><span class="line">printme( <span class="built_in">str</span> = <span class="string">&quot;My string&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">My string</span><br></pre></td></tr></table></figure>

<p>下例能将关键字参数顺序不重要展示得更清楚：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> name, age </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;Name: &quot;</span>, name</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;Age &quot;</span>, age</span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;miki&quot;</span> )</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Name:  miki</span><br><span class="line">Age  <span class="number">50</span></span><br></pre></td></tr></table></figure>

<h5 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h5><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span>(<span class="params">[formal_args,] *var_args_tuple </span>):</span></span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure>

<p>加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_var_info</span>(<span class="params">arg1, *vartuple</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;不定长参数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;输出:&quot;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;arg1: &quot;</span>, arg1</span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;var: &quot;</span>, var</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">print_var_info(<span class="number">10</span>)</span><br><span class="line">print_var_info(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># arg1:  10</span></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># arg1:  10</span></span><br><span class="line"><span class="comment"># var:  20</span></span><br><span class="line"><span class="comment"># var:  30</span></span><br></pre></td></tr></table></figure>

<h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>python 使用 lambda 来创建匿名函数。</p>
<ul>
<li>lambda只是一个表达式，函数体比def简单很多。</li>
<li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li>
<li>lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</li>
<li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li>
</ul>
<p><strong>语法</strong><br>lambda函数的语法只包含一个语句，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression</span><br></pre></td></tr></table></figure>

<p>如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">20</span>, <span class="number">20</span> )</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">相加后的值为 :  <span class="number">30</span></span><br><span class="line">相加后的值为 :  <span class="number">40</span></span><br></pre></td></tr></table></figure>

<p>补充：<br>    在Python中，有 filter，map，reduce方法，lambda用于此方法中如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = [<span class="number">2</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">22</span>, <span class="number">17</span>, <span class="number">24</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">27</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">3</span> == <span class="number">0</span>, foo)</span><br><span class="line">[<span class="number">18</span>, <span class="number">9</span>, <span class="number">24</span>, <span class="number">12</span>, <span class="number">27</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * <span class="number">2</span> + <span class="number">10</span>, foo)</span><br><span class="line">[<span class="number">14</span>, <span class="number">46</span>, <span class="number">28</span>, <span class="number">54</span>, <span class="number">44</span>, <span class="number">58</span>, <span class="number">26</span>, <span class="number">34</span>, <span class="number">64</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> reduce(<span class="keyword">lambda</span> x, y: x + y, foo)</span><br><span class="line"><span class="number">139</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Python学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习笔记（四）【日期和时间】</title>
    <url>/2018/02/06/2018-02-06-Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%90%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E3%80%91/</url>
    <content><![CDATA[<h3 id="获取格式化的时间"><a href="#获取格式化的时间" class="headerlink" title="获取格式化的时间"></a>获取格式化的时间</h3><hr>
<p>你可以根据需求选取各种格式，但是最简单的获取可读的时间模式的函数是asctime():</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">localtime = time.asctime( time.localtime(time.time()) )</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;本地时间为 :&quot;</span>, localtime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># 本地时间为 : Thu Apr  7 10:05:21 2016</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>


<h3 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h3><hr>
<p>我们可以使用 time 模块的 strftime 方法来格式化日期：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化成2016-03-20 11:45:39形式</span></span><br><span class="line"><span class="built_in">print</span> time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime()) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化成Sat Mar 28 22:24:24 2016形式</span></span><br><span class="line"><span class="built_in">print</span> time.strftime(<span class="string">&quot;%a %b %d %H:%M:%S %Y&quot;</span>, time.localtime()) </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 将格式字符串转换为时间戳</span></span><br><span class="line">a = <span class="string">&quot;Sat Mar 28 22:24:24 2016&quot;</span></span><br><span class="line"><span class="built_in">print</span> time.mktime(time.strptime(a,<span class="string">&quot;%a %b %d %H:%M:%S %Y&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># 2016-04-07 10:25:09</span></span><br><span class="line"><span class="comment"># Thu Apr 07 10:25:09 2016</span></span><br><span class="line"><span class="comment"># 1459175064.0</span></span><br></pre></td></tr></table></figure>


<h3 id="Python中时间日期格式化符号"><a href="#Python中时间日期格式化符号" class="headerlink" title="Python中时间日期格式化符号"></a>Python中时间日期格式化符号</h3><hr>
<ul>
<li>%y 两位数的年份表示（00-99）</li>
<li>%Y 四位数的年份表示（000-9999）</li>
<li>%m 月份（01-12）</li>
<li>%d 月内中的一天（0-31）</li>
<li>%H 24小时制小时数（0-23）</li>
<li>%I 12小时制小时数（01-12）</li>
<li>%M 分钟数（00=59）</li>
<li>%S 秒（00-59）</li>
<li>%a 本地简化星期名称</li>
<li>%A 本地完整星期名称</li>
<li>%b 本地简化的月份名称</li>
<li>%B 本地完整的月份名称</li>
<li>%c 本地相应的日期表示和时间表示</li>
<li>%j 年内的一天（001-366）</li>
<li>%p 本地A.M.或P.M.的等价符</li>
<li>%U 一年中的星期数（00-53）星期天为星期的开始</li>
<li>%w 星期（0-6），星期天为星期的开始</li>
<li>%W 一年中的星期数（00-53）星期一为星期的开始</li>
<li>%x 本地相应的日期表示</li>
<li>%X 本地相应的时间表示</li>
<li>%Z 当前时区的名称</li>
<li>%% %号本身</li>
</ul>
<h3 id="获取某月日历"><a href="#获取某月日历" class="headerlink" title="获取某月日历"></a>获取某月日历</h3><hr>
<p>Calendar模块有很广泛的方法用来处理年历和月历，例如打印某月的月历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line"></span><br><span class="line">cal = calendar.month(<span class="number">2016</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;以下输出2016年1月份的日历:&quot;</span></span><br><span class="line"><span class="built_in">print</span> cal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># 以下输出2016年1月份的日历:</span></span><br><span class="line"><span class="comment">#     January 2016</span></span><br><span class="line"><span class="comment"># Mo Tu We Th Fr Sa Su</span></span><br><span class="line"><span class="comment">#              1  2  3</span></span><br><span class="line"><span class="comment">#  4  5  6  7  8  9 10</span></span><br><span class="line"><span class="comment"># 11 12 13 14 15 16 17</span></span><br><span class="line"><span class="comment"># 18 19 20 21 22 23 24</span></span><br><span class="line"><span class="comment"># 25 26 27 28 29 30 31</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Python学习</tag>
      </tags>
  </entry>
  <entry>
    <title>ShareSDK 回调一直是 SSDKResponseStateCancel</title>
    <url>/2018/02/07/2018-02-07-ShareSDK%20%E5%9B%9E%E8%B0%83%E4%B8%80%E7%9B%B4%E6%98%AF%20SSDKResponseStateCancel/</url>
    <content><![CDATA[<p>之前解决了，点击登录无反应的 <code>ShareSDK</code> 问题，今天又碰到了点击登陆后回调的 <code>SSDKResponseState</code> 参数一直都是 <code>cancel</code> 的问题。</p>
<p>刚开始以为是我的配置文件出现了问题，一直修改 <code>info.plist</code> 文件，但是问题依旧。问了技术支持，说让我升级到最新的版本，我又 <code>pod update</code>  一下，确实是最新的版本。之后觉得可能我的 <code>repo</code>  不是最新的，又更新了我的 <code>repo</code> ，发现还是不行。我看了一下 <code>sharesdk </code> 的版本，确实是<strong>4.0.4</strong>最新的没错啊，之后在 GitHub 上看 sharesdk 最新版本的时候，无意间看到了 sharesdk 名字改成了 <code>mob_sharesdk</code> 最新版本是<strong>4.0.9</strong>，终于知道原因了。</p>
<a id="more"></a>

<h4 id="我之前的写法："><a href="#我之前的写法：" class="headerlink" title="我之前的写法："></a>我之前的写法：</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;ShareSDK3&#x27;</span>, <span class="string">&#x27;~&gt; 4.0.4&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="更改后"><a href="#更改后" class="headerlink" title="更改后"></a>更改后</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;mob_sharesdk&#x27;</span>, <span class="string">&#x27;~&gt; 4.0.9&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pod update</span><br></pre></td></tr></table></figure>

<p>重新进行第三方登陆，终于可以了😭</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>iOS工作日志</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 原生实现扫描二维码和条形码功能，限制扫描区域</title>
    <url>/2018/02/08/2018-02-08-iOS%20%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%92%8C%E6%9D%A1%E5%BD%A2%E7%A0%81%E5%8A%9F%E8%83%BD%EF%BC%8C%E9%99%90%E5%88%B6%E6%89%AB%E6%8F%8F%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<blockquote>
<p>现在苹果iOS系统已经原生支持了二维码扫描的功能，使用原生来扫描需要导入 <strong>AVFoundation</strong> 。  </p>
</blockquote>
<h3 id="扫描准备"><a href="#扫描准备" class="headerlink" title="扫描准备"></a>扫描准备</h3><hr>
<p><strong>一、获取摄像设备：</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">device = <span class="type">AVCaptureDevice</span>.defaultDevice(withMediaType: <span class="type">AVMediaTypeVideo</span>)</span><br></pre></td></tr></table></figure>

<p><strong>二、创建输入流</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> input = <span class="type">AVCaptureDeviceInput</span>(device: device)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> e <span class="keyword">as</span> <span class="type">NSError</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(e.localizedDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>三、创建输出流</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">output = <span class="type">AVCaptureMetadataOutput</span>()</span><br><span class="line"><span class="comment">// 设置代理在主线程中刷新</span></span><br><span class="line">output?.setMetadataObjectsDelegate(<span class="keyword">self</span>, queue: <span class="type">DispatchQueue</span>.main)</span><br></pre></td></tr></table></figure>

<p><strong>四、初始化连接对象</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">session = <span class="type">AVCaptureSession</span>()</span><br><span class="line"><span class="comment">// 高质量采集率</span></span><br><span class="line">session?.canSetSessionPreset(<span class="type">AVCaptureSessionPresetHigh</span>)</span><br><span class="line">session?.addOutput(output)</span><br><span class="line">session?.addInput(input)</span><br></pre></td></tr></table></figure>

<p><strong>五、设置扫描区域</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 特别注意的地方：有效的扫描区域，定位是以设置的右顶点为原点。屏幕宽所在的那条线为y轴，屏幕高所在的线为x轴</span></span><br><span class="line"><span class="keyword">let</span> x = ((<span class="type">SCREENHeight</span> - <span class="type">QRCodeWidth</span> - topViewHeight) / <span class="number">2.0</span>) / <span class="type">SCREENHeight</span></span><br><span class="line"><span class="keyword">let</span> y = ((<span class="type">SCREENWidth</span> - <span class="type">QRCodeWidth</span>) / <span class="number">2.0</span>) / <span class="type">SCREENWidth</span></span><br><span class="line"><span class="keyword">let</span> width = <span class="type">QRCodeWidth</span> / <span class="type">SCREENHeight</span></span><br><span class="line"><span class="keyword">let</span> height = <span class="type">QRCodeWidth</span> / <span class="type">SCREENWidth</span></span><br><span class="line">output?.rectOfInterest = <span class="type">CGRect</span>(x: x, y: y, width: width, height: height)</span><br></pre></td></tr></table></figure>

<p><strong>六、设置扫码支持的编码格式(如下设置条形码和二维码兼容)</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">output?.metadataObjectTypes = [<span class="type">AVMetadataObjectTypeQRCode</span>, <span class="type">AVMetadataObjectTypeEAN13Code</span>, <span class="type">AVMetadataObjectTypeEAN8Code</span>, <span class="type">AVMetadataObjectTypeCode128Code</span>]</span><br></pre></td></tr></table></figure>

<p><strong>七、开始捕获</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">preview = <span class="type">AVCaptureVideoPreviewLayer</span>(session: session)</span><br><span class="line">preview?.videoGravity = <span class="type">AVLayerVideoGravityResizeAspectFill</span></span><br><span class="line">preview?.frame = <span class="keyword">self</span>.view.layer.bounds</span><br><span class="line"><span class="keyword">self</span>.view.layer.insertSublayer(preview!, at: <span class="number">0</span>)</span><br><span class="line">session?.startRunning()</span><br></pre></td></tr></table></figure>

<h3 id="扫描动画"><a href="#扫描动画" class="headerlink" title="扫描动画"></a>扫描动画</h3><hr>
<blockquote>
<p>这里的动画是仿支付宝的扫描框动画  </p>
</blockquote>
<p>我们新建一个方法，专门处理我们的动画。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">scanAnimation</span><span class="params">()</span></span> -&gt; <span class="type">CABasicAnimation</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> scanNetAnimation = <span class="type">CABasicAnimation</span>()</span><br><span class="line">        <span class="comment">// 沿Y轴运动</span></span><br><span class="line">     scanNetAnimation.keyPath = <span class="string">&quot;transform.translation.y&quot;</span></span><br><span class="line">     <span class="comment">// 扫描框的高度，注意：这里是实际高度的相反数</span></span><br><span class="line">     scanNetAnimation.byValue = <span class="type">QRCodeWidth</span></span><br><span class="line">       <span class="comment">// 动画的持续时间</span></span><br><span class="line">     scanNetAnimation.duration = <span class="number">1.5</span></span><br><span class="line">     <span class="comment">// 动画的重复次数</span></span><br><span class="line">     scanNetAnimation.repeatCount = <span class="type">MAXFLOAT</span></span><br><span class="line">        </span><br><span class="line">     <span class="keyword">return</span> scanNetAnimation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用动画：</p>
<p>我们在创建界面的时候，扫描框有一个UIImageView，我们需要将我们的动画添加到这个ImageView上面。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">scanImageView?.layer.add(scanAnimation(), forKey: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<h3 id="扫描之后的处理"><a href="#扫描之后的处理" class="headerlink" title="扫描之后的处理"></a>扫描之后的处理</h3><hr>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">captureOutput</span><span class="params">(<span class="keyword">_</span> captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [<span class="keyword">Any</span>]!, from connection: AVCaptureConnection!)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> metadataObjects.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        session?.stopRunning()</span><br><span class="line">        <span class="keyword">let</span> metadataObject = metadataObjects[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">AnyObject</span></span><br><span class="line">        <span class="keyword">let</span> stringValue: <span class="type">String</span> = metadataObject.stringValue</span><br><span class="line">        <span class="keyword">let</span> vc = <span class="type">QRCodeResultViewController</span>.instantiate()</span><br><span class="line">        vc.resultStr = stringValue</span><br><span class="line">        <span class="keyword">self</span>.navigationController?.pushViewController(vc, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="点击扫描结果的处理"><a href="#点击扫描结果的处理" class="headerlink" title="点击扫描结果的处理"></a>点击扫描结果的处理</h3><hr>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="keyword">_</span> webView: UIWebView, shouldStartLoadWith request: URLRequest, navigationType: UIWebViewNavigationType)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> requestURL = request.url</span><br><span class="line">    <span class="keyword">if</span> requestURL?.scheme == <span class="string">&quot;http&quot;</span> || requestURL?.scheme == <span class="string">&quot;https&quot;</span> || requestURL?.scheme == <span class="string">&quot;mailto&quot;</span> &amp;&amp; navigationType == .linkClicked &#123;</span><br><span class="line"><span class="comment">//        UIApplication.shared.open(requestURL!, options: [:], completionHandler: nil)</span></span><br><span class="line">        <span class="keyword">let</span> svc = <span class="type">SFSafariViewController</span>(url: requestURL!)</span><br><span class="line">        <span class="keyword">self</span>.present(svc, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(<span class="keyword">_</span> url: URL, options: [String : <span class="keyword">Any</span>] = [:], completionHandler completion: <span class="params">(<span class="params">(Bool)</span></span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>)? = <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>在Safari中打开连接。不过最好是把事件控制在自己的程序中，在iOS 9 之后，苹果引入了 SFSafariViewController 这个类，可以用这个类来显示需要浏览的网页。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> svc = <span class="type">SFSafariViewController</span>(url: requestURL!)</span><br><span class="line"><span class="keyword">self</span>.present(svc, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS学习—强引用（__strong）和 弱引用（__weak）</title>
    <url>/2018/02/08/2018-02-08-iOS%E5%AD%A6%E4%B9%A0%E2%80%94%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%88__strong%EF%BC%89%E5%92%8C%20%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88__weak%EF%BC%89/</url>
    <content><![CDATA[<p>在Objective-C的ARC模式中，</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> obj1 = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure>

<p>这里虽然没有显示的声明为 <code>__strong</code> ，但是 <code>Objective-C</code> 默认声明的一个对象就为 <code>__strong</code> ，即：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> obj1 = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj1 = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>是等价的。</p>
<p>在强引用中，有时会出现循环引用的情况，这时就需要弱引用来帮忙（ <code>__weak</code> ）。</p>
<p>强引用持有对象，弱引用不持有对象。</p>
<p>强引用可以释放对象，但弱引用不可以，因为弱引用不持有对象，当弱引用指向一个强引用所持有的对象时，当强引用将对象释放掉后，弱引用会自动的被赋值为nil，即弱引用会自动的指向nil。</p>
<p>下面用代码来说明：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"><span class="comment">//  ARC中的强引用和弱引用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by on 15/3/31.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2015年 apple. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">id</span> __<span class="keyword">weak</span> obj0 = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">            <span class="keyword">id</span> obj1 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">            obj0 = obj1;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;obj0: %@&quot;</span>, obj0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;obj0: %@&quot;</span>, obj0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  输出结果</span></span><br><span class="line"><span class="comment"> *  obj0: &lt;NSObject: 0x1003066c0&gt;</span></span><br><span class="line"><span class="comment"> *  obj0: (null)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  因为obj1生成的默认的为强引用(__strong)，在超出if的作用域之后，obj1所持有的对象被释放，</span></span><br><span class="line"><span class="comment"> *  obj0为弱引用，所以obj0不持有对象，在obj1对象释放后，obj0自动的被赋值为nil</span></span><br><span class="line"><span class="comment"> *  弱引用的特性是，不持有对象，即便是写成id __weak obj1 = [[NSObject alloc] init];</span></span><br><span class="line"><span class="comment"> *  此代码系统会给与警告，因为这里obj1被声明成弱引用，那么在赋值之后，alloc出来的对象会被立即释放。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义OS X的window button</title>
    <url>/2018/02/08/2018-02-08-%E8%87%AA%E5%AE%9A%E4%B9%89OS%20X%E7%9A%84window%20button/</url>
    <content><![CDATA[<blockquote>
<p>由于项目原来的设计，导致在OS X 10.10之后的系统上会出现一些奇怪的Bug，调用<code>- addSubview:positioned:relativeTo:</code>方法却并没有实现将视图放在最上层。经过不断的查找，才知道，子视图的父视图并没有被显示出来，导致了<code>- addSubview:positioned:relativeTo:</code>方法不起作用。那么如果将父视图显示出来的话，window button（关闭按钮，最小化按钮，全屏按钮，最大化窗口按钮）又会被遮盖掉，无奈，需要自定义window button。</p>
</blockquote>
<h3 id="在自定义之前一定要将系统自动创建的按钮关闭"><a href="#在自定义之前一定要将系统自动创建的按钮关闭" class="headerlink" title="在自定义之前一定要将系统自动创建的按钮关闭"></a>在自定义之前一定要将系统自动创建的按钮关闭</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="keyword">self</span>.window standardWindowButton:<span class="built_in">NSWindowCloseButton</span>] setEnabled:<span class="literal">NO</span>];</span><br><span class="line">[[<span class="keyword">self</span>.window standardWindowButton:<span class="built_in">NSWindowMiniaturizeButton</span>] setEnabled:<span class="literal">NO</span>];</span><br><span class="line">[[<span class="keyword">self</span>.window standardWindowButton:<span class="built_in">NSWindowFullScreenButton</span>] setEnabled:<span class="literal">NO</span>];</span><br><span class="line">[[<span class="keyword">self</span>.window standardWindowButton:<span class="built_in">NSWindowZoomButton</span>] setEnabled:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="自定义左上角的三个控制按钮"><a href="#自定义左上角的三个控制按钮" class="headerlink" title="自定义左上角的三个控制按钮"></a>自定义左上角的三个控制按钮</h3><p>这里我是将三个按钮写到了一个自定义View中，方便布局用。</p>
<p>首先是头文件中声明：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CustomWindowButtonView</span> : <span class="title">NSView</span> </span>&#123;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> mouseInside_;</span><br><span class="line">    <span class="built_in">NSButton</span> *closeButton_;</span><br><span class="line">    <span class="built_in">NSButton</span> *minitButton_;</span><br><span class="line">    <span class="built_in">NSButton</span> *zoomButton_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> mouseInside;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSButton</span> *closeButton;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSButton</span> *minitButton;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSButton</span> *zoomButton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>mouseInside参数是用于判断鼠标是否在视图之中。</p>
<p>创建一个window button所用到的方法是<code>+ standardWindowButton:forStyleMask:</code><br>文档中相关说明：</p>
<blockquote>
<p>Returns a new instance of a given standard window button, sized appropriately for a given window style.</p>
</blockquote>
<p>这里说明了，此方法是返回一个标准的window button实例，并且会设置合适的window style。<br><code>NSWindowButton</code>取值如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">   <span class="built_in">NSWindowCloseButton</span>,</span><br><span class="line">   <span class="built_in">NSWindowMiniaturizeButton</span>,</span><br><span class="line">   <span class="built_in">NSWindowZoomButton</span>,</span><br><span class="line">   <span class="built_in">NSWindowToolbarButton</span>,</span><br><span class="line">   <span class="built_in">NSWindowDocumentIconButton</span>,</span><br><span class="line">   <span class="built_in">NSWindowDocumentVersionsButton</span> = <span class="number">6</span>,</span><br><span class="line">   <span class="built_in">NSWindowFullScreenButton</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSUInteger</span> <span class="built_in">NSWindowButton</span>;</span><br></pre></td></tr></table></figure>

<p>名字很清楚的显示了window button的作用，这里我们需要自定义的是左边的三个按钮，所以需要用到的是<code>NSWindowCloseButton</code>（关闭窗口按钮），<code>NSWindowMiniaturizeButton</code>（最小化窗口按钮）和<code>NSWindowZoomButton</code>（最大化窗口按钮，<strong>不是全屏按钮</strong>）。</p>
<p><strong>注意</strong><br>在OS X 10.10之后的版本中，<code>NSWindowZoomButton</code>会变成全屏按钮，而不是10.10之前的最大化窗口按钮。</p>
<p>第二个参数设置成<code>self.window.styleMask</code>就OK了。</p>
<p>这里windows button需要实现系统的悬停，响应窗口和非响应窗口的不同效果，那么就要实现鼠标移入和移出的方法<code>- mouseEntered:</code>和<code>- mouseExited:</code>，但是实现这个方法，需要重写<code>- updateTrackingAreas</code>方法，因为当大小或坐标改变后就会造成所指定的检测区域错误,所以我们需要重写<code>updateTrackingAreas</code>方法,将创建<code>NSTrackingArea</code>的工作放在其中。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateTrackingAreas &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">super</span> updateTrackingAreas];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSTrackingArea</span> *<span class="keyword">const</span> trackingArea = [[<span class="built_in">NSTrackingArea</span> alloc] initWithRect:<span class="built_in">NSZeroRect</span> options:(<span class="built_in">NSTrackingMouseEnteredAndExited</span> | <span class="built_in">NSTrackingActiveAlways</span> | <span class="built_in">NSTrackingInVisibleRect</span>) owner:<span class="keyword">self</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span> addTrackingArea:trackingArea];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后继续实现鼠标移入移出的方法：</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)mouseEntered:(<span class="built_in">NSEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">super</span> mouseEntered:event];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.mouseInside = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplayForStandardWindowButtons];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)mouseExited:(<span class="built_in">NSEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">super</span> mouseExited:event];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.mouseInside = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplayForStandardWindowButtons];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们需要实现一个在<strong>苹果的官方文档中并不存在</strong>的方法<code>- _mouseInGroup:</code>，这个方法用来返回判断鼠标是否在视图中的参数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)_mouseInGroup:(<span class="built_in">NSButton</span> *)button &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.mouseInside;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后一个就是需要重绘一下按钮的状态：</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setNeedsDisplayForStandardWindowButtons &#123;</span><br><span class="line">    [<span class="keyword">self</span>.closeButton setNeedsDisplay];</span><br><span class="line">    [<span class="keyword">self</span>.minitButton setNeedsDisplay];</span><br><span class="line">    [<span class="keyword">self</span>.zoomButton setNeedsDisplay];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就实现了自定义的window button，但是窗口在成为第一响应者和不适第一响应者的时候，还有当点击最小化的时候等等情况下，window button都会处于错误的状态中，例如，当失去第一响应的时候，这三个按钮应该变为淡灰色，但却是彩色，当点击最小化，然后再点击显示窗口的时候，三个按钮还是停留在鼠标移入的状态中，所以这些情况都要进行处理。这里我用通知实现了相关的处理：</p>
<p><strong>首先，注册通知：</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNotificationCenter</span> *defaultCenter = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br><span class="line">[defaultCenter addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(applicationWillBecomeActive:)</span><br><span class="line">                      name:<span class="built_in">NSApplicationWillBecomeActiveNotification</span> object:<span class="built_in">NSApp</span>];</span><br><span class="line">[defaultCenter addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(applicationDidResignActive:)</span><br><span class="line">                      name:<span class="built_in">NSApplicationDidResignActiveNotification</span> object:<span class="built_in">NSApp</span>];</span><br><span class="line">[defaultCenter addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(windowActiveChanged:)</span><br><span class="line">                       name:<span class="built_in">NSWindowDidBecomeMainNotification</span> object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<p><strong>然后实现处理方法（如果有更好的处理方式，大家可以自行写逻辑，这里仅供参考）：</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)applicationWillBecomeActive:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.mouseInside = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplayForStandardWindowButtons];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.mouseInside = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplayForStandardWindowButtons];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidResignActive:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.mouseInside = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplayForStandardWindowButtons];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)windowActiveChanged:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.mouseInside = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplayForStandardWindowButtons];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样左边的三个自定义window button就已经完成。</p>
<h3 id="兼容10-10之前的按钮需要实现自定义全屏按钮（NSWindowFullScreenButton）"><a href="#兼容10-10之前的按钮需要实现自定义全屏按钮（NSWindowFullScreenButton）" class="headerlink" title="兼容10.10之前的按钮需要实现自定义全屏按钮（NSWindowFullScreenButton）"></a>兼容10.10之前的按钮需要实现自定义全屏按钮（NSWindowFullScreenButton）</h3><p>创建全屏按钮的方式与之前相同，不多说直接看代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.versionNum != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.fullScreenButton = [<span class="built_in">NSWindow</span> standardWindowButton:<span class="built_in">NSWindowFullScreenButton</span> forStyleMask:<span class="keyword">self</span>.window.styleMask];</span><br><span class="line">        [<span class="keyword">self</span>.fullScreenButton setFrame:<span class="built_in">NSMakeRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.fullScreenButton.frame.size.width, <span class="keyword">self</span>.fullScreenButton.frame.size.height)];</span><br><span class="line">        [<span class="keyword">self</span>.topView.fullScreenBackView addSubview:<span class="keyword">self</span>.fullScreenButton];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我判断了一下系统的版本。</p>
<p><strong>注意</strong></p>
<blockquote>
<p>设置按钮一定要在主视图控制器中进行，不能在自定义的子视图中进行，否则在10.10之前的系统中会出现coreUI的错误提示。而且这个错误出现的几率不是100%</p>
</blockquote>
<p>在全屏之后，我们最好将所有的window button给隐藏掉，调用<code>setHidden:</code>即可。</p>
<p>这下，自定义的window button就完成了。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://www.tanhao.me/pieces/1808.html/">OSX的MouseEntered和MouseExited事件检测</a></li>
<li><a href="http://stackoverflow.com/questions/7634788/cocoa-osx-nswindow-standardwindowbutton-behaving-strangely-once-copied-and-add">Cocoa/OSX - NSWindow standardWindowButton behaving strangely once copied and added again</a></li>
</ul>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>macOS工作日志</tag>
      </tags>
  </entry>
  <entry>
    <title>配置 git 代理</title>
    <url>/2018/02/08/2018-02-08-%E9%85%8D%E7%BD%AE%20git%20%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>当我们再做开发，从github上面下载库的时候，总是很慢。pod setup 那是更加的慢。这里我们配置一下代理，速度立马就上去了。  </p>
</blockquote>
<p>Git 目前支持的三种协议 <code>git://</code>、<code>ssh://</code> 和 <code>http://</code> ，其代理配置各不相同： <code>core.gitproxy</code> 用于 <code>git://</code> 协议， <code>http.proxy</code> 用于 <code>http://</code> 协议， <code>ssh://</code> 协议的代理需要配置 <code>ssh</code> 的 <code>ProxyCommand</code> 参数。</p>
<a id="more"></a>

<p>1、配置http和https代理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ git config --<span class="keyword">global</span> http.proxy http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1087</span></span><br><span class="line">$ git config --<span class="keyword">global</span> https.proxy https://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1087</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 删除代理</span></span><br><span class="line">$ git config --<span class="keyword">global</span> --unset http.proxy</span><br><span class="line">$ git config --<span class="keyword">global</span> --unset https.proxy</span><br><span class="line"></span><br><span class="line">$ npm config delete proxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置socks5代理</span></span><br><span class="line">$ git config --<span class="keyword">global</span> http.proxy <span class="string">&#x27;socks5://127.0.0.1:1086&#x27;</span></span><br><span class="line">$ git config --<span class="keyword">global</span> https.proxy <span class="string">&#x27;socks5://127.0.0.1:1086&#x27;</span></span><br></pre></td></tr></table></figure>

<p>2、 配置git代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global core.gitproxy github.com</span><br></pre></td></tr></table></figure>

<p>后面的 <code>github.com</code> 是根据情况而定，这里配置的是github的 <code>git.proxy</code></p>
<p><strong>ssh代理没有试过，略</strong></p>
<p>终端中执行 <code>clone</code> 命令，速度应该很快了。</p>
<blockquote>
<p><strong>sourcetree</strong> 速度也会变快，因为它的 <code>clone</code> 操作，其实也是调用 <code>git clone</code> 命令。  </p>
</blockquote>
]]></content>
      <categories>
        <category>系统设置</category>
      </categories>
      <tags>
        <tag>环境设置</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH 免密登陆 VPS</title>
    <url>/2018/02/09/2018-02-09-SSH%20%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86%20VPS/</url>
    <content><![CDATA[<p>我们在进行 SSH 登陆的时候，每次都需要输入密码，就感到十分的不方便，这里可以利用 SSH Key（ssh公钥） 来验证登录，从而实现免密登陆。</p>
<h3 id="通过命令生成-SSH-Key"><a href="#通过命令生成-SSH-Key" class="headerlink" title="通过命令生成 SSH Key"></a>通过命令生成 SSH Key</h3><p>生成 SSH Key 我们需要 <code>ssh-keygen</code> 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xxxxx@xxxxx.com&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Generating public/private rsa key pair...</span></span><br><span class="line"><span class="comment"># 三次回车即可生成 ssh key</span></span><br></pre></td></tr></table></figure>

<p>查看生成的 SSH Key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"><span class="comment"># ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc....</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>在 <code>.ssh</code> 文件夹中，可能有三个文件</p>
<ul>
<li>id_rsa : 生成的私钥文件</li>
<li>id_rsa.pub ： 生成的公钥文件</li>
<li>know_hosts :  已知的主机公钥清单</li>
</ul>
<p>我们需要用的就在 <code>id_rsa.pub</code> 文件中。</p>
<p>如果希望ssh公钥生效需满足至少下面两个条件：<br>    * <code>.ssh</code> 目录的权限必须是700<br>    * <code>.ssh/authorized_keys</code> 文件权限必须是600</p>
<h3 id="将-SSH-Key-上传到服务器"><a href="#将-SSH-Key-上传到服务器" class="headerlink" title="将 SSH Key 上传到服务器"></a>将 SSH Key 上传到服务器</h3><h4 id="方法一：手动复制"><a href="#方法一：手动复制" class="headerlink" title="方法一：手动复制"></a>方法一：手动复制</h4><p>先登录服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@服务器IP地址 -p 端口</span><br></pre></td></tr></table></figure>

<p>在 VPS 的默认目录（/root）下面新建文件夹 <code>.ssh</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir ~/.ssh</span><br></pre></td></tr></table></figure>

<p>进入 <code>.ssh</code> 目录，执行 <code>vi</code> 命令新建 <code>authorized_keys</code> 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">vi authorized_keys</span><br></pre></td></tr></table></figure>

<p>将 <code>id_rsa.pub</code> 文件中的内容粘贴到 <code>authorized_keys</code> 文件中，保存退出，之后就可以实现免密登陆。</p>
<h4 id="方法二：执行-scp-命令快速建立-authorized-keys-文件"><a href="#方法二：执行-scp-命令快速建立-authorized-keys-文件" class="headerlink" title="方法二：执行 scp 命令快速建立 authorized_keys 文件"></a>方法二：执行 <code>scp</code> 命令快速建立 <code>authorized_keys</code> 文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -P 端口 ~/.ssh/id_rsa.pub root@服务器IP地址:/root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>注意：这里 <code>-P</code> 的 P 是大写。</p>
<p>输入密码后，<code>authorized_keys</code> 文件就新建成功，之后就可以免密登陆了。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习笔记（七）【Python中的包】</title>
    <url>/2018/02/12/2018-02-12-Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E3%80%90Python%E4%B8%AD%E7%9A%84%E5%8C%85%E3%80%91/</url>
    <content><![CDATA[<p>包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。<br><strong>简单来说，包就是文件夹，但该文件夹下必须存在 <code>__init__.py</code> 文件, 该文件的内容可以为空。<code>__int__.py</code> 用于标识当前文件夹是一个包。</strong><br>考虑一个在 <code>package_runoob</code> 目录下的 <code>runoob1.py</code>、<code>runoob2.py</code>、<code>__init__.py</code> 文件，<code>test.py</code> 为测试调用包的代码，目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test.py</span><br><span class="line">package_runoob</span><br><span class="line">|-- __init__.py</span><br><span class="line">|-- runoob1.py</span><br><span class="line">|-- runoob2.py</span><br></pre></td></tr></table></figure>

<p><strong>package_runoob/runoob1.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runoob1</span>():</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;I&#x27;m in runoob1&quot;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>package_runoob/runoob2.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runoob2</span>():</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;I&#x27;m in runoob2&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>现在，在 package_runoob 目录下创建 init.py：</strong><br><strong>package_runoob/init.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;作为主程序运行&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;package_runoob 初始化&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>然后我们在 package_runoob 同级目录下创建 test.py 来调用 package_runoob 包</strong></p>
<p><strong>test.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入 Phone 包</span></span><br><span class="line"><span class="keyword">from</span> package_runoob.runoob1 <span class="keyword">import</span> runoob1</span><br><span class="line"><span class="keyword">from</span> package_runoob.runoob2 <span class="keyword">import</span> runoob2</span><br><span class="line"> </span><br><span class="line">runoob1()</span><br><span class="line">runoob2()</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package_runoob 初始化</span><br><span class="line">I&#39;m in runoob1</span><br><span class="line">I&#39;m in runoob2</span><br></pre></td></tr></table></figure>

<p>如上，为了举例，我们只在每个文件里放置了一个函数，但其实你可以放置许多函数。你也可以在这些文件里定义Python的类，然后为这些类建一个包。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Python学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习笔记（八）【File(文件) 方法】</title>
    <url>/2018/02/15/2018-02-15-Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E3%80%90File(%E6%96%87%E4%BB%B6)%20%E6%96%B9%E6%B3%95%E3%80%91/</url>
    <content><![CDATA[<p>file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">file.close()</span><br><span class="line"><span class="comment"># 关闭文件。关闭后文件不能再进行读写操作。</span></span><br><span class="line"></span><br><span class="line">file.flush()</span><br><span class="line"><span class="comment"># 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</span></span><br><span class="line"></span><br><span class="line">file.fileno()</span><br><span class="line"><span class="comment"># 返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</span></span><br><span class="line"></span><br><span class="line">file.isatty()</span><br><span class="line"><span class="comment"># 如果文件连接到一个终端设备返回 True，否则返回 False。</span></span><br><span class="line"></span><br><span class="line">file.<span class="built_in">next</span>()</span><br><span class="line"><span class="comment"># 返回文件下一行。</span></span><br><span class="line"></span><br><span class="line">file.read([size])</span><br><span class="line"><span class="comment"># 从文件读取指定的字节数，如果未给定或为负则读取所有。</span></span><br><span class="line"></span><br><span class="line">file.readline([size])</span><br><span class="line"><span class="comment"># 读取整行，包括 &quot;\n&quot; 字符。</span></span><br><span class="line"></span><br><span class="line">file.readlines([sizehint])</span><br><span class="line"><span class="comment"># 读取所有行并返回列表，若给定sizeint&gt;0，则是设置一次读多少字节，这是为了减轻读取压力。</span></span><br><span class="line"></span><br><span class="line">file.seek(offset[, whence])</span><br><span class="line"><span class="comment"># 设置文件当前位置</span></span><br><span class="line"></span><br><span class="line">file.tell()</span><br><span class="line"><span class="comment"># 返回文件当前位置。</span></span><br><span class="line"></span><br><span class="line">file.truncate([size])</span><br><span class="line"><span class="comment"># 截取文件，截取的字节通过size指定，默认为当前文件位置。</span></span><br><span class="line"></span><br><span class="line">file.write(<span class="built_in">str</span>)</span><br><span class="line"><span class="comment"># 将字符串写入文件，没有返回值。</span></span><br><span class="line"></span><br><span class="line">file.writelines(sequence)</span><br><span class="line"><span class="comment"># 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Python学习</tag>
      </tags>
  </entry>
  <entry>
    <title>斐讯 K3 从 LEDE 固件刷回官方固件</title>
    <url>/2018/02/24/2018-02-24-%E6%96%90%E8%AE%AF%20K3%20%E4%BB%8E%20LEDE%20%E5%9B%BA%E4%BB%B6%E5%88%B7%E5%9B%9E%E5%AE%98%E6%96%B9%E5%9B%BA%E4%BB%B6/</url>
    <content><![CDATA[<p>由于 LEDE 本人使用起来并不是十分的顺手，于是想刷回官方的固件，本人使用的是进入 CFE 模式进行刷机。<br>此教程使用的是 Mac 电脑，在虚拟机中进行 <code>ping</code> 操作。</p>
<h4 id="改变虚拟机的上网方式"><a href="#改变虚拟机的上网方式" class="headerlink" title="改变虚拟机的上网方式"></a>改变虚拟机的上网方式</h4><p>虚拟机的网络设置一定要改为<strong>桥接网路</strong>，我选择的是<strong>雷雳以太网（Thunderbolt Ethernet）</strong>。<br>接下来测试一下是否能上网，连接上网线，试一下 Windows 能否连接网络，如果可以，即设置成功。</p>
<p><img src="/my_pictures/%E6%96%90%E8%AE%AFK3%E4%BB%8ELEDE%E5%9B%BA%E4%BB%B6%E5%88%B7%E5%9B%9E%E5%AE%98%E6%96%B9%E5%9B%BA%E4%BB%B6-1.jpg"></p>
<a id="more"></a>

<h4 id="设置以太网的静态-IP"><a href="#设置以太网的静态-IP" class="headerlink" title="设置以太网的静态 IP"></a>设置以太网的静态 IP</h4><p>如果之前你没有改过 LAN 地址的话，那么 K3 默认 IP 是 <code>192.168.2.1</code>，设置类似于下图：</p>
<p><img src="/my_pictures/%E6%96%90%E8%AE%AFK3%E4%BB%8ELEDE%E5%9B%BA%E4%BB%B6%E5%88%B7%E5%9B%9E%E5%AE%98%E6%96%B9%E5%9B%BA%E4%BB%B6-2.jpg"></p>
<p>因为我将 LAN 地址改为了 <code>10.0.0.1</code> 所以，我的设置如下：</p>
<p><img src="/my_pictures/%E6%96%90%E8%AE%AFK3%E4%BB%8ELEDE%E5%9B%BA%E4%BB%B6%E5%88%B7%E5%9B%9E%E5%AE%98%E6%96%B9%E5%9B%BA%E4%BB%B6-3.jpg"></p>
<h4 id="启动路由器"><a href="#启动路由器" class="headerlink" title="启动路由器"></a>启动路由器</h4><ol>
<li>将路由器插上电源，一根网线连接 Mac 的雷雳以太网网口，另一头插入 K3 的LAN 口，注意不是 WAN 口。</li>
<li>断电的情况下用 iPhone 的取卡针按着 K3 那个小的恢复按钮，然后开机，注意这时候依然按着恢复按钮，不要松开（需要一直按着20秒以上就可以松开了，这时候显示屏的进度条基本上已经走到 3/4 的地方）。</li>
<li>接着在 Windows 的命令提示框中输入命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我的输入的是 10.0.0.1</span></span><br><span class="line">ping 10.0.0.1 -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你的是默认的地址那么需要 ping 192.168.2.1</span></span><br><span class="line">ping 192.168.2.1 -t</span><br></pre></td></tr></table></figure>

<p>等 ttl = 100 的时候，就可以打开网页了。</p>
<h4 id="上传固件"><a href="#上传固件" class="headerlink" title="上传固件"></a>上传固件</h4><p>网上说用 Firefox 浏览器成功率高，所以我就用了 Firefox 浏览器，其他的没试过，也不清楚效果。</p>
<p>打开 Firefox 浏览器，地址栏输入 <code>10.0.0.1</code> ，如果是默认地址则输入 <code>192.168.2.1</code> ，回车，就会出现类似于下面的界面（由于自己当时没有截图，所以用了网上的图）：</p>
<p><img src="/my_pictures/%E6%96%90%E8%AE%AFK3%E4%BB%8ELEDE%E5%9B%BA%E4%BB%B6%E5%88%B7%E5%9B%9E%E5%AE%98%E6%96%B9%E5%9B%BA%E4%BB%B6-4.jpg"></p>
<p>点击最下面的 <code>Restore default NVRAM values.</code> ，然后点击 <code>Continue</code> ，点击选择文件，上传官方下载的固件，点击 <code>Upload</code> 上传固件。等待一会儿会出现如下界面（于自己当时没有截图，所以用了网上的图）：</p>
<p><img src="/my_pictures/%E6%96%90%E8%AE%AFK3%E4%BB%8ELEDE%E5%9B%BA%E4%BB%B6%E5%88%B7%E5%9B%9E%E5%AE%98%E6%96%B9%E5%9B%BA%E4%BB%B6-5.jpg"></p>
<p>接下来就是等待，看显示屏就知道固件有没有安装好。</p>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul>
<li><a href="http://koolshare.cn/thread-92771-1-1.html">固件讨论 K3原厂固件,LEDE可以刷回原厂</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习笔记（六）【模块】</title>
    <url>/2018/02/10/2018-02-10-Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E3%80%90%E6%A8%A1%E5%9D%97%E3%80%91/</url>
    <content><![CDATA[<blockquote>
<p>Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。<br>模块让你能够有逻辑地组织你的 Python 代码段。<br>把相关的代码分配到一个模块里能让你的代码更好用，更易懂。<br>模块能定义函数，类和变量，模块里也能包含可执行的代码。  </p>
</blockquote>
<h5 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h5><hr>
<p><strong>模块的引入</strong></p>
<p>模块定义好后，我们可以使用 import 语句来引入模块，语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module1[, module2[,... moduleN]</span><br></pre></td></tr></table></figure>

<p>比如要引用模块 math，就可以在文件最开始的地方用 import math 来引入。在调用 math 模块中的函数时，必须这样引用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">模块名.函数名</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。</p>
<p><strong>一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。</strong></p>
<h5 id="From…import-语句"><a href="#From…import-语句" class="headerlink" title="From…import 语句"></a>From…import 语句</h5><hr>
<p>Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> name1[, name2[, ... nameN]]</span><br></pre></td></tr></table></figure>

<p>例如，要导入模块 fib 的 fibonacci 函数，使用如下语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fib <span class="keyword">import</span> fibonacci</span><br></pre></td></tr></table></figure>

<p>这个声明不会把整个 fib 模块导入到当前的命名空间中，它只会将 fib 里的 fibonacci 单个引入到执行这个声明的模块的全局符号表。</p>
<h5 id="From…import-语句-1"><a href="#From…import-语句-1" class="headerlink" title="From…import* 语句"></a>From…import* 语句</h5><hr>
<p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。<br>例如我们想一次性引入 math 模块中所有的东西，语句如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<h5 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h5><hr>
<p>当你导入一个模块，Python 解析器对模块位置的搜索顺序是：<br>    * 1、当前目录<br>    * 2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。<br>    * 3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。<br>模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。</p>
<h5 id="PYTHONPATH-变量"><a href="#PYTHONPATH-变量" class="headerlink" title="PYTHONPATH 变量"></a>PYTHONPATH 变量</h5><p>作为环境变量，PYTHONPATH 由装在一个列表里的许多目录组成。PYTHONPATH 的语法和 shell 变量 PATH 的一样。<br>在 Windows 系统，典型的 PYTHONPATH 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> PYTHONPATH=c:\python27\lib;</span><br></pre></td></tr></table></figure>

<p>在 UNIX 系统，典型的 PYTHONPATH 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> PYTHONPATH=/usr/local/lib/python</span><br></pre></td></tr></table></figure>

<h5 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h5><hr>
<p>变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。</p>
<p>一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。</p>
<p>每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。</p>
<p><strong>Python 会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。</strong></p>
<p><strong>因此，如果要给函数内的全局变量赋值，必须使用 global 语句。</strong></p>
<p><strong>global VarName 的表达式会告诉 Python， VarName 是一个全局变量，这样 Python 就不会在局部命名空间里寻找这个变量了。</strong></p>
<p>例如，我们在全局命名空间里定义一个变量 Money。我们再在函数内给变量 Money 赋值，然后 Python 会假定 Money 是一个局部变量。然而，我们并没有在访问前声明一个局部变量 Money，结果就是会出现一个 UnboundLocalError 的错误。取消 global 语句的注释就能解决这个问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line">Money = <span class="number">2000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AddMoney</span>():</span></span><br><span class="line">   <span class="comment"># 想改正代码就取消以下注释:</span></span><br><span class="line">   <span class="comment"># global Money</span></span><br><span class="line">   Money = Money + <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> Money</span><br><span class="line">AddMoney()</span><br><span class="line"><span class="built_in">print</span> Money</span><br></pre></td></tr></table></figure>

<h5 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a>dir()函数</h5><hr>
<p>dir() 函数一个排好序的字符串列表，内容是一个模块里定义过的名字。</p>
<p>返回的列表容纳了在一个模块里定义的所有模块，变量和函数。如下一个简单的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入内置math模块</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"> </span><br><span class="line">content = <span class="built_in">dir</span>(math)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> content;</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#39;__doc__&#39;, &#39;__file__&#39;, &#39;__name__&#39;, &#39;acos&#39;, &#39;asin&#39;, &#39;atan&#39;, </span><br><span class="line">&#39;atan2&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;degrees&#39;, &#39;e&#39;, &#39;exp&#39;, </span><br><span class="line">&#39;fabs&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;frexp&#39;, &#39;hypot&#39;, &#39;ldexp&#39;, &#39;log&#39;,</span><br><span class="line">&#39;log10&#39;, &#39;modf&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;radians&#39;, &#39;sin&#39;, &#39;sinh&#39;, </span><br><span class="line">&#39;sqrt&#39;, &#39;tan&#39;, &#39;tanh&#39;]</span><br></pre></td></tr></table></figure>

<p><strong>在这里，特殊字符串变量__name__指向模块的名字，__file__指向该模块的导入文件名。</strong></p>
<h5 id="globals-和-locals-函数"><a href="#globals-和-locals-函数" class="headerlink" title="globals() 和 locals() 函数"></a>globals() 和 locals() 函数</h5><hr>
<p><strong>根据调用地方的不同，globals() 和 locals() 函数可被用来返回全局和局部命名空间里的名字。</strong></p>
<p>如果在函数内部调用 locals()，返回的是所有能在该函数里访问的命名。</p>
<p>如果在函数内部调用 globals()，返回的是所有在该函数里能访问的全局名字。</p>
<p>两个函数的返回类型都是字典。所以名字们能用 keys() 函数摘取。</p>
<h5 id="reload-函数"><a href="#reload-函数" class="headerlink" title="reload() 函数"></a>reload() 函数</h5><hr>
<p><strong>当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。</strong></p>
<p><strong>因此，如果你想重新执行模块里顶层部分的代码，可以用 reload() 函数。该函数会重新导入之前导入过的模块。语法如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reload(module_name)</span><br></pre></td></tr></table></figure>

<p><strong>在这里，module_name要直接放模块的名字，而不是一个字符串形式。</strong>比如想重载 hello 模块，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reload(hello)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Python学习</tag>
      </tags>
  </entry>
  <entry>
    <title>修改 VPS 的 SSH 端口</title>
    <url>/2018/02/25/2018-02-25-%E4%BF%AE%E6%94%B9%20VPS%20%E7%9A%84%20SSH%20%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>如果你发现连不上你的 VPS了，那么有一种可能就是端口被封，我们需要改一下 VPS 端口了。</p>
<h3 id="登陆服务器"><a href="#登陆服务器" class="headerlink" title="登陆服务器"></a>登陆服务器</h3><p>如何登陆 VPS 可以参考这篇文章： <a href="https://tomatosx.github.io/%E7%BD%91%E7%BB%9C/2018/02/09/SSH-%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86-VPS/">SSH 免密登陆 VPS</a></p>
<h3 id="修改-VPS-的-SSH-端口"><a href="#修改-VPS-的-SSH-端口" class="headerlink" title="修改 VPS 的 SSH 端口"></a>修改 VPS 的 SSH 端口</h3><p>VPS 的端口配置在文件 <code>sshd_config </code> 中，我们直接用如下的命令打开文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>在文章的末尾你能看到 <code>Port</code> 字段，一般默认是 22，随意修改一个数字，建议 1000 以下。然后保存退出。重启 VPS 即可。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>获取电信光猫超级密码</title>
    <url>/2018/02/25/2018-02-25-%E8%8E%B7%E5%8F%96%E7%94%B5%E4%BF%A1%E5%85%89%E7%8C%AB%E8%B6%85%E7%BA%A7%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h3 id="登陆电信光猫"><a href="#登陆电信光猫" class="headerlink" title="登陆电信光猫"></a>登陆电信光猫</h3><p>打开浏览器，输入 <code>http://192.168.1.1</code> ，进入光猫管理页面，用 <code>useradmin</code> 账户登陆。将地址栏中的连接 <code>http://192.168.1.1/cgi-bin/content.asp</code>  改为 <code>http://192.168.1.1/cgi-bin/telnet.asp</code> 。出来如下的界面：</p>
<p><img src="/my_pictures/%E8%8E%B7%E5%8F%96%E7%94%B5%E4%BF%A1%E5%85%89%E7%8C%AB%E8%B6%85%E7%BA%A7%E5%AF%86%E7%A0%81-1.jpg"></p>
<p>启用 <code>Telnet</code> ，点击确定。</p>
<h3 id="终端获取超级密码"><a href="#终端获取超级密码" class="headerlink" title="终端获取超级密码"></a>终端获取超级密码</h3><p>打开 Mac 终端，输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet 192.168.1.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户名 admin</span></span><br><span class="line"><span class="comment"># 密码 1234</span></span><br><span class="line"></span><br><span class="line">cat /tmp/ctromfile.cfg</span><br></pre></td></tr></table></figure>

<p>按住 <code>control + s</code> 键，保存终端内容到文件。</p>
<p>文件中搜索 <code>telecomadmin</code> ，就能看到超级密码了。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>电信</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift是一门动态类型的强类型语言</title>
    <url>/2018/02/26/2018-02-26-Swift%E6%98%AF%E4%B8%80%E9%97%A8%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BC%BA%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>之前我一直以为，Swift是一门弱类型的语言。</p>
<p>判断依据：</p>
<blockquote>
<p>Swift 变量不强制的指定类型，而是用 <code>var</code> 和 <code>let</code> 表示可变与不可变。所以，Swift是一门弱类型的语言。  </p>
</blockquote>
<p>但是，看了一下强弱类型的时候，才恍然大悟。其实 <code>var</code> 和 <code>let</code> 的特性，只是说明Swift是一门动态类型的语言。并不能指出是否是强或弱类型。</p>
<p>一些定义：</p>
<ul>
<li>静态类型语言：是一种编译器无法自动检测类型的语言。</li>
<li>动态类型语言：是一种编译器能够自动检测类型的语言。</li>
<li>强类型语言：强类型语言也称为强类型定义语言。是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。</li>
<li>弱类型语言：弱类型语言也称为弱类型定义语言。与强类型定义相反。像vb，php，js等就属于弱类型语言。</li>
</ul>
<a id="more"></a>

<p>光看定义不够生动，还是来举个例子：</p>
<p>Java是一种静态类型语言，也是一种强类型语言。因为编译器不能自动检测类型，所以它是静态的，而且类型受到严格限制，所以它也是一种强类型语言。</p>
<p>javascript是一种动态类型语言和非强类型语言。<br>因为编译器能够在运行时检测类型，并且类型也不受严格限制。</p>
<p>所以，基于上面的例子，你可以说swift允许我们不声明类型并且让编译器自己检测类型，所以swift被Apple官方公布为动态类型语言。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这里没有强制声明类型，看似一个弱类型的语言，其实不然。Swift 编译器能够推断出 <code>num</code> 是 <code>Int</code> 类型。那么 <code>num</code> 就不能再被赋值为 <code>String</code> 类型。更不能写成如下的形式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="keyword">let</span> result = num + str</span><br></pre></td></tr></table></figure>

<p>编译器将会报如下的错误：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">error: binary <span class="keyword">operator</span> &#x27;+&#x27; cannot be applied to operands of type &#x27;<span class="type">Int&#x27;</span> and &#x27;<span class="type">String&#x27;</span></span><br><span class="line"><span class="keyword">let</span> result = num + str</span><br><span class="line">             ~~~ ^ ~~~</span><br><span class="line">note: overloads <span class="keyword">for</span> &#x27;+&#x27; exist with these partially matching parameter lists: (<span class="type">Int</span>, <span class="type">Int</span>), (<span class="type">String</span>, <span class="type">String</span>), (<span class="type">Int</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Pointee</span>&gt;), (<span class="type">Int</span>, <span class="type">UnsafePointer</span>&lt;<span class="type">Pointee</span>&gt;)</span><br><span class="line"><span class="keyword">let</span> result = num + str</span><br><span class="line">                 ^</span><br></pre></td></tr></table></figure>

<p>这说明了，Swift 是一门强类型的语言。Swift 的类型声明，你可以看成是在定义变量的时候，隐式声明的（由编译器推断出），当然也可以显式的声明。如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="type">Int</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://sandeshsardar.com/2017/06/29/swift-is-dynamic-and-strong-type-language/">Swift is Dynamic and strong type language</a></li>
<li><a href="https://www.jianshu.com/p/ac99366112f5">关于 Swift 的 5 个误区</a></li>
</ul>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift专题</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【一】内建集合类型</title>
    <url>/2018/02/27/2018-02-27-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E4%B8%80%E3%80%91%E5%86%85%E5%BB%BA%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="数组和可变性"><a href="#数组和可变性" class="headerlink" title="数组和可变性"></a>数组和可变性</h3><hr>
<p>在Swift中，数组是值类型。并且Swift中，Swift标准库中的所有集合类型都使用了“写时复制”这一技术，避免了大量副本导致性能下降。值类型的好处，不仅是性能有提高，其次就是能保证数组的不可变。</p>
<p>在Objective-C中，声明一个不可变的数组 <code>NSArray</code> 并不能保证数组的不可变。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mutableAry = <span class="type">NSMutableArray</span>(array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">/// 我们不想让 ary 被改变，声明为不可变数组</span></span><br><span class="line"><span class="keyword">let</span> ary: <span class="type">NSArray</span> = mutableAry</span><br><span class="line"><span class="comment">/// 但是事实上它依然能够被 a 影响并改变</span></span><br><span class="line">mutableAry.add(<span class="number">5</span>)</span><br><span class="line">ary <span class="comment">// [1, 2, 3, 5]</span></span><br></pre></td></tr></table></figure>

<p>正确的做法是，在赋值的时候，先进行拷贝：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nsAry = mutableAry.copy() <span class="keyword">as</span>! <span class="type">NSArray</span></span><br><span class="line">mutableAry.add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">mutableAry <span class="comment">// [1, 2, 3, 5, 10]</span></span><br><span class="line">nsAry <span class="comment">// [1, 2, 3, 5]</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>值类型的优点</strong></p>
<pre><code>* 不变性
值类型的变量是严格的被一个所有者控制的
* 独立性
引用类型是一种隐式的共享实例
* 安全性
在多线程时可以放心值传递</code></pre>
<p><strong>不可变性在安全中的作用</strong></p>
<blockquote>
<p>选择值类型而不是引用类型的一个主要原因是能让你的代码变得更加简单。你在任何情况下用一个值类型，都能够假设你的其他代码不会使它改变，这通常在多线程环境中很有用，如果一个线程中使用的数据被另一个线程给意外的修改了，这通常会产生非常严重的Bug，且相当难以调试。<br>由于只有当你需要修改数据时两者的区别才会得到体现，所以当你的实例不会对数据进行修改的时候，值类型和引用类型看起来是完全相同的。<br>你也许会想，写一个完全不可变的类，这或许是有价值的，使用Cocoa的NSObject能简化这个过程，并且能很好地保持原有的语义。现在，你能通过使用不可变的存储属性，以及避免暴露修改数据的接口，从而在Swift里实现一个不可变的类。事实上，大多数的Cocoa类，比如NSURL等，都被设计为不可变的类，然而，Swift当前并没有提供任何语言机制去强制申明一个类不可改变（比如子类化就能修改一个类的实现），只有结构体和枚举才是强制不可变的。  </p>
</blockquote>
<h3 id="使用函数将行为参数化"><a href="#使用函数将行为参数化" class="headerlink" title="使用函数将行为参数化"></a>使用函数将行为参数化</h3><hr>
<p>类似于如下的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">&quot;Paula&quot;</span>, <span class="string">&quot;Elena&quot;</span>, <span class="string">&quot;Zoe&quot;</span>]</span><br><span class="line"><span class="keyword">var</span> lastNameEndingInA: <span class="type">String?</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names.reversed() <span class="keyword">where</span> name.hasSuffix(<span class="string">&quot;a&quot;</span>) &#123;</span><br><span class="line">	  lastNameEndingInA = name</span><br><span class="line">	  <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">lastNameEndingInA <span class="comment">// Optional(&quot;Elena&quot;)</span></span><br></pre></td></tr></table></figure>

<p>可以将其改写成 <code>Sequence</code> 的一个扩展，详解，参考<strong>函数式编程</strong>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">last</span><span class="params">(<span class="keyword">where</span> predicate: <span class="params">(Iterator.Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Iterator</span>.<span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> reversed() <span class="keyword">where</span> predicate(element) &#123;</span><br><span class="line">            <span class="keyword">return</span> element</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Filter函数"><a href="#Filter函数" class="headerlink" title="Filter函数"></a>Filter函数</h3><hr>
<p>一个关于性能的小提示：如果你正在写下面这样的代码，请不要这么做！</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">bigArray.<span class="built_in">filter</span> &#123; someCondition &#125;.<span class="built_in">count</span> &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>filter 会创建一个全新的数组，并且会对数组中的每个元素都进行操作。然而在上面这段代码中，这显然是不必要的。上面的代码仅仅检查了是否有至少一个元素满足条件，在这个情景下，使用 contains(where:) 更为合适：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">bigArray.<span class="built_in">contains</span> &#123; someCondition &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Reduce函数"><a href="#Reduce函数" class="headerlink" title="Reduce函数"></a>Reduce函数</h3><hr>
<p>使用reduce函数可以向下面一样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = fibs.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123; total, num <span class="keyword">in</span> total + num &#125; <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>运算符也是函数，所以我们也可以把上面的例子写成这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fibs.<span class="built_in">reduce</span>(<span class="number">0</span>, +) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<h3 id="集合代数"><a href="#集合代数" class="headerlink" title="集合代数"></a>集合代数</h3><hr>
<p>Set中，可以对Set执行数学中的基本集合操作<strong>补集</strong>，<strong>交集</strong>，<strong>并集</strong><br>因为在标准库中，Set是唯一实现了 <code>SetAlgebra</code> 协议的类型。</p>
<blockquote>
<p>但是这个协议在 Foundation 中还被另外两个很有意思的类型实现了：那就是 IndexSet 和 CharacterSet。  </p>
</blockquote>
<p>具体可以参考 <code>SetAlgebra</code> 协议。</p>
<p><strong>补集</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iPods: <span class="type">Set</span> = [<span class="string">&quot;iPod touch&quot;</span>, <span class="string">&quot;iPod nano&quot;</span>, <span class="string">&quot;iPod mini&quot;</span>, <span class="string">&quot;iPod shuffle&quot;</span>, <span class="string">&quot;iPod Classic&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> discontinuedIPods: <span class="type">Set</span> = [<span class="string">&quot;iPod mini&quot;</span>, <span class="string">&quot;iPod Classic&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> currentIPods = iPods.subtracting(discontinuedIPods)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;iPod shuffle&quot;, &quot;iPod nano&quot;, &quot;iPod touch&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>交集</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> touchscreen: <span class="type">Set</span> = [<span class="string">&quot;iPhone&quot;</span>, <span class="string">&quot;iPad&quot;</span>, <span class="string">&quot;iPod touch&quot;</span>, <span class="string">&quot;iPod nano&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> iPodsWithTouch = iPods.intersection(touchscreen)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;iPod touch&quot;, &quot;iPod nano&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>并集</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> discontinued: <span class="type">Set</span> = [<span class="string">&quot;iBook&quot;</span>, <span class="string">&quot;Powerbook&quot;</span>, <span class="string">&quot;Power Mac&quot;</span>]</span><br><span class="line">discontinued.formUnion(discontinuedIPods)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;iBook&quot;, &quot;iPod mini&quot;, &quot;Powerbook&quot;, &quot;Power Mac&quot;, &quot;iPod Classic&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="索引集合和字符集合"><a href="#索引集合和字符集合" class="headerlink" title="索引集合和字符集合"></a>索引集合和字符集合</h3><hr>
<p><strong>IndexSet 表示了一个由正整数组成的集合。当然，你可以用Set<Int>来做这件事，但是IndexSet更加高效，因为它内部使用了一组范围列表进行实现。</strong></p>
<p>如果选择 <code>Set&lt;Int&gt;</code> 来存储1000以内所选择的数字的话，最坏的情况是存储1000个元素。如果用 <code>IndexSet</code> ，即使选择前500个数字的话，<code>IndexSet</code> 里其实只存储了选择的首位和末位两个整数值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">indices</span> = <span class="type">IndexSet</span>()</span><br><span class="line"><span class="built_in">indices</span>.insert(integersIn: <span class="number">1</span>..&lt;<span class="number">5</span>)</span><br><span class="line"><span class="built_in">indices</span>.insert(integersIn: <span class="number">11</span>..&lt;<span class="number">15</span>)</span><br><span class="line"><span class="keyword">let</span> evenIndices = <span class="built_in">indices</span>.<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125; <span class="comment">// [2, 4, 12, 14]</span></span><br></pre></td></tr></table></figure>

<p><code>CharacterSet</code> 将在字符串一章讨论。</p>
<p><strong>思考：</strong></p>
<p>过滤数组中重复的元素，并且保持数组中元素的顺序。</p>
<p>我们可以用 <code>Set</code> 去除重复，但是 <code>Set</code> 是无序，我们可以结合闭包来实现。这里我们写一个 <code>Sequence</code> 的扩展。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Iterator</span>.<span class="title">Element</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">unique</span><span class="params">()</span></span> -&gt; [<span class="type">Iterator</span>.<span class="type">Element</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> seen: <span class="type">Set</span>&lt;<span class="type">Iterator</span>.<span class="type">Element</span>&gt; = []</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">filter</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> seen.<span class="built_in">contains</span>($<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                seen.insert($<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">6</span>].unique() <span class="comment">// [1, 2, 3, 12, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h4 id="2018年3月11日-上午3-35-更新"><a href="#2018年3月11日-上午3-35-更新" class="headerlink" title="2018年3月11日 上午3:35 更新"></a>2018年3月11日 上午3:35 更新</h4><hr>
<p>关于去除数组中重复项的更函数式的写法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// SwifterSwift: Remove all duplicate elements from Array.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///        [1, 2, 2, 3, 4, 5].removeDuplicates() -&gt; [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">///        [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]. removeDuplicates() -&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;o&quot;]</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Thanks to https://github.com/sairamkotha for improving the method</span></span><br><span class="line">    <span class="keyword">self</span> = <span class="built_in">reduce</span>([])&#123; $<span class="number">0</span>.<span class="built_in">contains</span>($<span class="number">1</span>) ? $<span class="number">0</span> : $<span class="number">0</span> + [$<span class="number">1</span>] &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// SwifterSwift: Return array with all duplicate elements removed.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///        [1, 2, 2, 3, 4, 5, 5].duplicatesRemoved() -&gt; [ 2, 5]</span></span><br><span class="line"><span class="comment">///        [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]. duplicatesRemoved() -&gt; [&quot;l&quot;]</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Returns: an array of unique elements.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">duplicatesRemoved</span><span class="params">()</span></span> -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">    <span class="comment">// Thanks to https://github.com/sairamkotha for improving the property</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reduce</span>([])&#123; ($<span class="number">0</span> <span class="keyword">as</span> [<span class="type">Element</span>]).<span class="built_in">contains</span>($<span class="number">1</span>) ? $<span class="number">0</span> : $<span class="number">0</span> + [$<span class="number">1</span>] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【二】集合类型协议</title>
    <url>/2018/02/28/2018-02-28-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E4%BA%8C%E3%80%91%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="序列（Sequence）"><a href="#序列（Sequence）" class="headerlink" title="序列（Sequence）"></a>序列（Sequence）</h3><hr>
<p>Sequence定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Iterator</span>: <span class="type">IteratorProtocol</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Iterator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要实现一个Sequence，首先需要提供一个返回<strong>迭代器（iterator）</strong>的<code>makeIterator()</code> 方法。<br>对于迭代器，它是一个满足 <code>IteratorProtocol</code> 协议的类型。</p>
<p>IteratorProtocol协议的定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>IteratorProtocol 协议中唯一的一个方法是 next()，这个方法需要在每次被调用时返回序列中的下一个值。当序列被耗尽时，next() 应该返回 nil</strong></p>
<p>关联类型 <code>Element</code> 指定了迭代器产生的值的类型。</p>
<p>举几个例子进行体会：</p>
<p>1、斐波那契数列</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 菲波那切数列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FibsIterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> state = (<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> upcomingNumber = state.<span class="number">0</span></span><br><span class="line">        state = (state.<span class="number">1</span>, state.<span class="number">0</span> + state.<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> upcomingNumber &gt; <span class="number">1000</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> upcomingNumber</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = <span class="type">FibsIterator</span>()</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> number = iterator.next() &#123;</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987</span></span><br></pre></td></tr></table></figure>

<p>2、返回字符串切片</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 依次返回字符串的切片</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PrefixIterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> string: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> offset: <span class="type">String</span>.<span class="type">Index</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(str: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.string = str</span><br><span class="line">        <span class="keyword">self</span>.offset = str.startIndex</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> offset &lt; string.endIndex <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        offset = string.index(after: offset)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(string[string.startIndex..&lt;offset])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strIterator = <span class="type">PrefixIterator</span>(str: <span class="string">&quot;ABCDEFG&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> str = strIterator.next() &#123;</span><br><span class="line">    <span class="built_in">print</span>(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// AB</span></span><br><span class="line"><span class="comment">// ABC</span></span><br><span class="line"><span class="comment">// ABCD</span></span><br><span class="line"><span class="comment">// ABCDE</span></span><br><span class="line"><span class="comment">// ABCDEF</span></span><br><span class="line"><span class="comment">// ABCDEFG</span></span><br></pre></td></tr></table></figure>

<p>再定义一个PrefixSequence类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 实现PrefixIterator的sequence协议，之后可以用for来进行循环</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PrefixSequence</span>: <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> str: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">PrefixIterator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">PrefixIterator</span>(str: str)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> str <span class="keyword">in</span> <span class="type">PrefixSequence</span>(str: <span class="string">&quot;ABCDEFGHIJKLMN&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了sequence协议，就可以使用sequence协议中提供的所有方法</span></span><br><span class="line"><span class="keyword">let</span> lower = <span class="type">PrefixSequence</span>(str: <span class="string">&quot;ABCDEFGHIJKLMN&quot;</span>).<span class="built_in">map</span> &#123; <span class="keyword">return</span> $<span class="number">0</span>.lowercased() &#125;</span><br><span class="line"><span class="built_in">print</span>(lower.<span class="keyword">prefix</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>


<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><hr>
<p>集合类型 (Collection) 指的是那些稳定的序列，它们能够被多次遍历且保持一致。和序列不同，集合类型不能是无限的。</p>
<p>Collection 协议是建立在 Sequence 协议上的。除了从 Sequence 继承了全部方法以外，得益于可以获取指定位置的元素以及稳定迭代的保证，集合还获取了一些新的能力。比如 count 属性，如果序列是不稳定的，那么对序列计数将会消耗序列中的元素，这显然不是我们的目的。但是对于稳定的集合类型，我们就可以对其进行计数。</p>
<p>集合类型在标准库中运用广泛。除了 Array，Dictionary 和 Set 以外，String 的四种表示方式都是集合类型。另外还有 CountableRange 和 UnsafeBufferPointer 也是如此。更进一步，我们可以看到标准库外的一些类型也遵守了 Collection 协议。有两个我们熟知的类型通过这种方法获得了很多新的能力，它们是 Data 和 IndexSet，它们都来自 Foundation 框架。</p>
<p>自定义一个队列的集合类型：</p>
<p>1、为队列设计协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 一个能够将元素入队和出队的类型</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 在 `self` 中所持有的元素的类型</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line">    <span class="comment">/// 将 `newElement` 入队到 `self`</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">_</span> newElement: Element)</span></span></span><br><span class="line">    <span class="comment">/// 从 `self` 出队一个元素</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">dequeue</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、队列的实现</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 一个高效的 FIFO 队列，其中元素类型为 `Element`</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FIFOQueue</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> <span class="keyword">left</span>: [<span class="type">Element</span>] = []</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> <span class="keyword">right</span>: [<span class="type">Element</span>] = []</span><br><span class="line">    <span class="comment">/// 将元素添加到队列最后</span></span><br><span class="line">    <span class="comment">/// - 复杂度: O(1)</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">_</span> newElement: Element)</span></span> &#123;</span><br><span class="line">        <span class="keyword">right</span>.append(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 从队列前端移除一个元素</span></span><br><span class="line">    <span class="comment">/// 当队列为空时，返回 nil</span></span><br><span class="line">    <span class="comment">/// - 复杂度: 平摊 O(1)</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">dequeue</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">left</span>.isEmpty &#123;</span><br><span class="line">            <span class="keyword">left</span> = <span class="keyword">right</span>.reversed()</span><br><span class="line">            <span class="keyword">right</span>.removeAll()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span>.popLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会对 dequeue 操作被声明为 O(1) 感到有一点奇怪。确实，它包含了一个复杂度为 O(n) 的 reverse 操作。对于单个的操作来说可能耗时会长一些，不过对于非常多的 push 和 pop 操作来说，取出一个元素的平摊耗时是一个常数。</p>
<p>理解这个复杂度的关键在于理解反向操作发生的频率以及发生在多少个元素上。我们可以使用“银行家理论”来分析平摊复杂度。想象一下，你每次将一个元素放入队列，就相当于你在银行存了一块钱。接下来，你把右侧的栈的内容转移到左侧去，因为对应每个已经入队的元素，你在银行里都相当于有一块钱。你可以用这些钱来支付反转。你的账户永远不会负债，你也从来不会花费比你付出的更多的东西。</p>
<p>这个理论可以用来解释一个操作的消耗在时间上进行平摊的情况，即便其中的某次调用可能不是常数，但平摊下来以后这个耗时依然是常数。Swift 中向数组后面添加一个元素的操作是常数时间复杂度，这也可以用同样的理论进行解释。当数组存储空间耗尽时，它需要申请更大的空间，并且把所有已经存在于数组中的元素复制过去。但是因为每次申请空间都会使存储空间翻倍，“添加元素，支付一块钱，数组尺寸翻倍，最多耗费所有钱来进行复制”这个理论已然是有效的。</p>
<h5 id="遵守-ExpressibleByArrayLiteral-协议"><a href="#遵守-ExpressibleByArrayLiteral-协议" class="headerlink" title="遵守 ExpressibleByArrayLiteral 协议"></a>遵守 ExpressibleByArrayLiteral 协议</h5><hr>
<p>遵守 ExpressibleByArrayLiteral 协议的好处是，可以像用字面量去创建一个Array的方式去创建队列（[value1, value2, etc]）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FIFOQueue</span>: <span class="title">ExpressibleByArrayLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ArrayLiteralElement</span> = <span class="type">Element</span></span><br><span class="line">    <span class="keyword">init</span>(arrayLiteral elements: <span class="type">Element</span>...) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="keyword">left</span>: elements.reversed(), <span class="keyword">right</span>: [])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> queue: <span class="type">FIFOQueue</span>&lt;<span class="type">Int</span>&gt; = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>字面量和类型的区别</strong></p>
<p>在这里需要特别注意 Swift 中字面量和类型的区别。<strong>这里的 [1, 2, 3] 并不是一个数组，它只是一个“数组字面量”，是一种写法，我们可以用它来创建任意的遵守 ExpressibleByArrayLiteral 的类型。</strong>在这个字面量里面还包括了其他的字面量类型，比如能够创建任意遵守 ExpressibleByIntegerLiteral 的整数型字面量。<br>这些字面量有“默认”的类型，<strong>如果你不指明类型，那些 Swift 将假设你想要的就是默认的类型。</strong>正如你所料，数组字面量的默认类型是 Array，整数字面量的默认类型是 Int，浮点数字面量默认为 Double，而字符串字面量则对应 String。<strong>但是这只发生在你没有指定类型的情况下。</strong></p>
<h5 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h5><hr>
<p>building…</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【三】可选值</title>
    <url>/2018/03/01/2018-03-01-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E4%B8%89%E3%80%91%E5%8F%AF%E9%80%89%E5%80%BC/</url>
    <content><![CDATA[<p>Swift 中可选值的定义如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">Wrapped</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">some</span>(wrapped)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>Optional</code> 是枚举类型，所以有的时候可以用模式匹配来进行一些巧妙的操作：</p>
<ul>
<li>使用 if case 来进行模式匹配，对非 nil 的值做 for 循环</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">nil</span>, <span class="number">4</span>, <span class="literal">nil</span>, <span class="number">44</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> i? <span class="keyword">in</span> ary &#123;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 4, 44</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ul>
<li>或者只对 nil 值进行循环</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="literal">nil</span> <span class="keyword">in</span> ary &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No Value&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了 x? 这个模式，它只会匹配那些非 nil 的值。这个语法是 .Some(x) 的简写形式，所以该循环还可以被写为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> .<span class="keyword">some</span>(i) <span class="keyword">in</span> ary &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【四】结构体和类</title>
    <url>/2018/03/02/2018-03-02-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E5%9B%9B%E3%80%91%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="结构体和类的主要不同点："><a href="#结构体和类的主要不同点：" class="headerlink" title="结构体和类的主要不同点："></a>结构体和类的主要不同点：</h3><ul>
<li><p>结构体 (和枚举) 是值类型，而类是引用类型。在设计结构体时，我们可以要求编译器保证不可变性。而对于类来说，我们就得自己来确保这件事情。</p>
</li>
<li><p>内存的管理方式有所不同。结构体可以被直接持有及访问，但是类的实例只能通过引用来间接地访问。结构体不会被引用，但是会被复制。也就是说，结构体的持有者是唯一的，但是类却能有很多个持有者。</p>
</li>
<li><p>使用类，我们可以通过继承来共享代码。而结构体 (以及枚举) 是不能被继承的。想要在不同的结构体或者枚举之间共享代码，我们需要使用不同的技术，比如像是组合、泛型以及协议扩展等。</p>
</li>
</ul>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><hr>
<p><strong>值语义 (value semantics)</strong><br>    * 结构体只有一个持有者。比如，当我们将结构体变量传递给一个函数时，函数将接收到结构体的复制，它也只能改变它自己的这份复制。这叫做值语义 (value semantics)，有时候也被叫做复制语义。</p>
<p><strong>引用语义 (reference semantics)</strong><br>    * 对于对象来说，它们是通过传递引用来工作的，因此类对象会拥有很多持有者，这被叫做引用语义 (reference semantics)。</p>
<p>因为结构体只有一个持有者，所以它不可能造成引用循环。而对于类和函数这样的引用类型，我们需要特别小心，避免造成引用循环的问题。</p>
<p>编译器所做的对于值类型的复制优化和值语义类型的写时复制行为并不是一回事儿。写时复制必须由开发者来实现，想要实现写时复制，你需要检测所包含的类是否有共享的引用。和自动移除不必要的值类型复制不同，写时复制是需要自己实现的。不过编译器会移除那些不必要的“无效”浅复制，以及像是数组这样的类型中的代码会执行“智能的”写时复制，两者互为补充，都是对值类型的优化。</p>
<a id="more"></a>

<p>如果你的结构体只由其他结构体组成，那编译器可以确保不可变性。同样地，当使用结构体时，编译器也可以生成非常快的代码。举个例子，对一个只含有结构体的数组进行操作的效率，通常要比对一个含有对象的数组进行操作的效率高得多。这是因为结构体通常要更直接：值是直接存储在数组的内存中的。而对象的数组中包含的只是对象的引用。最后，在很多情况下，编译器可以将结构体放到栈上，而不用放在堆里。</p>
<h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h3><hr>
<p>Swift 可以让我们在写出安全代码的同时，保留直观的可变代码的风格。</p>
<p>可变性带来的问题，在Foundation中有两个类，<code>NSArray</code> 和<code>NSMutableArray</code>。我们可以用 NSMutableArray 写出下面这样 (会崩溃) 的程序：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mutableArray: <span class="type">NSMutableArray</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> mutableArray &#123;</span><br><span class="line">    mutableArray.removeLastObject()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当迭代一个 NSMutableArray，你不能去改变它，因为迭代器是基于原始的数组工作的，改变数组将会破坏迭代器的内部状态。</p>
<p>在Swift数组中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> ary &#123;</span><br><span class="line">    ary.removeLast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子不会崩溃，这是因为迭代器持有了数组的一个本地的，独立的复制。这样，无论如何移除 <code>ary</code> 中的数据，数组的迭代器的复制依然持有最开始的三个元素。</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><hr>
<p>对于结构体，Swift 会自动按照成员变量为它添加初始化方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Float</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Float</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的方法，可以这样初始化：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newPoint = <span class="type">Point</span>(x: <span class="number">0.1</span>, y: <span class="number">0.2</span>)</span><br></pre></td></tr></table></figure>

<p>为 <code>Point</code> 重载加号：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> +<span class="params">(lhs: Point, rhs: Point)</span></span> -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Point</span>(x: lhs.x + rhs.x, y: lhs.y + rhs.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以进行 <code>Point</code> 之间相加了。这里是生成新的一个值，如果是 <code>+=</code> 该如何实现呢，这就要用到 <code>inout</code> 关键字。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> +=<span class="params">(lhs: <span class="keyword">inout</span> Point, rhs: Point)</span></span> &#123;</span><br><span class="line">    lhs = lhs + rhs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里接受一个 <code>Point</code> 值，并且在本地改变它的值，然后将新的值复制回去（覆盖原来的 <code>lhs</code> 的值）。这个行为和 mutating 方法如出一辙。实际上，mutating 标记的方法也就是结构体上的普通方法，只不过隐式的 self 被标记为了 inout 而已。</p>
<p>结构体并不意味着你的代码就可以像魔法一般做到线程安全。在闭包内的 while 循环和闭包外的 while 循环都引用了同一个结构体变量，两者会在同时发生改变。</p>
<h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h3><hr>
<p>在 Swift 标准库中，像是 Array，Dictionary 和 Set 这样的集合类型是通过一种叫做写时复制 (copy-on-write) 的技术实现的。我们这里有一个整数数组：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> y = x</span><br></pre></td></tr></table></figure>

<p>如果我们创建了一个新的变量 y，并且把 x 赋值给它时，会发生复制，现在 x 和 y 含有的事独立的结构体。在内部，这些 Array 结构体含有指向某个内存的引用。这个内存就是数组中元素所存储的位置，它们位于堆 (heap) 上。在这个时候，两个数组的引用指向的是内存中同一个位置，这两个数组共享了它们的存储部分。不过，当我们改变 x 的时候，这个共享会被检测到，内存将会被复制。这样一来，我们得以独立地改变两个变量。昂贵的元素复制操作只在必要的时候发生，也就是我们改变这两个变量的时候发生复制：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">x.append(<span class="number">5</span>)</span><br><span class="line">y.removeLast()</span><br><span class="line">x <span class="comment">// [1, 2, 3, 5]</span></span><br><span class="line">y <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<p>如果 Array 结构体中的引用在数组被改变的一瞬间时是唯一的话 (比如，没有声明 y)，那么也不会有复制发生，内存的改变将在原地进行。这种行为就是写时复制，作为一个结构体的作者，你并不能免费获得这种特性，你需要自己进行实现。当你自己的类型内部含有一个或多个可变引用，同时你想要保持值语义，并且避免不必要的复制时，为你的类型实现写时复制是有意义的。</p>
<h3 id="闭包和可变性"><a href="#闭包和可变性" class="headerlink" title="闭包和可变性"></a>闭包和可变性</h3><hr>
<p>例如，有一个函数在每次被调用时生成一个唯一的整数，直到 Int.max。这可以通过将状态移动到函数外部来实现。换句话说，这个函数对变量 i 进行了闭合 (close)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniqueInteger</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装成闭包</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniqueIntegerProvider</span><span class="params">()</span></span> -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数也是引用类型，如果我们将函数A赋值给另一个变量，编译器不会复制这个函数或者 i。相反，它将会创建一个指向相同函数的引用。<br>这对所有的闭包和函数来说都是正确的：如果我们传递这些闭包和函数，它们会以引用的方式存在，并共享同样的状态。</p>
<p>Swift 的结构体一般被存储在栈上，而非堆上。不过这其实是一种优化：默认情况下结构体是存储在堆上的，但是在绝大多数时候，这个优化会生效，并将结构体存储到栈上。当结构体变量被一个函数闭合的时候，优化将不再生效，此时这个结构体将存储在堆上。因为变量 i 被函数闭合了，所以结构体将存在于堆上。这样一来，就算uniqueIntegerProvider 退出了作用域，i 也将继续存在。与此相似，如果结构体太大，它也会被存储在堆上。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><hr>
<p>当把 Swift 和使用垃圾回收机制的语言进行对比时，第一印象是它们在内存管理上似乎很相似。大多数时候，你都不太需要考虑它。不过，看看下面的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> window: <span class="type">Window?</span> = <span class="type">Window</span>()</span><br><span class="line"><span class="keyword">var</span> view: <span class="type">View?</span> = <span class="type">View</span>(window: window!)</span><br><span class="line">window?.rootView = view</span><br><span class="line">view = <span class="literal">nil</span></span><br><span class="line">window = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>首先，我们创建了 window 对象，window 的引用计数将为 1。之后创建 view 对象时，它持有了 window 对象的强引用，所以这时候 window 的引用计数为 2，view 的计数为 1。接下来，将 view 设置为 window 的 rootView 将会使 view 的引用计数加一。此时 view 和 window 的引用计数都是 2。当把两个变量都设置为 nil 后，它们的引用计数都会是 1。即使它们已经不能通过变量进行访问了，但是它们却互相有着对彼此的强引用。这就被叫做引用循环，当处理类似于这样的数据结构时，我们需要特别小心这一点。因为存在引用循环，这样的两个对象在程序的生命周期中将永远无法被释放。</p>
<h4 id="weak-引用"><a href="#weak-引用" class="headerlink" title="weak 引用"></a>weak 引用</h4><p>要打破引用循环，我们需要确保其中一个引用要么是 weak，要么是 unowned。weak 引用表示不增加引用计数，并且当被引用的对象被释放时，将该 weak 引用自身设置为 nil。</p>
<p>构造函数<br>    * 构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。特别的一个类可以有多个构造函数 ，可根据其参数个数的不同或参数类型的不同来区分它们 即构造函数的重载。</p>
<p>析构函数<br>    * 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，delete会自动调用析构函数后释放内存）。</p>
<h4 id="unowned-引用"><a href="#unowned-引用" class="headerlink" title="unowned 引用"></a>unowned 引用</h4><p>因为 weak 引用的变量可以变为 nil，所以它们必须是可选值类型，但是有些时候这并不是你想要的。例如，也许我们知道我们的 view 将一定有一个 window，这样这个属性就不应该是可选值，而同时我们又不想一个 view 强引用 window。这种情况下，我们可以使用 unowned 关键字，这将不持有引用的对象，但是却假定该引用会一直有效。</p>
<p>对每个 unowned 的引用，Swift 运行时将为这个对象维护另外一个引用计数。当所有的 strong 引用消失时，对象将把它的资源 (比如对其他对象的引用) 释放掉。不过，这个对象本身的内存将继续存在，直到所有的 unowned 引用也都消失。这部分内存将被标记为无效 (有时候我们也把它叫做僵尸 (zombie) 内存)，当我们试图访问这样的 unowned 引用时，就会发生运行时错误。</p>
<p>当你不需要 weak 的时候，还是建议使用 unowned。一个 weak 变量总是需要被定义为 var，而 unowned 变量可以使用 let 来定义。不过，只有在你确定你的引用将一直有效时，才应该使用 unowned。</p>
<p>个人来说，我经常发现自己即使是在那些可以用 unowned 的场合，也还一直在用 weak。我们可能会时不时地对一些代码进行重构，而这可能会导致我们之前对于对象有效的假设失效，这种情况下使用 unowned 就很危险。当使用 weak 时，一个好处是编译器强制我们需要处理引用为 nil 时的可能性。</p>
<h3 id="结构体和类使用实践"><a href="#结构体和类使用实践" class="headerlink" title="结构体和类使用实践"></a>结构体和类使用实践</h3><hr>
<p>例子：银行账户转账功能：</p>
<p><strong>基于类的实现：</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 银行账户</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">USDCents</span> = <span class="type">Int</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> funds: <span class="type">USDCents</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">init</span>(funds: <span class="type">USDCents</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.funds = funds</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个账户</span></span><br><span class="line"><span class="keyword">let</span> alice = <span class="type">Account</span>(funds: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> bob = <span class="type">Account</span>(funds: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转账函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transfer</span><span class="params">(amount: USDCents, source: Account, destination: Account)</span></span></span><br><span class="line">    -&gt; <span class="type">Bool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">guard</span> source.funds &gt;= amount <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    source.funds -= amount</span><br><span class="line">    destination.funds += amount</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行转账</span></span><br><span class="line">transfer(<span class="number">50</span>, source: alice, destination: bob)</span><br></pre></td></tr></table></figure>

<p>缺点：<br>    * 不是线程安全的</p>
<hr>
<p><strong>基于纯结构体的实现：</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> funds: <span class="type">USDCents</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有使用 inout 关键词，这里的逻辑就要复杂一些</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transfer</span><span class="params">(amount: USDCents, source: Account, destination: Account)</span></span></span><br><span class="line">    -&gt; (source: <span class="type">Account</span>, destination: <span class="type">Account</span>)?</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">guard</span> source.funds &gt;= amount <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> newSource = source</span><br><span class="line">    <span class="keyword">var</span> newDestination = destination</span><br><span class="line">    newSource.funds -= amount</span><br><span class="line">    newDestination.funds += amount</span><br><span class="line">    <span class="keyword">return</span> (newSource, newDestination)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> (newAlice, newBob) = transfer(<span class="number">50</span>, source: alice, destination: bob) &#123;</span><br><span class="line">    <span class="comment">// 更新数据源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：<br>    * 线程安全</p>
<p>缺点：<br>    * 程序变得啰嗦</p>
<hr>
<p><strong>基于 inout 结构体实现</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transfer</span></span></span><br><span class="line"><span class="function">    <span class="params">(amount: USDCents, <span class="keyword">inout</span> source: Account, <span class="keyword">inout</span> destination: Account)</span></span></span><br><span class="line">    -&gt; <span class="type">Bool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">guard</span> source.funds &gt;= amount <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    source.funds -= amount</span><br><span class="line">    destination.funds += amount</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用含有 inout 修饰的参数的函数时，我们需要为变量加上 &amp; 符号。不过注意，和传递 C 指针的语法不同，这里不代表引用传递。当函数返回的时候，被改变的值会被复制回调用者中去：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> alice = <span class="type">Account</span>(funds: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> bob = <span class="type">Account</span>(funds: <span class="number">0</span>)</span><br><span class="line">transfer(<span class="number">50</span>, source: &amp;alice, destination: &amp;bob)</span><br></pre></td></tr></table></figure>

<p>优点：<br>    * 线程安全，保证了函数体内的稳定性<br>    * 写起来和基于类的策略一样容易</p>
<h3 id="闭包和内存"><a href="#闭包和内存" class="headerlink" title="闭包和内存"></a>闭包和内存</h3><hr>
<p>在 Swift 中，除了类以外，函数 (包括闭包) 也是引用类型。我们在闭包和可变性的部分已经看到过，闭包可以捕获变量。如果这些变量是引用类型的话，闭包将持有对它们的强引用。</p>
<p><strong>引用循环：</strong></p>
<p>对象 A 引用了对象 B，但是对象 B 引用了一个包含对象 A 的回调。让我们考虑之前的例子，当一个视图引用了它的窗口时，窗口通过一个弱引用指向这个根视图。在此基础上，窗口现在多了一个 onRotate 回调，它是一个可选值，初始值为 nil：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">Window</span></span><br><span class="line">    <span class="keyword">init</span>(window: <span class="type">Window</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.window = window</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Deinit View&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> rootView: <span class="type">View?</span></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Deinit Window&quot;</span>)&#125;</span><br><span class="line">    <span class="keyword">var</span> onRotate: (() -&gt; ())?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们像之前那样创建视图，设置窗口，一切照旧，我们不会引入引用循环：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> window: <span class="type">Window?</span> = <span class="type">Window</span>()</span><br><span class="line"><span class="keyword">var</span> view: <span class="type">View?</span> = <span class="type">View</span>(window: window!)</span><br><span class="line">window?.rootView = view!</span><br></pre></td></tr></table></figure>

<p>视图强引用了窗口，但是窗口只是弱引用视图，一切安好。但是，如果我们对 onRotate 回调进行配置，并在其中使用 view 的话，我们就会引入一个引用循环：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">window?.onRotate = &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;We now also need to update the view: \(view)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>视图引用了窗口，窗口引用回调，回调引用视图：循环形成。</p>
<p>![](/my_pictures/2018-03-02-Swift 进阶【四】结构体和类-1.jpg)</p>
<p>我们需要找到一种办法来打破这个引用循环。有三种方式可以打破循环，每种方式都在图表中用箭头表示出来了：</p>
<ul>
<li>我们可以让指向 Window 的引用变为 weak。不过不幸的是，这会导致 Window 消失，因为没有其他指向它的强引用了。</li>
<li>我们可以将 Window 的 onRotate 闭包声明为 weak。不过这也不可行，因为闭包其实是没有办法被标记为 weak 的，而且就算 weak 闭包是可能的，所有的 Window 的用户需要知道这件事情，因为有时候会需要手动引用这个闭包。</li>
<li>我们可以通过使用捕获列表 (capture list) 来让闭包不去引用视图。这在上面这些例子中是唯一正确的选项。</li>
</ul>
<p><strong>捕获列表：</strong></p>
<p>为了打破上面的循环，我们需要保证闭包不去引用 视图。我们可以通过使用捕获列表并将捕获变量 view 标记为 weak 或者 unowned 来达到这个目的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">window?.onRotate = &#123; [<span class="keyword">weak</span> view] <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;We now also need to update the view: \(view)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>捕获列表也可以用来初始化新的变量。比如，如果我们想要用一个 weak 变量来引用窗口，我们可以将它在捕获列表中进行初始化，我们甚至可以定义完全不相关的变量，就像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">window?.onRotate = &#123; [<span class="keyword">weak</span> view, <span class="keyword">weak</span> myWindow=window, x=<span class="number">5</span>*<span class="number">5</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;We now also need to update the view: \(view)&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Because the window \(myWindow) changed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这和上面闭包的定义几乎是一样的，只有在捕获列表的地方有所不同。这些变量的作用域只在闭包内部，在闭包外面它们是不能使用的。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift学习</tag>
      </tags>
  </entry>
  <entry>
    <title>内存：栈和堆（C / Swift）</title>
    <url>/2018/03/14/2018-03-14-%E5%86%85%E5%AD%98%EF%BC%9A%E6%A0%88%E5%92%8C%E5%A0%86%EF%BC%88C%20:%20Swift%EF%BC%89/</url>
    <content><![CDATA[<h3 id="栈（C-语言描述）"><a href="#栈（C-语言描述）" class="headerlink" title="栈（C 语言描述）"></a>栈（C 语言描述）</h3><hr>
<p>什么是栈（Stack）？这是计算机内存中的一个特殊区域，它存储由每个函数创建的临时变量（包括 <code>main()</code> 函数）。栈是一个“LIFO”（后进先出）的数据结构。它是被 CPU 管理和优化的。每次函数声明一个新变量时，它都被“压入”栈中。然后每次函数退出时，所有由该函数压入栈的变量都被释放（也就是说，它们被删除）。一旦释放栈变量，该区域的内存就可用于其他栈变量。</p>
<p>使用栈来存储变量的优点是内存是自动为你管理的。你无需手动分配内存，或者在你不再需要时释放内存。更重要的是，由于 CPU 如此高效地组织栈内存，读取和写入栈变量的速度非常快。</p>
<p>理解栈的关键是这样一个概念：当一个函数退出时，它的所有变量都从栈中弹出（因此永远丢失）。因此栈变量本质上是本地的。这与我们之前看到的一个概念（称为变量范围）或局部变量或全局变量有关。 C 编程中的一个常见错误是尝试访问某个函数内栈上创建的变量，该函数在该函数之外的某个地方（即该函数退出后）从该程序中创建。</p>
<p>要记住栈的另一个特性是，可以存储在栈上的变量的大小有一个限制（随OS变化）。对于在堆中分配的变量，情况并非如此。</p>
<p><strong>栈的总结：</strong> </p>
<ul>
<li>随着函数压入和弹出局部变量，栈增长和缩小 </li>
<li>没有必要自己管理内存，变量内存被自动的分配和释放 </li>
<li>栈具有大小限制 </li>
<li>栈变量仅在创建它们的函数正在运行时才存在</li>
</ul>
<h3 id="堆（C-语言描述）"><a href="#堆（C-语言描述）" class="headerlink" title="堆（C 语言描述）"></a>堆（C 语言描述）</h3><hr>
<p>堆是计算机内存中的一个区域，不会自动为你进行内存管理，并且不受 CPU 的严格管理。它是一个更自由的内存区域（并且更大）。要在堆上分配内存，必须使用 <code>malloc()</code> 或 <code>calloc()</code> ，它们是内置的 C 函数。一旦你在堆上分配了内存，当你不再需要它的时候，你就有责任使用 <code>free()</code> 来释放内存。如果你没有做到这一点，你的程序将会有所谓的内存泄漏。也就是说，堆上的内存仍然会被留出（并且不会被其他进程使用）。</p>
<a id="more"></a>

<p>与栈不同，堆没有栈那样大小的限制（除了计算机明显的物理限制外）。<br>由于必须使用指针访问堆上的内存，因此堆内存的读取和写入速度稍慢。<br>与栈不同，在堆中创建的变量可以通过程序中任何位置的任何函数访问。<br>堆变量实质上是全局的。</p>
<h3 id="栈与堆的优点和缺点"><a href="#栈与堆的优点和缺点" class="headerlink" title="栈与堆的优点和缺点"></a>栈与堆的优点和缺点</h3><hr>
<p>栈 </p>
<ul>
<li>访问速度非常快 </li>
<li>不必显式的释放分配的内存 </li>
<li>空间由 CPU 高效管理，内存不会变得碎片化 </li>
<li>只有局部变量 </li>
<li>栈的大小有限制（取决于操作系统） </li>
<li>变量不能调整内存大小 </li>
</ul>
<p>堆 </p>
<ul>
<li>变量可以全局访问 </li>
<li>内存大小没有限制 </li>
<li>（相对）较慢的访问 </li>
<li>没有保证有效利用空间，随着内存块被分配，内存随着时间的推移可能变得碎片化，然后释放 </li>
<li>你必须手动管理内存（分配和释放） </li>
<li>可以使用 <code>realloc()</code> 来调整变量的内存大小</li>
</ul>
<h3 id="例子🌰"><a href="#例子🌰" class="headerlink" title="例子🌰"></a>例子🌰</h3><hr>
<p>下面是一个简短的程序，它在<strong>栈</strong>上创建它的变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">multiplyByTwo</span> <span class="params">(<span class="keyword">double</span> input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> twice = input * <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">return</span> twice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">double</span> salary = <span class="number">12345.67</span>;</span><br><span class="line">    <span class="keyword">double</span> myList[<span class="number">3</span>] = &#123;<span class="number">1.2</span>, <span class="number">2.3</span>, <span class="number">3.4</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;double your salary is %.3f\n&quot;</span>, multiplyByTwo(salary));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// double your salary is 24691.340</span></span><br></pre></td></tr></table></figure>

<p>在第 10, 11 和 12 行，我们声明了变量：一个 <code>int </code> ，一个 <code>double</code> 和一个由三个双精度组成的数组。只要 <code>main()</code> 函数执行，这三个变量就会被压入栈。当 <code>main()</code> 函数退出（并且程序停止）时，这些变量将从栈中弹出。类似地，在函数 <code>multiplyByTwo()</code> 中，一旦 <code>multiplyByTwo()</code> 函数执行， <code>double</code> 变量，即 <code>double</code> 将被压入栈。一旦 <code>multiplyByTwo()</code> 函数退出，两个变量就从栈中弹出，并且永远消失。</p>
<p>另一点说明，有一种方法可以告诉 C 保存栈变量，即使在其创建者函数退出，就是在声明变量时使用 <code>static</code> 关键字。用 <code>static</code> 关键字声明的变量因此变成类似于全局变量的变量，但是仅在创建它的函数内部可见。这是一种奇怪的结构，除非在特定的情况下，否则你可能不需要这种结构。</p>
<p>下面是该程序的另一个版本，它将它的所有变量分配给<strong>堆</strong>而不是<strong>栈</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> *<span class="title">multiplyByTwo</span> <span class="params">(<span class="keyword">double</span> *input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> *twice = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    *twice = *input * <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">return</span> twice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *age = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    *age = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">double</span> *salary = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    *salary = <span class="number">12345.67</span>;</span><br><span class="line">    <span class="keyword">double</span> *myList = <span class="built_in">malloc</span>(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    myList[<span class="number">0</span>] = <span class="number">1.2</span>;</span><br><span class="line">    myList[<span class="number">1</span>] = <span class="number">2.3</span>;</span><br><span class="line">    myList[<span class="number">2</span>] = <span class="number">3.4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> *twiceSalary = multiplyByTwo(salary);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;double your salary is %.3f\n&quot;</span>, *twiceSalary);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(age);</span><br><span class="line">    <span class="built_in">free</span>(salary);</span><br><span class="line">    <span class="built_in">free</span>(myList);</span><br><span class="line">    <span class="built_in">free</span>(twiceSalary);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，使用 <code>malloc()</code> 在堆上分配内存，然后使用 <code>free()</code> 来释放它，没有什么大不了的，但有点麻烦。另外要注意的是，现在到处都有一堆星号（*）。那些是什么？答案是，他们是指针。 <code>malloc()</code>（<code>calloc()</code> 和 <code>free()</code> ）函数处理的是指针而不是实际值。指针是 C 中的一种特殊数据类型，它将地址存储在内存中，而不是存储实际值。因此，在上面的第 5 行中，两次变量不是 <code>double</code>，而是一个指向 <code>double</code> 的指针。在内存地址中，这是一个 <code>double</code> 类型的数据。</p>
<h3 id="何时使用堆？何时使用栈？"><a href="#何时使用堆？何时使用栈？" class="headerlink" title="何时使用堆？何时使用栈？"></a>何时使用堆？何时使用栈？</h3><hr>
<p>什么时候应该使用堆，什么时候应该使用栈？</p>
<ul>
<li>如果你需要分配一大块内存（例如一个大的数组，或者一个大的结构体），并且你需要在很长的时间内保存这个变量（比如全局变量），那么你应该把它分配到堆上。</li>
<li>如果你正在处理的是只有在使用它们的函数仍然存在时才需要保持的小变量，那么你应该使用栈，因为它使用起来更容易也更快。</li>
<li>如果你需要动态改变大小的数组和结构体等变量（例如可根据需要增长或缩小的数组），那么你可能需要在堆上分配它们，并使用动态内存分配函数，如<code>malloc()</code> ，<code>calloc()</code> ，<code>realloc()</code> 和 <code>free()</code> 来“手动”管理该内存。</li>
</ul>
<h3 id="数据在内存中的存储（C-语言描述-）"><a href="#数据在内存中的存储（C-语言描述-）" class="headerlink" title="数据在内存中的存储（C 语言描述 ）"></a>数据在内存中的存储（C 语言描述 ）</h3><hr>
<p>这里有一条黄金法则：</p>
<ul>
<li>引用类型总是被分配到“堆”上。</li>
<li>值类型总是分配到它声明的地方：<ul>
<li>作为引用类型的成员变量分配到“堆”上</li>
<li>作为方法的局部变量时分配到“栈”上</li>
</ul>
</li>
</ul>
<h3 id="结构体在内存中的存储（Swift-语言描述）"><a href="#结构体在内存中的存储（Swift-语言描述）" class="headerlink" title="结构体在内存中的存储（Swift 语言描述）"></a>结构体在内存中的存储（Swift 语言描述）</h3><hr>
<p>与 C 语言不同，苹果对 Swift 中的结构体有着优化，使其能够存储在栈上，进而加快访问速度与增加操作的安全性。</p>
<p>如果你的结构体只由其他结构体组成，那编译器可以确保不可变性。同样地，当使用结构体时，编译器也可以生成非常快的代码。举个例子，对一个只含有结构体的数组进行操作的效率，通常要比对一个含有对象的数组进行操作的效率高得多。这是因为结构体通常要更直接：值是直接存储在数组的内存中的。而对象的数组中包含的只是对象的引用。最后，在很多情况下，编译器可以将结构体放到栈上，而不用放在堆里。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniqueIntegerProvider</span><span class="params">()</span></span> -&gt; <span class="type">AnyIterator</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">AnyIterator</span> &#123;</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swift 的结构体一般被存储在栈上，而非堆上。不过这其实是一种优化：默认情况下结构体是存储在堆上的，但是在绝大多数时候，这个优化会生效，并将结构体存储到栈上。<strong>当结构体变量被一个函数闭合的时候，优化将不再生效，此时这个结构体将存储在堆上</strong>。因为变量 i 被函数闭合了，所以结构体将存在于堆上。这样一来，就算 uniqueIntegerProvider 退出了作用域，i 也将继续存在。与此相似，<strong>如果结构体太大，它也会被存储在堆上</strong>。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift专题</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【五】函数</title>
    <url>/2018/03/16/2018-03-16-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E4%BA%94%E3%80%91%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="在-Swift-中函数是一等公民。"><a href="#在-Swift-中函数是一等公民。" class="headerlink" title="在 Swift 中函数是一等公民。"></a>在 Swift 中函数是一等公民。</h3><hr>
<p>要理解 Swift 中的函数和闭包，需要先明白三件事情，按重要程度进行大致排序如下：</p>
<ol>
<li>函数可以像 Int 或者 String 那样被赋值给变量，也可以作为另一个函数的输入参数，或者另一个函数的返回值来使用。</li>
<li>函数能够捕获存在于其局部作用域之外的变量。</li>
<li>有两种方法可以创建函数，一种是使用 <code>func</code> 关键字，另一种是 <code>&#123; &#125;</code>。在 Swift 中，后一种被称为<strong>闭包表达式</strong>。</li>
</ol>
<h5 id="函数可以被赋值给变量，也能够作为函数的输入和输出"><a href="#函数可以被赋值给变量，也能够作为函数的输入和输出" class="headerlink" title="函数可以被赋值给变量，也能够作为函数的输入和输出"></a>函数可以被赋值给变量，也能够作为函数的输入和输出</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个函数接受 Int 值并将其打印</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInt</span><span class="params">(i: Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;you passed \(i)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要将函数赋值给一个变量，比如 funVar，我们只需要将函数名字作为值就可以了。注意在函数名后没有括号：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> funVar = printInt</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>现在，我们可以使用 funVar 变量来调用 printInt 函数。注意在函数名后面需要使用括号：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">funVar(<span class="number">2</span>) <span class="comment">// 将打印 &quot;you passed 2&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们也能够写出一个接受函数作为参数的函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">useFunction</span><span class="params">(function: <span class="params">(Int)</span></span></span> -&gt; () ) &#123;</span><br><span class="line">    function(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">useFunction(function: printInt) <span class="comment">// you passed 3</span></span><br><span class="line">useFunction(function: funVar) <span class="comment">// you passed 3</span></span><br></pre></td></tr></table></figure>

<p>为什么将函数作为变量来处理这件事情如此关键？因为它让你很容易写出 “高阶” 函数，高阶函数将函数作为参数的能力使得它们在很多方面都非常有用。</p>
<p>你也可以在其他函数中返回一个函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnFunc</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">innerFunc</span><span class="params">(i: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;you passed \(i)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerFunc</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myFunc = returnFunc()</span><br><span class="line">myFunc(<span class="number">3</span>) <span class="comment">// you passed 3</span></span><br></pre></td></tr></table></figure>

<h5 id="函数可以捕获存在于它们作用范围之外的变量"><a href="#函数可以捕获存在于它们作用范围之外的变量" class="headerlink" title="函数可以捕获存在于它们作用范围之外的变量"></a>函数可以捕获存在于它们作用范围之外的变量</h5><p>当函数引用了在函数作用域外部的变量时，这个变量就被 “捕获” 了，它们将会继续存在，而不是在超过作用域后被摧毁。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counterFunc</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">innerFunc</span><span class="params">(i: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        counter += i <span class="comment">// counter is captured</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;running total: \(counter)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，因为 counter 是一个 counterFunc 的局部变量，它在 return 语句执行之后应该离开作用域并被摧毁。但是这个因为 innerFunc 捕获了它，它将继续存在。我们在结构体和类讨论过，counter 将存在于堆上而非栈上。我们可以多次调用 innerFunc，并且看到 running total 的输出在增加：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f = counterFunc()</span><br><span class="line">f(<span class="number">3</span>) <span class="comment">// running total: 3</span></span><br><span class="line">f(<span class="number">4</span>) <span class="comment">// running total: 7</span></span><br></pre></td></tr></table></figure>

<p>如果我们再次调用 counterFunc() 函数，将会生成并“捕获”新的 counter 变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = counterFunc()</span><br><span class="line">g(<span class="number">2</span>) <span class="comment">// running total: 2</span></span><br><span class="line">g(<span class="number">2</span>) <span class="comment">// running total: 4</span></span><br></pre></td></tr></table></figure>

<p>这不影响我们的第一个函数，它拥有它自己的 counter：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">f(<span class="number">2</span>) <span class="comment">// running total: 9</span></span><br></pre></td></tr></table></figure>

<p><strong>你可以将这些函数以及它们所捕获的变量想象为一个类的实例，这个类拥有一个单一的方法 (也就是这里的函数) 以及一些成员变量 (这里的被捕获的变量)。</strong></p>
<p><strong>在编程术语里，一个函数和它所捕获的变量环境组合起来被称为闭包。上面 f 和 g 都是闭包的例子，因为它们捕获并使用了一个在它们外部声明的非局部变量 counter。</strong></p>
<h5 id="函数可以使用-来声明为闭包表达式"><a href="#函数可以使用-来声明为闭包表达式" class="headerlink" title="函数可以使用 { } 来声明为闭包表达式"></a>函数可以使用 { } 来声明为闭包表达式</h5><p>在 Swift 中，定义函数的方法有两种。一种是像上面所示那样使用 func 关键字。另一种方法是使用<strong>闭包表达式</strong>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doubler</span><span class="params">(i: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">map</span>(doubler) <span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>

<p>使用闭包表达式的语法来写相同的函数，像之前那样将它传给 map：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> doublerAlt = &#123; (i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span> <span class="keyword">return</span> i*<span class="number">2</span> &#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">map</span>(doublerAlt) <span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>

<p><strong>使用闭包表达式来定义的函数可以被想成函数的字面量</strong>，就和 1 是整数字面量，”hello” 是字符串字面量那样。与 func 相比较，它的区别在于闭包表达式是匿名的，它们没有被赋予一个名字。使用它们的唯一方法是在它们被创建时将其赋值给一个变量，就像我们这里对 doubler 进行的赋值一样。</p>
<p><strong>使用闭包表达式声明的 doubler，和之前我们使用 func 关键字声明的函数，其实是完全等价的。它们甚至存在于同一个“命名空间”中，这一点和一些其他语言有所不同。</strong></p>
<p>这里，我们将 doubler map 的例子用短得多的形式进行了重写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">2</span> &#125; <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<p>之所以看起来和原来很不同，是因为我们使用了 Swift 中的一些特性，来让代码更加简洁。我们来一个个看看这些用到的特性：</p>
<ol>
<li>如果你将闭包作为参数传递，并且你不再用这个闭包做其他事情的话，就没有必要现将它存储到一个局部变量中。可以想象一下比如 5*i 这样的数值表达式，你可以把它直接传递给一个接受 Int 的函数，而不必先将它计算并存储到变量里。</li>
<li>如果编译器可以从上下文中推断出类型的话，你就不需要指明它了。在我们的例子中，从数组元素的类型可以推断出传递给 map 的函数接受 Int 作为参数，从闭包的乘法结果的类型可以推断出闭包返回的也是 Int。</li>
<li>如果闭包表达式的主体部分只包括一个单一的表达式的话，它将自动返回这个表达式的结果，你可以不写 return。</li>
<li>Swift 会自动为函数的参数提供简写形式，$0 代表第一个参数，$1 代表第二个参数，以此类推。</li>
<li>如果函数的最后一个参数是闭包表达式的话，你可以将这个闭包表达式移到函数调用的圆括号的外部。这样的尾随闭包语法在多行的闭包表达式中表现非常好，因为它看起来更接近于装配了一个普通的函数定义，或者是像 if (expr) { } 这样的执行块的表达形式。</li>
<li>最后，如果一个函数除了闭包表达式外没有别的参数，那么方法名后面的调用时的圆括号也可以一并省略。</li>
</ol>
<p><strong>最后要说明的是关于命名的问题。要清楚，那些使用 func 声明的函数也可以是闭包，就和用 { } 声明的是一样的。记住，闭包指的是一个函数以及被它所捕获的所有变量的组合。而使用 { } 来创建的函数被称为闭包表达式，人们常常会把这种语法简单地叫做闭包。但是不要因此就认为使用闭包表达式语法声明的函数和其他方法声明的函数有什么不同。它们都是一样的，它们都是函数，也都可以是闭包。</strong> </p>
<h3 id="inout-参数和可变方法"><a href="#inout-参数和可变方法" class="headerlink" title="inout 参数和可变方法"></a>inout 参数和可变方法</h3><hr>
<p>如果你有一些 <code>C</code> 或者 <code>C++</code> 背景的话，在 Swift 中 <code>inout</code> 参数前面使用的 <code>&amp;</code> 符号可能会给你一种它是传递引用的印象。但事实并非如此，<code>inout</code> 做的事情是通过值传递，然后复制回来，而并不是传递引用。 引用官方《Swift 编程语言》中的话：</p>
<blockquote>
<p>inout 参数将一个值传递给函数，函数可以改变这个值，然后将原来的值替换掉，并从函数中传出。  </p>
</blockquote>
<h3 id="嵌套函数和inout"><a href="#嵌套函数和inout" class="headerlink" title="嵌套函数和inout"></a>嵌套函数和inout</h3><hr>
<p>在一个嵌套函数中也可以使用 <code>inout</code> 关键词，Swift 依然会保证你的使用是安全的。比如说，你可以定义一个嵌套函数（使用 func 或者使用闭包表达式），然后安全地改变一个 <code>inout</code> 的参数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementTenTimes</span><span class="params">(value: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">inc</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">        inc()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line">incrementTenTimes(value: &amp;x)</span><br><span class="line">x <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>不过，你不能够让这个 <code>inout</code> 参数逃逸（我们会在本章最后详细提到逃逸函数的内容）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">escapeIncrement</span><span class="params">(value: <span class="keyword">inout</span> Int)</span></span> -&gt; () -&gt; () &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">inc</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以这么理解，因为 <code>inout</code> 的值会在函数返回之前复制回去，那么要是我们可以在函数返回之后再去改变它，应该要怎么做呢？是说值应该在改变以后再复制吗？要是调用源已经不存在了怎么办？编译器必须对此进行验证，因为这对保证安全十分关键。</p>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><hr>
<p>计算属性看起来和常规的属性很像，但是它并不使用任何内存来存储自己的值。相反，这个属性每次被访问时，返回值都将被实时计算出来。 </p>
<p>举个简单的例子，GPS 追踪信息结构体：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GPSTrack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> record: [(<span class="type">CLLocation</span>, <span class="type">Date</span>)] = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">GPSTrack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 返回 GPS 追踪的所有日期</span></span><br><span class="line">    <span class="comment">/// - 复杂度：O(n)，n 是记录点的数量。</span></span><br><span class="line">    <span class="keyword">var</span> dates: [<span class="type">Date</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> record.<span class="built_in">map</span> &#123; $<span class="number">0.1</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们没有指定 <code>setter</code>，所以 <code>dates</code> 属性是只读的。它的结果不会被缓存，每次在你调用 <code>dates</code> 属性时，结果都要被计算一遍。<strong>Swift API 指南推荐你对所有复杂度不是 O(1) 的计算属性都应该在文档中写明，因为调用者可能会假设一个计算属性的耗时是常数时间。</strong></p>
<h3 id="延迟存储属性（懒加载）"><a href="#延迟存储属性（懒加载）" class="headerlink" title="延迟存储属性（懒加载）"></a>延迟存储属性（懒加载）</h3><hr>
<p>延迟初始化一个值在 Swift 中是一种常见的模式，Swift 为此准备了一个特殊的 <code>lazy</code> 关键字来定义一个延迟属性（lazy property）。需要注意，延迟属性会被自动声明为 <code>mutating</code>，因此，这个属性也必须被声明为 <code>var</code>。延迟修饰符是编程记忆化的一种特殊形式。</p>
<p>比如，如果我们有一个 <code>view controller</code> 来显示 GPSTrack，我们可能会想展示一张追踪的预览图像。通过将属性改为延迟加载，我们可以将昂贵的图像生成工作推迟到属性被首次访问：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GPSTrackViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> track: <span class="type">GPSTrack</span> = <span class="type">GPSTrack</span>()</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> preview: <span class="type">UIImage</span> = &#123;</span><br><span class="line">        <span class="keyword">for</span> point <span class="keyword">in</span> <span class="keyword">self</span>.track.record &#123;</span><br><span class="line">            <span class="comment">// 进行昂贵的计算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIImage</span>()</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们第一次访问这个属性 <code>preview</code> 的时候，闭包将被执行（注意闭包后面的括号），它的返回值被存储在变量中。</p>
<p><strong>如果 <code>track</code> 属性发生了改变，<code>preview</code> 并不会自动更新。</strong>让我们来用一个更简单的例子来看看发生了什么。我们有一个 <code>Point</code> 结构体，并且用延迟的方式存储了 <code>distanceFromOrigin</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> distanceFromOrigin: <span class="type">Double</span> = <span class="keyword">self</span>.x * <span class="keyword">self</span>.x + <span class="keyword">self</span>.y * <span class="keyword">self</span>.y</span><br><span class="line">    <span class="keyword">init</span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point = <span class="type">Point</span>(x: <span class="number">3</span>, y: <span class="number">4</span>)</span><br><span class="line">point.distanceFromOrigin <span class="comment">// 25.0</span></span><br><span class="line">point.x += <span class="number">10</span></span><br><span class="line">point.distanceFromOrigin <span class="comment">// 25.0</span></span><br></pre></td></tr></table></figure>

<p>当我们创建一个点后，可以访问 <code>distanceFromOrigin</code> 属性，这将会计算出值，并存储起来<strong>等待重用</strong>。不过，如果我们之后改变了 x 的值，这个变化将不会反应在 <code>distanceFromOrigin</code> 中。</p>
<p>解决办法：将其改为普通的（非延迟）计算属性。</p>
<h3 id="escaping-标注"><a href="#escaping-标注" class="headerlink" title="@escaping 标注"></a>@escaping 标注</h3><hr>
<p>正如我们在之前一章中看到的那样，在处理闭包时我们需要对内存格外小心。回想一下捕获列表的例子，在那个例子中为了避免引用循环，我们将 <code>view</code> 标记为了 <code>weak</code> ：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">window?.onRotate = &#123; [<span class="keyword">weak</span> view] <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;We now also need to update the view: \(view)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，在我们使用 <code>map</code> 这样的函数的时候，我们从来不会去把什么东西标记为 <code>weak</code>。因为 <code>map</code> 将同步执行，这个闭包不会被任何地方持有，也不会有引用循环被创建出来，所以并不需要这么做。和我们传递给 <code>map</code> 的闭包相比，这里存储在 <code>onRotate</code> 中的闭包是逃逸的 (escape)，两者有所区别。</p>
<p>一个被保存在某个地方等待稍后（比如函数返回以后）再调用的闭包就叫做<strong>逃逸闭包</strong>。而传递给 <code>map</code> 的闭包会在 <code>map</code> 中被直接使用。这意味着编译去不需要改变在闭包中被捕获的变量的引用计数。</p>
<blockquote>
<p>在 Swift 3 之前，事情完全相反：那时候逃逸闭包是默认的，对非逃逸闭包，你需要标记出<code>@noescape</code>。Swift 3 的行为更好，因为它默认是安全的：如果一个函数参数可能导致引用循环，那么它需要被显式地标记出来。<code>@escaping</code> 标记可以作为一个警告，来提醒使用这个函数的开发者注意引用关系。非逃逸闭包可以被编译器高度优化，快速的执行路径将被作为基准而使用，除非你在有需要的时候显式地使用其他方法。  </p>
</blockquote>
<p><strong>注意默认非逃逸的规则只对那些直接参数位置（immediate parameter position）的函数类型有效。也就是说，类型是函数的存储属性将会是逃逸的（这很正常）。出乎意料的是，对于那些使用闭包作为参数的函数，如果闭包被封装到像是多元组或者可选值等类型的话，这个闭包参数也是逃逸的。因为在这种情况下闭包不是直接参数，它将自动变为逃逸闭包。这样的结果是，你不能写出一个函数，使它接受的函数参数同时满足可选值和非逃逸。很多情况下，你可以通过为闭包提供一个默认值来避免可选值。如果这样做行不通的话，可以通过重载函数，提供一个包含可选值 (逃逸) 的函数，以及一个不可选，不逃逸的函数来绕过这个限制：</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transform</span><span class="params">(<span class="keyword">_</span> input: Int, with f: <span class="params">(<span class="params">(Int)</span></span></span></span> -&gt; <span class="type">Int</span>)?) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Using optional overload&quot;</span>)</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> f = f <span class="keyword">else</span> &#123; <span class="keyword">return</span> input &#125;</span><br><span class="line">    <span class="keyword">return</span> f(input)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transform</span><span class="params">(<span class="keyword">_</span> input: Int, with f: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Using non-optional overload&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> f(input)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">transform(<span class="number">10</span>, with: <span class="literal">nil</span>) <span class="comment">// 使用可选值重载</span></span><br><span class="line">transform(<span class="number">10</span>) &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125; <span class="comment">// 使用非可选值重载</span></span><br></pre></td></tr></table></figure>

<p>这样一来，如果用 <code>nil</code> 参数（或者一个可选值类型的变量）来调用函数，将使用可选值变种，而如果使用闭包字面量的调用将使用非逃逸和非可选值的重载方法。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift学习</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 11权限更新</title>
    <url>/2018/03/17/2018-03-17-iOS%2011%E6%9D%83%E9%99%90%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>最近项目中遇到了一个崩溃，当点击图片选择保存的时候，并没有出现请求相册权限的对话框，而是直接就崩溃，并且没有任何错误信息。开始以为是权限没有添加，但是 <code>NSPhotoLibraryUsageDescription</code> 是添加了的，搞不懂了。去翻了翻官方的文档，果然找到了解决方式。</p>
<p>从 iOS 11 开始，相册的权限参数发生了变化，适配 iOS 11 还需要添加一个 <code>NSPhotoLibraryAddUsageDescription</code> 的参数。官方的描述如下：</p>
<blockquote>
<p><strong>NSPhotoLibraryAddUsageDescription</strong></p>
<p><code>NSPhotoLibraryAddUsageDescription</code> ( <code>String</code> - iOS) This key lets you describe the reason your app seeks write-only access to the user’s photo library. When the system prompts the user to allow access, this string is displayed as part of the alert.</p>
<p>Important: To protect user privacy, an iOS app linked on or after iOS 10.0, and that accesses the user’s photo library, must statically declare the intent to do so. Include the NSPhotoLibraryAddUsageDescription key (in apps that link on or after iOS 11) or NSPhotoLibraryUsageDescription key in your app’s <code>Info.plist</code> file and provide a purpose string for the key. If your app attempts to access the user’s photo library without a corresponding purpose string, your app exits.  </p>
<p>This key is supported in iOS 11.0 and later.</p>
</blockquote>
<p>从 important 的最后一句话可以看出，当应用试图访问用户相册但是 <code>Info.plist</code>  中并没有对应权限的参数的话，应用就会退出。</p>
<a id="more"></a>

<p>原因找到，添加上新的参数。搞定！！！</p>
<p>关于 <code>Info.plist</code> 中的 <code>key</code> ，可以参考官方的文档：<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html">Cocoa Keys</a></p>
<p>相关权限申请：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PermissionsManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 相册权限</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - authorizedClosure: 已授权回调</span></span><br><span class="line">    <span class="comment">///   - deniedClosure: 未授权回调</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">albumPermissions</span><span class="params">(authorizedClosure: <span class="params">(<span class="params">()</span></span></span></span> -&gt; ())?, deniedClosure: (() -&gt; ())?) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> status = <span class="type">PHPhotoLibrary</span>.authorizationStatus()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> status &#123;</span><br><span class="line">        <span class="keyword">case</span> .notDetermined:</span><br><span class="line">            <span class="type">PHPhotoLibrary</span>.requestAuthorization &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.albumPermissions(authorizedClosure: authorizedClosure, deniedClosure: deniedClosure)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .authorized:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> authorized = authorizedClosure &#123;</span><br><span class="line">                authorized()</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> denied = deniedClosure &#123;</span><br><span class="line">                denied()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 相机权限</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - authorizedClosure: 已授权回调</span></span><br><span class="line">    <span class="comment">///   - deniedClosure: 未授权回调</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cameraPermissions</span><span class="params">(authorizedClosure: <span class="params">(<span class="params">()</span></span></span></span> -&gt; ())?, deniedClosure: (() -&gt; ())?) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> status = <span class="type">AVCaptureDevice</span>.authorizationStatus(<span class="keyword">for</span>: .video)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> status &#123;</span><br><span class="line">        <span class="keyword">case</span> .notDetermined:</span><br><span class="line">            <span class="type">AVCaptureDevice</span>.requestAccess(<span class="keyword">for</span>: .video) &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.cameraPermissions(authorizedClosure: authorizedClosure, deniedClosure: deniedClosure)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .authorized:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> authorized = authorizedClosure &#123;</span><br><span class="line">                authorized()</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> denied = deniedClosure &#123;</span><br><span class="line">                denied()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>iOS工作日志</tag>
      </tags>
  </entry>
  <entry>
    <title>layoutIfNeeded() 函数对 UIScrollView 的影响</title>
    <url>/2018/03/17/2018-03-17-layoutIfNeeded()%20%E5%87%BD%E6%95%B0%E5%AF%B9%20UIScrollView%20%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    <content><![CDATA[<p>在做 iOS 相关的约束动画时，我们一定会用到 <code>layoutIfNeeded()</code> 函数，但是在大多数情况下使用并没有什么问题。当与 <code>UIScrollView</code> 相关的控件结合使用的时候要注意了。</p>
<p>在开发一个 App 时（类似于浏览器的 App），需求是，滑动的时候，需要隐藏掉顶部的 <code>navigation bar</code> （这里我是用 <code>UIView</code> 自定义的一个 <code>navigation bar</code>）。向上滑动，让 <code>navigation bar</code> 移动到可视区域外消失，当然，移动的时候是有动画的，这里我用的是 <code>constraint</code> 相关的动画，所以我需要在最后调用一次 <code>layoutIfNeeded()</code> 函数。代码类似如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">0.35</span>) &#123;</span><br><span class="line">    <span class="comment">// 进行更改约束的操作</span></span><br><span class="line">    <span class="keyword">self</span>.view.layoutIfNeeded()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>这时就出现问题了，滑动的时候，你想让滑动停止，当然是手指放在屏幕上，滑动就会立刻停止，不过在进行布局动画的时候，滑动将会继续，只有当动画完了的时候，视图才会响应你的点击事件。</p>
<p>为了避免上述的问题，建议使用 <code>Core Graphics</code> 来完成上述的动画效果，即：<code>CGAffineTransform</code></p>
<p>使用 <code>Core Graphics</code> 完成动画，也能避免 <code>layoutIfNeeded()</code> 必须在父视图中调用这一要求的一些恶心的问题。</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>iOS工作日志</tag>
      </tags>
  </entry>
  <entry>
    <title>8 Mistakes to Avoid while Using RxSwift</title>
    <url>/2018/03/19/2018-03-19-8%20Mistakes%20to%20Avoid%20while%20Using%20RxSwift/</url>
    <content><![CDATA[<p>Judging by the number of talks, articles and discussions related to reactive programming in Swift, it looks like the community has been taken by the storm. It’s not that the concept of <em>reactiveness</em> itself is a new shiny thing. The idea of using it for the development within the Apple ecosystem had been played with for a long time. Frameworks like <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> have existed for years and did an awesome job at bringing the reactive programming to the Objective-C. However, the new and exciting features of Swift make it even more convenient to go full in on the “signals as your apps’ building blocks” model.</p>
<p>Here at Polidea, we’ve also embraced the reactive paradigm, mostly in the form of <a href="https://github.com/ReactiveX/RxSwift">RxSwift</a>, the port of C#-originated <a href="http://reactivex.io/">Reactive Extensions</a>. And we couldn’t be happier! It helps us build more expressive and better-architectured apps faster and easier. Unifying various patterns (target-action, completion block, notification) under a universal API that is easy to use, easy to compose and easy to test has so many benefits. Also, introducing new team members is way easier now, when so much logic is written with methods familiar either from sequences (map, filter, zip, flatMap) or from other languages that Reactive Extensions had been ported to.</p>
<a id="more"></a>

<p>The process of learning RxSwift, however, hasn’t been painless. We’ve made many mistakes, fallen into many traps and eventually arrived at the other end to share what we’ve learned along the way. This is what this series is about: showing you the most common pitfalls to avoid when going reactive. They all come from the everyday practical use of RxSwift in non-trivial applications. It took us many hours to learn our lessons and we hope that with our help it’s going to take you only few minutes to enjoy the benefits of reactive programming without ever encountering its dark side.</p>
<p>So, let’s start!</p>
<h3 id="Not-disposing-a-subscription"><a href="#Not-disposing-a-subscription" class="headerlink" title="Not disposing a subscription"></a>Not disposing a subscription</h3><p>When you started using RxSwift for the first time, you’ve probably tried to observe some events by writing:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">observable</span><br><span class="line">    .subscribe(onNext: &#123; ... &#125;)</span><br></pre></td></tr></table></figure>

<p>Such an expression was, however, openly criticized by Xcode with the default <code>Result to call to &#39;subscribe&#39; is unused</code> warning. Luckily, there’s an easy fix available just around the corner. Telling the compiler that we ignore the call result with <code>_ =</code> would be enough, right? So now it’s:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">_</span> = observable</span><br><span class="line">        .subscribe(onNext: &#123; ... &#125;)</span><br></pre></td></tr></table></figure>

<p>and everything is fixed, isn’t it? If you think so, prepare yourself for a treat. There’re probably a whole lot of low-hanging fruits of undisposed subscriptions just waiting to be picked from your memory-management tree. Ignoring the subscription’s result is a clear path to memory leaks. While there are situations in which you’ll be spared any problems, in the worst-case scenario both your <code>observable</code> and the observer closure will never be released. The bad news is that by ignoring the value returned from <code>subscribe</code> method you’re giving away the control over which scenario is going to happen.</p>
<p>To understand the problem, I’ll show you the mental model of the subscription process in terms of memory-management first. Then, I’ll derive the best practices. Finally, I’m going to peek into RxSwift source code to understand what is actually happening in the current (v3.X/4.0) implementation and how it relates to the mental model presented earlier.</p>
<h3 id="The-mental-model-for-subscription-memory-management"><a href="#The-mental-model-for-subscription-memory-management" class="headerlink" title="The mental model for subscription memory-management"></a>The mental model for subscription memory-management</h3><p><em>Calling <code>subscribe</code> creates a reference cycle that retains both the <code>observable</code> and the <code>observer</code></em>. Neither of them is going to be released unless the cycle is broken, and it’s broken only in two situations:</p>
<ul>
<li>when the observable sequence completes, either with <code>.completed</code> or <code>.error</code> event,</li>
<li>when someone explicitly calls <code>.dispose()</code> on the <em>reference cycle manager</em> returned by <code>subscribe</code> method.</li>
</ul>
<p>![](/my_pictures/8 Mistakes to Avoid while Using RxSwift-1.jpeg)</p>
<p>The details may vary, but the basic idea of what it means to <em>subscribe</em> holds regardless of your particular observable, observer or subscription. The crucial thing to spot is that ignoring the <em>reference cycle manager</em>, aka <code>disposable</code>, strips you of the possibility to break reference cycle yourself. It is your gateway drug into the memory arrangement, and once it’s not available, there is no going back. If you use the <code>_ =</code> syntax, you basically state that the only way for the <code>observable</code> and <code>observer</code> to be released is by completing the observable sequence.</p>
<p>This might sometimes be exactly what you want! For example, if you’re calling <code>Observable.just</code>, it doesn’t really matter that you won’t ensure breaking the cycle. The single element is being emitted instantaneously, followed by <code>.completed</code> event. There are, however, many situations in which you might not be entirely sure of the completion possibilities for observable in question:</p>
<ul>
<li>you’re given the <code>Observable</code> from another object and the documentation doesn’t state whether it completes,</li>
<li>you’re given the <code>Observable</code> from another object and the documentation does state it completes, but there have been some changes in the internal implementation of that object along the way and no one remembered to update documentation,</li>
<li>the <code>Observable</code> is explicitly not completing (examples include <code>Variable</code>, <code>Observable.interval</code>, subjects),</li>
<li>there is an error in observable implementation, such as forgetting to send <code>.completed</code> event in <code>Observable.create</code> closure.<br>Since you’re rarely in control of all the observables in your app, and even then there’s a possibility for a mistake, the rule of thumb is to ensure yourself that the reference cycle will be broken. Either keep the reference to <code>disposable</code> and call the <code>.dispose()</code> method when the time comes, or use a handy helper like <code>DisposeBag</code> that’s gonna do it for you. You might also provide a separate cycle-breaking observable with <code>.takeUntil</code> operator. What way to choose depends on your particular situation, but always remember that:</li>
</ul>
<blockquote>
<p>Subscription creates a reference cycle between the observable and the observer. It might be broken implicitly, when observable completes, or explicitly, via <code>.dispose()</code>call. If you’re not 100% sure when or whether observable will complete, break the subscription reference cycle yourself!   </p>
</blockquote>
<p>Now that we’ve cleared things up, I feel like I owe you a little bit of explanation. The mental model I’ve drawn above is, well, a mental model, and therefore not strictly correct. What’s happening in the current RxSwift implementation (version 3.x/4.x at the time of writing) is a little bit more complicated. To understand the actual behavior, let us have a deeper dive into the RxSwift internals.</p>
<h3 id="The-implementation-of-the-subscribe-method"><a href="#The-implementation-of-the-subscribe-method" class="headerlink" title="The implementation of the subscribe method"></a>The implementation of the <code>subscribe</code> method</h3><p>Where is the <code>subscribe</code> method implemented? First place to search would be, unsurprisingly, the <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/ObservableType.swift">ObservableType.swift</a> file. It contains declaration of <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/ObservableType.swift#L39">subscribe</a> method as a part of the <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/ObservableType.swift#L10">ObservableType</a> protocol:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ObservableType.swift</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;O: ObserverType&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">_</span> observer: O</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> == <span class="type">E</span></span><br></pre></td></tr></table></figure>

<p>What implements this protocol? Basically, all the various types of observables. Let’s concentrate on the major implementation called <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observable.swift">Observable</a>, since it’s a base class for all but one of the observables defined in RxSwift. Its version of <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observable.swift#L22">subscribe</a> method is short and simple:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Observable.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;O: ObserverType&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">_</span> observer: O</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> == <span class="type">E</span> &#123;</span><br><span class="line">    rxAbstractMethod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Oh, the abstract method. We need to look into the <code>Observable</code> subclasses then. A quick search reveals that there are 14 different overridden <code>subscribe</code> methods within the RxSwift source code at the time of writing. We can put each of them in one of three buckets:</p>
<ul>
<li>implementations in subjects, which provide their own subscription logic due to the extraordinary place they occupy in the RxSwift lore,</li>
<li>implementations in connectable observables, which must deal with subscriptions in a special way due to their ability of multicasting,</li>
<li>implementation in <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift">Producer</a>, a subclass of <code>Observable</code> which provides the subscription logic for most of the operators you’ve grown to love and use.</li>
</ul>
<p>![](/my_pictures/8 Mistakes to Avoid while Using RxSwift-2.jpeg)</p>
<p>Let’s concentrate on <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift">Producer</a> type, since it represents the variant of observable that is simplest to reason about: the emitter of the sequence of events, from the single source to single recipient. It’s definitely the most common use case. Almost all the operators are derived from <code>Producer</code> base class. While a few of them provide a dedicated subscription logic that’s optimized further to their particular needs (see <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Just.swift">Just</a>, <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Empty.swift">Empty</a> or <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Error.swift">Error</a> for basic examples), the vast majority use the following implementation of <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L14">subscribe</a> from <code>Producer</code> (some scheduler-related logic was stripped for better readability):</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Producer.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;O : ObserverType&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">_</span> observer: O</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> == <span class="type">Element</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">    <span class="keyword">let</span> sinkAndSubscription = run(observer, cancel: disposer)</span><br><span class="line">    disposer.setSinkAndSubscription(</span><br><span class="line">        sink: sinkAndSubscription.sink,</span><br><span class="line">        subscription: sinkAndSubscription.subscription</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> disposer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So, what’s happening here? First, the observable creates a <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L39">SinkDisposer</a> object. Then it uses the <code>SinkDisposer</code> instance to create two additional objects: <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L18">sink and subscription</a>. They both have the same type: <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Disposable.swift">Disposable</a>, which is a protocol exposing a single <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Disposable.swift#L12">dispose</a> method. These two objects are being passed back to <code>SinkDisposer</code> via a setter method, which suggests, correctly, that their references will be kept. After all that setup is done, the <code>SinkDisposer</code> is being returned. So, when we’re calling <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L76">.dispose()</a> on the object returned from the <code>subscribe</code> method to break the subscription, we’re actually calling it on <code>SinkDisposer</code> instance.</p>
<p>So far, so good. One mystery down, still a few to go. Let’s dive into two crucial steps performed here: <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L17">let sinkAndSubscription = run(observer, cancel: disposer)</a> and <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L18">disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</a> methods. They are, as you’ll see, the essential parts of creating the reference cycle that keeps the subscription alive.</p>
<h3 id="Sinking-in-the-sea-of-Observables"><a href="#Sinking-in-the-sea-of-Observables" class="headerlink" title="Sinking in the sea of Observables"></a>Sinking in the sea of Observables</h3><p>The <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L34">run</a> method is provided by the <code>Producer</code>, but only in an abstract variant:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Producer.swift</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span>&lt;O : ObserverType&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">_</span> observer: O, cancel: Cancelable</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>)</span><br><span class="line"><span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> == <span class="type">Element</span> &#123;</span><br><span class="line">    rxAbstractMethod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The actual logic is specific to the particular <code>Producer</code> subclass. Before we check them, it’s crucial to understand the pattern that is very common across the RxSwift operators implementation: <em>sink</em>. This is the way that RxSwift deals with the complexity of observable streams and how it separates the creation of the observable from the logic that is being run the moment you <code>subscribe</code> to it.</p>
<p>The idea is simple: when you use the particular operator (say you <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Map.swift#L20">map</a> the existing observable), it returns an instance of a particular observable type dedicated to the task at hand. So calling <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Just.swift#L18">Observable.just(1)</a> gives you back the instance of <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Just.swift#L75">Just</a> class, which is a subclass of the <code>Producer</code> optimized for returning just one element and then completing. When you call <code>Observable&lt;Int&gt;.just(1).map &#123; $0 == 42 &#125;</code>, you’re being given back the instance of <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Map.swift#L142">Map</a> class, which is a subclass of the <code>Producer</code> optimized for applying the closure to each element in the <code>.next</code> event. However, at the very moment you create an observable, there’s nothing being actually sent to anyone yet, because no one has subscribed. The actual work of passing the events starts during the <code>subscribe</code> method, more precisely: in the <code>run</code> method that we’re so interested in.</p>
<p>That’s where the sink pattern shines. Each observable type has its own dedicated <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Sink.swift">Sink</a> subclass. For the <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Timer.swift#L19">interval</a> operator, represented by the <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Timer.swift#L88">Timer</a> observable, there is the <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Timer.swift#L49">TimerSink</a>. For the <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Merge.swift#L19">flatMap</a> operator, represented by the <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Merge.swift#L546">FlatMap</a> observable, there is the <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Merge.swift#L355">FlatMapSink</a>. For the <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Catch.swift#L32">catchErrorJustReturn</a> operator, represented by the <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Catch.swift#L151">Catch</a> observable, there is the <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Catch.swift#L108">CatchSink</a>. I think you get the idea!</p>
<p>But what is this <code>Sink</code> object, exactly? It is the place that stores the actual operator logic. So, for the <code>interval</code>, the <code>TimerSink</code> is the place that schedules sending events after each period and keeps track of the internal state (i.e. how many events were already sent). For the <code>flatMap</code>, the <code>FlatMapSink</code> (and its superclass, <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Merge.swift#L438">MergeSink</a> ) is the place that subscribes to the observables returned from flatmapping closure, keeps track of them and passes their events further. You may basically think of a <code>Sink</code> as a wrapper for the observer. It listens for the events from observable, applies the operator-related logic and then passes those transformed events further down the stream.</p>
<p>This is how RxSwift isolates the creation of observables from the execution of subscription logic for <code>Producer</code> -based observables. The former is encapsulated in the <code>Observable</code> subclass, the latter is provided by the <code>Sink</code> subclass. The separation of responsibilities greatly simplifies the actual objects’ implementations and makes it possible to write multiple variants of <code>Sink</code> optimized for different scenarios.</p>
<h3 id="Sink-full-of-knowledge"><a href="#Sink-full-of-knowledge" class="headerlink" title="Sink full of knowledge"></a><code>Sink</code> full of knowledge</h3><p>Now that we know what the <em>sink</em> pattern is, let’s go back to the <code>run</code> method. Each of these <code>Producer</code> subclasses provides its own <code>run</code> implementation. While details may vary, it usually can be abstracted into three steps:</p>
<ul>
<li>create a <code>sink</code> object as an instance of a class that derives from <code>Sink</code> type,</li>
<li>create a subscription instance, usually by running <code>sink.run</code> method,</li>
<li>return both instances wrapped in a tuple.<br>To clarify things further, please look at the <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Merge.swift#L558">FlatMap.run</a> example:</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Merge.swift, FlatMap observable class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span>&lt;O: ObserverType&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">_</span> observer: O, cancel: Cancelable</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>)</span><br><span class="line"><span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> == <span class="type">SourceSequence</span>.<span class="type">E</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sink = <span class="type">FlatMapSink</span>(</span><br><span class="line">      selector: _selector,</span><br><span class="line">      observer: observer,</span><br><span class="line">      cancel: cancel</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">let</span> subscription = sink.run(_source)</span><br><span class="line">  <span class="keyword">return</span> (sink: sink, subscription: subscription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The most important thing from the memory-management perspective is that in the moment of subscription the <code>sink</code> is given everything that’s needed to do the job:</p>
<ul>
<li>the events source (aka <em>Observable</em> ),</li>
<li>the event recipient (called <code>observer</code> ),</li>
<li>the operator-related data (for example, the flatmapping closure),</li>
<li>and the <code>SinkDisposer</code> instance (under the name <code>cancel</code> ).<br><code>sink</code> is free to store as many of these references as it sees fit for providing the required behavior of the operator. At the minimum, it’s gonna store the <code>observer</code> and, what’s gonna be crucial later, the <code>SinkDisposer</code>. Possibly more! Looking at the memory graph, <code>sink</code> quickly becomes the Northern Star in the constellation of objects related to the subscription.</li>
</ul>
<p>There is, however, one more object returned from observable’s <code>run</code> method. It’s <code>subscription</code>. This is the object that takes care of the logic that should be run when the subscription is being disposed of. Remember <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Create.swift#L20">create</a> operator? It takes a closure that returns <code>Disposable</code>, an object responsible for performing the cleanup. This is the same <code>Disposable</code> that’s returned from <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Create.swift#L25">AnonymousObservableSink</a>‘s <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Create.swift#L59">run</a> method as <code>subscription</code>. For each operator there might be some tasks to cancel, some resources to free, some internal subscription to dispose of. They’re all enclosed in the <code>subscription</code> object, and the ability to perform the cleanup is exposed via <code>subscription.dispose</code> method.</p>
<h3 id="The-Producer‘s-reference-cycle-Sink-and-SinkDisposer"><a href="#The-Producer‘s-reference-cycle-Sink-and-SinkDisposer" class="headerlink" title="The Producer‘s reference cycle: Sink and SinkDisposer"></a>The <code>Producer</code>‘s reference cycle: Sink and SinkDisposer</h3><p>Knowing that, let’s get back to the last component of the <code>subscribe</code> method implementation. Before the <code>SinkDisposer</code> is returned, the <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L59">setSinkAndSubscription</a> method is called. It does exactly what you might expect: the <code>sink</code> and <code>subscription</code> objects are passed via setter and kept in the <code>SinkDisposer</code> properties. They are referenced strongly, but wrapped into Optionals, which makes it possible set the references to <code>nil</code> later.</p>
<p>Have you already spotted the reference cycle from our mental model? It’s hidden in the plain sight! <code>sink</code> <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Sink.swift#L11">stores the reference</a> to <code>SinkDisposer</code>, and <code>SinkDisposer</code> <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L52">stores the reference</a> to <code>sink</code>. That’s why the subscription doesn’t release itself on the scope exit. Two objects keep each other alive, in an eternal hug of memory-lockup, until the end of the app. And since <code>sink</code> keeps <code>SinkDisposer</code> as non-Optional property, the one and only way of breaking the cycle is by asking the <code>SinkDisposer</code> to set the <code>sink</code> Optional reference to <code>nil</code>. And guess what? This is exactly what’s happening in the <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L76">SinkDisposer.dispose</a> method. It calls <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L91">dispose</a> on <code>sink</code>, then it calls <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L92">dispose</a> on subscription and then it <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L94">nils out references</a> to break the retain cycle. So for the <code>Producer</code> -based observables, the <code>SinkDisposer</code> is the <em>reference cycle manager</em> from the mental model that we’ve introduced earlier.</p>
<p>After all those details, you might wonder how come the reference cycle breaks itself when observable completes? Well, we’ve just stated that it requires <code>SinkDisposer.dispose()</code> method, so the answer is simple. The central point of subscription process, <code>sink</code> object, keeps the reference to <code>SinkDisposer</code> and also receives all the events from the observable. So once it gets either <code>.completed</code> or <code>.error</code> event and once its own logic determines that this is the sequence completion, it simply calls <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Sink.swift#L48">dispose</a> method on its <code>SinkDisposer</code> reference. This way the cycle is being broken from the inside.</p>
<p>To summarize the process, here comes the diagram of the actual reference cycle in the usual <code>Producer</code> -based observable subscription:</p>
<p>![](/my_pictures/8 Mistakes to Avoid while Using RxSwift-3.jpeg)</p>
<h3 id="The-road-goes-ever-on-and-on"><a href="#The-road-goes-ever-on-and-on" class="headerlink" title="The road goes ever on and on"></a>The road goes ever on and on</h3><p>Aren’t you curious what happens in non- <code>Producer</code> -based cases, such as subjects or connectable observables? The concept is very similar. There is always a reference cycle that’s controlled by some kind of <em>reference cycle manager</em> and there is always a way of breaking this cycle by <code>dispose</code> method invocation. I encourage you to dive into RxSwift source code and see for yourself!</p>
<p>Now it is clear where the mental model comes from. The details of particular subscription vary, and each observable type has specific optimizations applied for better performance and cleaner architecture. However, the basic idea prevails: there’s a reference cycle and the only way of breaking this cycle is either by completing the observable or through <em>reference cycle manager</em>.</p>
<p>Relying on the completion of the observable, while useful in many real-life situations, should always be a road taken with much care and deliberation. If you’re not sure of how to handle the subscription’s memory management, or you simply want your code to be more resilient to the future changes, it’s always best to default to supplying a mechanism of breaking the reference cycle explicitly.</p>
<p>That’s all for this time. More ways to shoot yourself in the foot with RxSwift are coming. Next time we’re going to look at memory management from a different perspective, focusing not on the subscription process, but on what’s being passed to operators. Until then, don’t forget to <a href="https://twitter.com/polidea">follow Polidea on Twitter</a> for more mobile development related posts!</p>
<p><a href="https://www.polidea.com/blog/8-Mistakes-to-Avoid-while-Using-RxSwiftPart-1/">8 Mistakes to Avoid while Using RxSwift. Part 1 - Polidea</a></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>RxSwift专题</tag>
      </tags>
  </entry>
  <entry>
    <title>Escaping Closures - Swift</title>
    <url>/2018/03/19/2018-03-19-Escaping%20Closures%20-%20Swift/</url>
    <content><![CDATA[<h3 id="逃逸闭包和非逃逸闭包"><a href="#逃逸闭包和非逃逸闭包" class="headerlink" title="逃逸闭包和非逃逸闭包"></a>逃逸闭包和非逃逸闭包</h3><hr>
<p><strong>逃逸闭包（escaping closure）</strong>，什么是逃逸闭包？苹果官方给的定义是：当一个闭包作为一个参数传递给函数，但是它是在函数返回之后调用的，这时候，这个闭包就称为<strong>逃逸闭包</strong>。当你声明一个将闭包作为参数的函数时，你可以在参数的类型之前用 <code>@escaping</code> 来表明这个闭包是允许逃逸的。</p>
<p>闭包可以逃逸的一种方式是存储在函数之外定义的变量中。作为例子，许多启动异步操作的函数都将闭包参数放在异步执行完毕之后的操作中执行（completion handler）。该函数在开始操作后返回，但在操作完成之前不会调用闭包 — 闭包需要逃逸，稍后调用，举个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] = []</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithEscapingClosure</span><span class="params">(completionHandler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><code>someFunctionWithEscapingClosure(_ :)</code> 函数将闭包作为其参数，并将其添加到在函数外声明的数组中。如果你没有用 <code>@escaping</code>  来标记这个函数的参数，你会得到一个编译时的错误。</p>
<p>将一个闭包用 <code>@escaping</code> 来标记的话，意味着你需要在闭包中明确的引用自身 <code>self</code> ，例如，在下面的代码中，传递给 <code>someFunctionWithEscapingClosure(_:)</code> 的闭包是逃逸闭包，这就意味着它必须要明确的引用自身 <code>self</code> ， 相比之下，传递给 <code>someFunctionWithNonescapingClosure(_:)</code> 的闭包是非逃逸闭包，这意味着它可以隐式的引用自身。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithNonescapingClosure</span><span class="params">(closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x = <span class="number">100</span> &#125;</span><br><span class="line">        someFunctionWithNonescapingClosure &#123; x = <span class="number">200</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="type">SomeClass</span>()</span><br><span class="line">instance.doSomething()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// Prints &quot;200&quot;</span></span><br><span class="line"></span><br><span class="line">completionHandlers.first?()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// Prints &quot;100&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="非逃逸闭包示意图"><a href="#非逃逸闭包示意图" class="headerlink" title="非逃逸闭包示意图"></a>非逃逸闭包示意图</h3><hr>
<p>![非逃逸闭包示意图](/my_pictures/Escaping Closures - Swift-1.png)</p>
<h3 id="逃逸闭包示意图"><a href="#逃逸闭包示意图" class="headerlink" title="逃逸闭包示意图"></a>逃逸闭包示意图</h3><hr>
<p>![逃逸闭包示意图](/my_pictures/Escaping Closures - Swift-2.png)</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Swift专题</tag>
      </tags>
  </entry>
  <entry>
    <title>优化 Swift 中 Notification.Name 的使用方式</title>
    <url>/2018/03/19/2018-03-19-%E4%BC%98%E5%8C%96%20Swift%20%E4%B8%AD%20Notification.Name%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在 <code>Swift</code> 中使用通知，在写通知名称的时候，并不能像 <code>Objective-C</code> 那样简单方便，一个字符串搞定。刚开始使用 <code>Swift</code> 通知时，感觉各种不爽，需要这样写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Notification</span>.<span class="type">Name</span>(<span class="string">&quot;myNotification&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>光取个名字就需要这么长一串代码，真的有悖于 <code>Swift</code> 给我的那种简洁的印象。下面我们就来优化一下。</p>
<h3 id="方法一：简单粗暴的-Notification-Name-扩展"><a href="#方法一：简单粗暴的-Notification-Name-扩展" class="headerlink" title="方法一：简单粗暴的 Notification.Name 扩展"></a>方法一：简单粗暴的 Notification.Name 扩展</h3><hr>
<p>最简单的方式就是对 <code>Notification.Name</code> 进行扩展，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Notification</span>.<span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> myNotification = <span class="type">Notification</span>.<span class="type">Name</span>(<span class="string">&quot;myNotification&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>使用的时候就能用点进行调用了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: .myNotification, object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>一瞬间简单了不少。不过还不够，我希望自定义的通知名称与系统的分开，并且如果一个编程不规范的人可能还会犯 <code>namespace</code> 错误。<a href="https://juejin.im/post/5980a916f265da3e2e56e8ce">Swift中Notification.Name这么难用怎么办</a> 这篇文章给了我灵感。</p>
<h3 id="方法二：使用-Enum-定义自己的通知名称"><a href="#方法二：使用-Enum-定义自己的通知名称" class="headerlink" title="方法二：使用 Enum 定义自己的通知名称"></a>方法二：使用 Enum 定义自己的通知名称</h3><hr>
<p>首先我们要新建一个枚举类型 <code>NotificationNames</code> ，为了避免 <code>namespace</code> 的问题，声明一个计算属性，添加一个前缀，就好像以前 <code>Objective-C</code> 的前缀 <code>NS</code> 一样。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NotificationNames</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> myNotification</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> nameValue: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NN&quot;</span> + rawValue</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> notiName: <span class="type">Notification</span>.<span class="type">Name</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Notification</span>.<span class="type">Name</span>(nameValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再添加一个自定义的 <code>post</code> 函数，方便调用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">post</span><span class="params">(<span class="keyword">_</span> name: NotificationNames, object myObject: AnyObject? = <span class="literal">nil</span>)</span></span> &#123;</span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: name.notiName, object: myObject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用起来就简单了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(.myNotification, object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>当在 <code>NotificationNames</code>  类型参数输入点的时候，就会很快的列出我们自定义的名称了。</p>
<p>类似的，<code>RxSwift</code> 版本的扩展如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">NotificationCenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">notification</span><span class="params">(<span class="keyword">_</span> myName: NotificationNames, object: AnyObject? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Notification</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> notification(myName.notiName, object: object)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span></span><br><span class="line">        .rx.notification(.myNotification, object: <span class="literal">nil</span>)</span><br><span class="line">        .subscribe(onNext: &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// code</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .addDisposableTo(bag)</span><br></pre></td></tr></table></figure>

<p>参考： <a href="https://juejin.im/post/5980a916f265da3e2e56e8ce">Swift中Notification.Name这么难用怎么办</a></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Swift专题</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub 博客报错解决</title>
    <url>/2018/03/28/2018-03-28-GitHub%20%E5%8D%9A%E5%AE%A2%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>今天提交文章到 GitHub 博客中，却总是出现</p>
<p>The file <code>vendor/cache/ruby/2.5.0/gems/jekyll-3.6.2/lib/site_template/_posts/0000-00-00-welcome-to-jekyll.markdown.erb</code> does not have a valid date in the YAML front matter. 的错误</p>
<p>错误具体信息如下：</p>
<blockquote>
<p>The page build failed for the <code>master</code> branch with the following error:  </p>
<p>The file <code>vendor/cache/ruby/2.5.0/gems/jekyll-3.6.2/lib/site_template/_posts/0000-00-00-welcome-to-jekyll.markdown.erb</code> does not have a valid date in the YAML front matter. For more information, see </p>
<p>  <a href="https://help.github.com/articles/page-build-failed-invalid-post-date/">https://help.github.com/articles/page-build-failed-invalid-post-date/</a>.  </p>
<p>For information on troubleshooting Jekyll see:  </p>
<p>  <a href="https://help.github.com/articles/troubleshooting-jekyll-builds">https://help.github.com/articles/troubleshooting-jekyll-builds</a>  </p>
<p>If you have any questions you can contact us by replying to this email.  </p>
</blockquote>
<p>在 <code>jekyll</code> 的 Issues 中，找到了解决方式</p>
<a id="more"></a>

<p>将 <code>exclude: [vendor]</code> 添加到 <code>_config.yml</code> 文件中即可。</p>
<p>原因如下：</p>
<blockquote>
<p>Jekyll has a copy of itself in the vendor directory there. It includes our tests. We have that post in our tests to ensure we fail on invalid dates.  </p>
</blockquote>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>博客日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【六】编码和解码</title>
    <url>/2018/03/28/2018-03-28-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E5%85%AD%E3%80%91%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<p>将程序内部的数据结构序列化为一些可交换的数据格式，以及反过来将通用的数据格式反序列化为内部使用的数据结构，这在编程中是一项非常常见的任务。Swift 将这些操作称为编码（encoding）和解码（decoing）。Swift 4 的一个主要特性就是定义了一套标准的编码和解码数据的方法，所有的自定义类型都能选择使用这套方法。</p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><hr>
<p>Codable 系统（以其基本“协议”命名，而这个协议其实是一个类型别名）的设计主要围绕三个核心目标；</p>
<ul>
<li><strong>普遍性</strong> — 它对结构体，枚举和类都适用。</li>
<li><strong>类型安全</strong> — 像是 JSON 这样的可交换格式通常都是弱类型，而你的代码应该要使用强类型数据。</li>
<li><strong>减少模板代码</strong> — 在让自定义类型加入这套系统时，应该让开发者尽可能少地写重复的“适配代码”。编译器应该为你自动生成这些代码。</li>
</ul>
<a id="more"></a>

<p>某个类型通过声明自己遵守 Encodable 和/或 Decodable 协议来表明自己具备被序列化和/或反序列化的能力。这两个协议各自只有一个必须实现的方法 - Encodable 定义了 <code>encode(to:)</code> 用来对值自身进行编码，Decodable 指定了一个初始化方法，来从序列化的数据中创建实例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 某个类型可以将自身编码为一种外部表示。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Encodable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 将值编码到给定的 encoder 中。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 某个类型可以从外部表示中解码得到自身。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Decodable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 通过从给定的 decoder 中解码来创建新的实例。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为大多数实现了其中一个协议的类型，也会实现另一个，所以标准库中还提供了 Codable 类型别名，来作为这两个协议组合后的简写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Codable</span> = <span class="type">Decodable</span> &amp; <span class="type">Encodable</span> </span><br></pre></td></tr></table></figure>

<p>标准库中包括 <code>Bool</code>，数值类型和 <code>String</code> 等所有基本类型，都直接是 Codable 类型。那些含有 Codable 元素的可选值，数组，字典和集合，也都满足 Codable。最后，包括 <code>Data</code>，<code>Date</code>，<code>URL</code>，<code>CGPoint</code> 和 <code>CGRect</code> 在内的许多 Apple 框架中的常用数据类型，也已经适配了 Codable。</p>
<h3 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h3><hr>
<p>因为 JSON 是最常见的格式，所以我们来集中研究一下 <code>JSONEncoder</code> 和 <code>JSONDecoder</code> 。</p>
<p>我们先来建两个结构体，一个是封装了坐标的结构体，一个是封装了地点的结构体。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 坐标</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Coordinate</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> latitude: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> longitude: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 地点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Placemark</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> coordinate: <span class="type">Coordinate</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们可以将一个 <code>Placemark</code> 数组编码为 JSON 格式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> places = [</span><br><span class="line">    <span class="type">Placemark</span>(name: <span class="string">&quot;Berlin&quot;</span>, coordinate:</span><br><span class="line">        <span class="type">Coordinate</span>(latitude: <span class="number">52</span>, longitude: <span class="number">13</span>)),</span><br><span class="line">    <span class="type">Placemark</span>(name: <span class="string">&quot;Cape Town&quot;</span>, coordinate:</span><br><span class="line">        <span class="type">Coordinate</span>(latitude: -<span class="number">34</span>, longitude: <span class="number">18</span>))</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> encoder = <span class="type">JSONEncoder</span>()</span><br><span class="line">    <span class="keyword">let</span> jsonData = <span class="keyword">try</span> encoder.encode(places) <span class="comment">// 129 bytes</span></span><br><span class="line">    <span class="keyword">let</span> jsonString = <span class="type">String</span>(decoding: jsonData, <span class="keyword">as</span>: <span class="type">UTF8</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     [&#123;&quot;name&quot;:&quot;Berlin&quot;,&quot;coordinate&quot;:&#123;&quot;longitude&quot;:13,&quot;latitude&quot;:52&#125;&#125;,</span></span><br><span class="line"><span class="comment">     &#123;&quot;name&quot;:&quot;Cape Town&quot;,&quot;coordinate&quot;:&#123;&quot;longitude&quot;:18,&quot;latitude&quot;:-34&#125;&#125;]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Decoding"><a href="#Decoding" class="headerlink" title="Decoding"></a>Decoding</h3><hr>
<p>这一次我们来看一个复杂一点的，但是在实际应用中，能够经常见到的 JSON 格式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">let jsonStr = </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        &quot;success&quot;: true,</span></span><br><span class="line"><span class="string">        &quot;message&quot;: &quot;got the locations!&quot;,</span></span><br><span class="line"><span class="string">        &quot;data&quot;: &#123;</span></span><br><span class="line"><span class="string">            &quot;LocationList&quot;: [</span></span><br><span class="line"><span class="string">                &#123;</span></span><br><span class="line"><span class="string">                    &quot;LocID&quot;: 1,</span></span><br><span class="line"><span class="string">                    &quot;LocName&quot;: &quot;Downtown&quot;</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                &#123;</span></span><br><span class="line"><span class="string">                    &quot;LocID&quot;: 2,</span></span><br><span class="line"><span class="string">                    &quot;LocName&quot;: &quot;Uptown&quot;</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                &#123;</span></span><br><span class="line"><span class="string">                    &quot;LocID&quot;: 3,</span></span><br><span class="line"><span class="string">                    &quot;LocName&quot;: &quot;Midtown&quot;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            ]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里有三层结构，第一层是最外面的一层，第二层是 <code>data</code> 的这一层，第三层是 <code>LocationList</code> 对应的这一层，这一层是一个数组。</p>
<p>下面我们来建立三个结构体，分别对应着三层结构：</p>
<h4 id="第一层-Location"><a href="#第一层-Location" class="headerlink" title="第一层 Location"></a>第一层 Location</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Location</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">	  <span class="keyword">var</span> success: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">var</span> message: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">LocationData</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二层-LocationData"><a href="#第二层-LocationData" class="headerlink" title="第二层 LocationData"></a>第二层 LocationData</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LocationData</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="type">LocationList</span>: [<span class="type">LocationItem</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三层-LocationItem"><a href="#第三层-LocationItem" class="headerlink" title="第三层 LocationItem"></a>第三层 LocationItem</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LocationItem</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="type">LocID</span>: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> <span class="type">LocName</span>: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JSON-解码"><a href="#JSON-解码" class="headerlink" title="JSON 解码"></a>JSON 解码</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonDecode = <span class="type">JSONDecoder</span>()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> jsonData = jsonStr.data(using: .utf8) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> decoded = <span class="keyword">try</span> jsonDecode.decode(<span class="type">Location</span>.<span class="keyword">self</span>, from: jsonData)</span><br><span class="line">        <span class="built_in">print</span>(decoded.data.<span class="type">LocationList</span>.first?.<span class="type">LocName</span> ?? <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</span><br><span class="line">        <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一种更容易看出-JSON-包含情况的结构体声明"><a href="#一种更容易看出-JSON-包含情况的结构体声明" class="headerlink" title="一种更容易看出 JSON 包含情况的结构体声明"></a>一种更容易看出 JSON 包含情况的结构体声明</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Location</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LocationData</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">LocationItem</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> <span class="type">LocID</span>: <span class="type">Int</span></span><br><span class="line">            <span class="keyword">var</span> <span class="type">LocName</span>: <span class="type">String</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> <span class="type">LocationList</span>: [<span class="type">LocationItem</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> success: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">var</span> message: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">LocationData</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










































]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【七】字符串</title>
    <url>/2018/04/01/2018-04-01-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E4%B8%83%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h3><hr>
<p>大部分编程语言使用整数值对字符串进行下标操作，比如 <code>str[5]</code> 将会返回 <code>str</code> 中的第六个“字符” (这里的“字符”的概念由所操作的编程语言进行定义)。Swift 不允许这么做。为什么？答案可能现在你已经很耳熟了：因为整数的下标访问无法在常数时间内完成 (对于 <code>Collection</code> 协议来说这也是个直观要求)，而且查找第 n 个 <code>Character</code> 的操作也必须要对它之前的所有字节进行检查。</p>
<p><code>String.Index</code> 是 <code>String</code> 和它的视图所使用的索引类型，它本质上是一个存储了从字符串开头的字节偏移量的不透明值。如果你想计算第 n 个字符所对应的索引，你依然从字符串的开头或结尾开始，并花费 O(n) 的时间。但是一旦你拥有了有效的索引，就可以通过索引下标以 O(1) 的时间对字符串进行访问了。至关重要的是，通过一个已有索引来寻找下一个索引也是很快的，因为你可以从这个已有索引的字节偏移量开始进行查找，而不需要从头开始。正是由于这个原因，按顺序 (前向或者后向) 对字符串中的字符进行迭代是一个高效操作。</p>
<a id="more"></a>

<p>对字符串索引的操作的 API 与你在遇到其他任何集合时使用的索引操作是一样的。我们之所以经常容易忽略索引操作的等效性，是因为到现在为止我们最经常使用的数组的索引是整数类型，于是我们往往通过简单的算数，而非正式的索引操作 API，来对数组索引进行操作。<code>index(after:)</code> 方法将返回下一个字符的索引：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"><span class="keyword">let</span> second = s.index(after: s.startIndex)</span><br><span class="line">s[second] <span class="comment">// b</span></span><br></pre></td></tr></table></figure>

<p>如果需要一次性地自动对多个字符进行迭代：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步进 4 个字符</span></span><br><span class="line"><span class="keyword">let</span> sixth = s.index(second, offsetBy: <span class="number">4</span>)</span><br><span class="line">s[sixth] <span class="comment">// f</span></span><br></pre></td></tr></table></figure>

<p>如果存在超过字符串末尾的风险，你可以加上 <code>limitedBy:</code> 参数。如果这个方法在达到目标索引之前就先触发了限制条件的话，它将返回 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> safeIdx = s.index(s.startIndex, offsetBy: <span class="number">400</span>, limitedBy: s.endIndex)</span><br><span class="line">safeIdx <span class="comment">// nil</span></span><br></pre></td></tr></table></figure>

<p>毫无疑问，这比简单的整数索引需要更多的代码，但是再一次，Swift 就是这样设计的。如果 Swift 允许使用整数下标索引来访问字符串，会大大增加意外地写出性能相当糟糕的代码的可能性（比如，在一个循环中使用了整数下标）。</p>
<h3 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h3><hr>
<p>和所有集合类型一样，<code>String</code> 有一个特定的 <code>SubSequence</code> 类型，它就是 <code>Substring</code> 。<code>Substring</code> 和 <code>ArraySlice</code> 很相似：它是一个以不同起始和结束索引的对原字符串的切片。子字符串和原字符串共享文本存储，这带来的巨大的好处，它让对字符串切片成为了非常高效的操作。在下面的例子中，创建 <code>firstWord</code> 并不会导致昂贵的复制操作或者内存申请：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence = <span class="string">&quot;The quick brown fox jumped over the lazy dog.&quot;</span></span><br><span class="line"><span class="keyword">let</span> firstSpace = sentence.index(of: <span class="string">&quot; &quot;</span>) ?? sentence.endIndex</span><br><span class="line"><span class="keyword">let</span> firstWord = sentence[..&lt;firstSpace] <span class="comment">// The</span></span><br><span class="line">type(of: firstWord) <span class="comment">// Substring</span></span><br></pre></td></tr></table></figure>

<p>在你对一个（可能会很长的）字符串进行迭代并提取它的各个部分的循环中，切片的高效特性就非常重要了。这类任务可能包括在文本中寻找某个单词出现的所有位置，或者解析一个 CSV 文件等。在这里，字符串分割是一个很有用的操作。<code>Colleciton</code> 定义了一个 <code>split</code> 方法，它会返回一个子序列的数组（也就是 <code>[Substring]</code> ）。最常用的一种形式是：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(separator: Element, maxSplits: Int = Int.<span class="built_in">max</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      omittingEmptySubsequences: Bool = <span class="literal">true</span>)</span></span> -&gt; [<span class="type">SubSequence</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以这样来使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> poem = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Over the wintry</span></span><br><span class="line"><span class="string">forest, winds howl in rage</span></span><br><span class="line"><span class="string">with no leaves to blow.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> lines = poem.<span class="built_in">split</span>(separator: <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment">// [&quot;Over the wintry&quot;, &quot;forest, winds howl in rage&quot;, &quot;with no leaves to blow.&quot;]</span></span><br><span class="line">type(of: lines) <span class="comment">// Array&lt;Substring&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="StringProtocol"><a href="#StringProtocol" class="headerlink" title="StringProtocol"></a>StringProtocol</h3><hr>
<p><code>Substring</code> 和 <code>String</code> 的接口几乎完全一样。这是通过一个叫做 <code>StringProtocol</code> 的通用协议来达到的，<code>String</code> 和 <code>Substring</code> 都遵守这个协议。因为几乎所有的字符串 API 都被定义在 <code>StringProtocol</code> 上，对于 <code>Substring</code>，你完全可以假装将它看作就是一个 <code>String</code>，并完成各项操作。不过，在某些时候，你还是需要将子字符串转回 <code>String</code> 实例；和所有的切片一样，子字符串也只能用于短期的存储，这可以避免在操作过程中发生昂贵的复制。当这个操作结束，你想将结果保存起来，或是传递给下一个子系统，这时你应该通过初始化方法从 <code>Substring</code> 创建一个新的 <code>String</code>，如下例所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastWord</span><span class="params">(<span class="keyword">in</span> input: String)</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">    <span class="comment">// 处理输入，操作子字符串</span></span><br><span class="line">    <span class="keyword">let</span> words = input.<span class="built_in">split</span>(separators: [<span class="string">&quot;,&quot;</span>, <span class="string">&quot; &quot;</span>])</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> lastWord = words.last <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="comment">// 转换为字符串并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(lastWord)</span><br><span class="line">&#125;</span><br><span class="line">lastWord(<span class="keyword">in</span>: <span class="string">&quot;one, two, three, four, five&quot;</span>) <span class="comment">// Optional(&quot;five&quot;)</span></span><br></pre></td></tr></table></figure>

<p><strong>不鼓励长期存储子字符串的根本原因在于，子字符串会一直持有整个原始字符串。如果有一个巨大的字符串，它的一个只表示单个字符的子字符串将会在内存中持有整个字符串。即使当原字符串的生命周期本应该结束时，只要子字符串还存在，这部分内存就无法释放。长期存储子字符串实际上会造成内存泄漏，由于原字符串还必须被持有在内存中，但是它们却不能再被访问。</strong></p>
<p>如果你想要扩展 <code>String</code> 为其添加新的功能，将这个扩展放在 <code>StringProtocol</code> 会是一个好主意，这可以保持 <code>String</code> 和 <code>Substring API</code> 的统一性。<code>StringProtocol</code> 设计之初就是为了在你想要对 String 扩展时来使用的。如果你想要将已有的扩展从 <code>String</code> 移动到 <code>StringProtocol</code> 的话，唯一需要做的改动是将传入其他 API 的 <code>self</code> 通过 <code>String(self)</code> 换为具体的 <code>String</code> 类型实例。</p>
<p>不过需要记住，在 Swift 4 中，<code>StringProtocol</code> 还并不是一个你想要构建自己的字符串类型时所应该实现的目标协议。文档中明确警告了这一点：</p>
<blockquote>
<p>不要声明任意新的遵守 <code>StringProtocol</code> 协议的类型。只有标准库中的 <code>String</code> 和 <code>Substring</code> 类型是有效的适配类型。  </p>
</blockquote>
<p>最终的目标是允许开发者创建他们自己的字符串类型 (比如带有特定的存储或者性能优化)，但是协议的设计还没有结束，所以现在就遵守这个协议的话，可能会让你的代码在 Swift 5 中无法通过编译。</p>
<h3 id="CustomStringConvertible"><a href="#CustomStringConvertible" class="headerlink" title="CustomStringConvertible"></a>CustomStringConvertible</h3><hr>
<p>符合 <code>CustomStringConvertible</code> 协议的类型可以在将实例转换为字符串时提供自己的表示形式。<code>String(describing:)</code> 初始值设定项是将任何类型的实例转换为字符串的首选方法。如果传递的实例符合<code>CustomStringConvertible</code> ，则 <code>String(describing:</code> 初始值设定项和 <code>print(_:)</code> 函数将使用实例的自定义描述属性。</p>
<p>不鼓励直接访问类型的 <code>description</code> 属性或使用 <code>CustomStringConvertible </code> 作为通用约束。</p>
<h4 id="遵守-CustomStringConvertible-协议"><a href="#遵守-CustomStringConvertible-协议" class="headerlink" title="遵守 CustomStringConvertible 协议"></a>遵守 <code>CustomStringConvertible</code> 协议</h4><p>通过定义 <code>description</code> 属性将 <code>CustomStringConvertible</code> 协议添加到自定义类型中。</p>
<p>例如，这个自定义的 <code>Point</code> 结构体使用标准库提供的默认表示形式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span>, y: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="type">Point</span>(x: <span class="number">21</span>, y: <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="comment">// Prints &quot;Point(x: 21, y: 30)&quot;</span></span><br></pre></td></tr></table></figure>

<p>在实现 <code>description</code> 属性并遵守 <code>CustomStringConvertible</code> 协议之后，<code>Point</code> 类型提供了它自己的自定义表示。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Point</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(\(x), \(y))&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="comment">// Prints &quot;(21, 30)&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="CustomDebugStringConvertible"><a href="#CustomDebugStringConvertible" class="headerlink" title="CustomDebugStringConvertible"></a>CustomDebugStringConvertible</h3><hr>
<p>Swift 为任意类型（any type）提供了默认的调试文本表示。 <code>String(reflecting:)</code> 的初始化和 <code>debugPrint(_:)</code> 函数使用该默认表示形式。要自定义该表示，请使您的类型符合 <code>CustomDebugStringConvertible </code> 协议。</p>
<p>由于 <code>String(reflecting:)</code> 的初始化适用于任何类型的实例，如果传递的值符合 <code>CustomDebugStringConvertible</code> ，则返回实例的 <code>debugDescription</code> ，不鼓励直接访问类型的 <code>debugDescription</code> 属性，或者使用 <code>CustomDebugStringConvertible</code> 作为通用约束。</p>
<blockquote>
<p>Note  </p>
<p>调用 <code>dump(_:_:_:_:)</code> 函数并在调试器中打印时使用 <code>String(reflecting:)</code> 和 <code>Mirror(reflecting:)</code> 来收集有关实例的信息，如果你为你自定义的类型实现了 <code>CustomDebugStringConvertible</code> 协议，则可能需要考虑通过实现 <code>CustomReflectable</code> 协议来提供自定义镜像。  </p>
</blockquote>
<h4 id="遵守-CustomDebugStringConvertible-协议"><a href="#遵守-CustomDebugStringConvertible-协议" class="headerlink" title="遵守 CustomDebugStringConvertible  协议"></a>遵守 <code>CustomDebugStringConvertible </code> 协议</h4><p>通过定义 <code>debugDescription </code> 属性将 <code>CustomDebugStringConvertible </code> 协议添加到自定义类型中。</p>
<p>例如，这个自定义的 <code>Point</code> 结构体使用标准库提供的默认表示形式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span>, y: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="type">Point</span>(x: <span class="number">21</span>, y: <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="type">String</span>(reflecting: p))</span><br><span class="line"><span class="comment">// Prints &quot;p: Point = &#123;</span></span><br><span class="line"><span class="comment">//           x = 21</span></span><br><span class="line"><span class="comment">//           y = 30</span></span><br><span class="line"><span class="comment">//         &#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>在实现 <code>debugDescription </code> 属性并遵守 <code>CustomDebugStringConvertible </code> 协议之后，<code>Point</code> 类型提供了它自己的自定义表示。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Point</span>: <span class="title">CustomDebugStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> debugDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Point(x: \(x), y: \(y))&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">String</span>(reflecting: p))</span><br><span class="line"><span class="comment">// Prints &quot;Point(x: 21, y: 30)&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 操作符</title>
    <url>/2018/04/02/2018-04-02-Swift%20%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<blockquote>
<p>Swift 支持重载操作符的特性，让我们可以自定义一些简单的计算。<br>最经典的例子就是两个二维向量之间的计算了。  </p>
</blockquote>
<p>首先我们定义一个二维向量，并创建两个向量</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> v1 = <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">let</span> v2 = <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">4.0</span>)</span><br></pre></td></tr></table></figure>

<p>相加两个向量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> v3 = <span class="type">Vector2D</span>(x: v1.x + v2.x, y: v1.y + v2.y)</span><br></pre></td></tr></table></figure>

<p>这样一次的话，感觉还好。但是遇到复杂的运算的话，这样写感觉就太啰嗦了，这时候重载操作符是最好的选择。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> +<span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Vector2D</span>(x: <span class="keyword">left</span>.x + <span class="keyword">right</span>.x, y: <span class="keyword">left</span>.y + <span class="keyword">right</span>.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>这样，我们相加两个向量就简单的多了</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> v3 = v1 + v2</span><br><span class="line"><span class="built_in">print</span>(v3) <span class="comment">// 输出 Vector2D(x: 3.0, y: 7.0)</span></span><br></pre></td></tr></table></figure>

<p>向量的内积运算符API中是没有定义的，所以我们自定义一个内积运算符。<br>这里是Swift 3的实现方式（感觉看起来比之前的版本可读性好多了）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义操作符 别名类型</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> +*: <span class="type">InnerProductPrecedence</span></span><br><span class="line"><span class="comment">// 自定义操作符的运算优先级</span></span><br><span class="line">precedencegroup <span class="type">InnerProductPrecedence</span> &#123;</span><br><span class="line"><span class="comment">//    结合律：内积的结果是一个 Double，不再会和其他内积结合使用，所以这里写成 none</span></span><br><span class="line">    <span class="keyword">associativity</span>: <span class="keyword">none</span></span><br><span class="line"><span class="comment">//    优先级设置：高于普通运算。</span></span><br><span class="line"><span class="comment">//    MultiplicationPrecedence（代表乘法和除法）</span></span><br><span class="line"><span class="comment">//    AdditionPrecedence（代表加法和减法）</span></span><br><span class="line">    higherThan: <span class="type">MultiplicationPrecedence</span>, <span class="type">AdditionPrecedence</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们就可以写具体的运算实现了</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> +*<span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">left</span>.x * <span class="keyword">right</span>.x + <span class="keyword">left</span>.y * <span class="keyword">right</span>.y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = v1 +* v2 <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="precedencegroup"><a href="#precedencegroup" class="headerlink" title="precedencegroup"></a>precedencegroup</h3><blockquote>
<p>定义了一个操作符优先级别。操作符优先级的定义和类型声明有些相似，一个操作符比需要属于某个特定的优先级。Swift 标准库中已经定义了一些常用的运算优先级组，比如加法优先级 (AdditionPrecedence) 和乘法优先级 (MultiplicationPrecedence) 等，你可以在<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0077-operator-precedence.md">这里</a>找到完整的列表。如果没有适合你的运算符的优先级组，你就需要像我们在例子中做得这样，自己指定结合律方式和优先级顺序了。  </p>
</blockquote>
<h3 id="infix"><a href="#infix" class="headerlink" title="infix"></a>infix</h3><blockquote>
<p>表示要定义的是一个中位操作符，即前后都是输入；其他的修饰还包括 prefix 和 postfix，不再赘述  </p>
</blockquote>
<h3 id="associativity"><a href="#associativity" class="headerlink" title="associativity"></a>associativity</h3><blockquote>
<p>定义了结合律，即如果多个同类的操作符顺序出现的计算顺序。比如常见的加法和减法都是 left，就是说多个加法同时出现时按照从左往右的顺序计算 (因为加法满足交换律，所以这个顺序无所谓，但是减法的话计算顺序就很重要了)。点乘的结果是一个 Double，不再会和其他点乘结合使用，所以这里写成 none  </p>
</blockquote>
<h3 id="higherThan"><a href="#higherThan" class="headerlink" title="higherThan"></a>higherThan</h3><blockquote>
<p>运算的优先级，点积运算是优先于乘法运算的。除了 higherThan，也支持使用 lowerThan 来指定优先级低于某个其他组。  </p>
</blockquote>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>iOS工作日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift ABI Stability Manifesto</title>
    <url>/2018/03/29/2018-03-29-Swift%20ABI%20Stability%20Manifesto/</url>
    <content><![CDATA[<ul>
<li>Authors: <a href="https://github.com/milseman">Michael Ilseman</a> (compiled through conversations with many others)</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><hr>
<h3 id="The-Big-Picture"><a href="#The-Big-Picture" class="headerlink" title="The Big Picture"></a>The Big Picture</h3><p>One of the top priorities for Swift right now is compatibility across future Swift versions. Compatibility aims at accomplishing two goals:</p>
<ol>
<li><strong>Source compatibility</strong> means that newer compilers can compile code written in an older version of Swift. This aims to reduce the migration pain that Swift developers face when migrating to a newer Swift version. Without source compatibility, projects face version-lock where all source code in a project and its packages must be written in the same version of Swift. With source compatibility, package authors will be able to maintain a single code base across multiple Swift versions while allowing their users to use a newer version of Swift.</li>
</ol>
<a id="more"></a>

<ol start="2">
<li><p><strong>Binary framework &amp; runtime compatibility</strong> enables the distribution of frameworks in a binary form that works across multiple Swift versions. Binary frameworks include both a <em>Swift module file</em>, which communicates source-level information of the framework’s API, and a <em>shared library</em>, which provides the compiled implementation that is loaded at runtime. Thus, there are two necessary goals for binary framework compatibility:</p>
<ul>
<li><p><strong>Module format stability</strong> stabilizes the module file, which is the compiler’s representation of the public interfaces of a framework. This includes API declarations and inlineable code. The module file is used by the compiler for necessary tasks such as type checking and code generation when compiling client code using a framework.</p>
</li>
<li><p><strong>ABI stability</strong> enables binary compatibility between applications and libraries compiled with different Swift versions. It is the focus of the rest of this document.</p>
</li>
</ul>
</li>
</ol>
<p>This document is an exploration and explanation of Swift’s ABI alongside the goals and investigations needed before declaring Swift’s ABI stable. It is meant to be a resource to the community as well as a declaration of the direction of Swift’s ABI.</p>
<p>Throughout this document there will be references to issues in Swift’s <a href="https://bugs.swift.org/">issue tracking system</a> denoted by “SR-xxxx”. These references track open engineering and design tasks for Swift’s ABI.</p>
<h3 id="What-Is-ABI"><a href="#What-Is-ABI" class="headerlink" title="What Is ABI?"></a>What Is ABI?</h3><p>At runtime, Swift program binaries interact with other libraries and components through an ABI. ABI is Application Binary Interface, or the specification to which independently compiled binary entities must conform to be linked together and executed. These binary entities must agree on many low level details: how to call functions, how their data is represented in memory, and even where their metadata is and how to access it.</p>
<p>ABI is per-platform, as it is a low level concern influenced by both the architecture and the OS. Most platform vendors define a “standard ABI” which is used for C code and built on by C-family languages. Swift, however, is a very different language from C and has its own per-platform ABI. While most of this document is platform-agnostic, platform-specific concerns have influenced details of the design and implementation of Swift’s ABI. For details on each platform’s standard ABI, refer to the <a href="#platform-abis">Appendix</a>.</p>
<h3 id="What-Is-ABI-Stability"><a href="#What-Is-ABI-Stability" class="headerlink" title="What Is ABI Stability?"></a>What Is ABI Stability?</h3><p>ABI stability means locking down the ABI to the point that future compiler versions can produce binaries conforming to the stable ABI. Once an ABI is stable, it tends to persist for the rest of the platform’s lifetime due to ever-increasing mutual dependencies.</p>
<p>ABI stability only affects invariants of externally visible public interfaces and symbols. Internal symbols, conventions, and layout can continue to change without breaking the ABI. For example, future compilers are free to change the calling conventions for internal function calls so long as the public interfaces are preserved.</p>
<p>Decisions about the ABI will have long-term ramifications and may limit the ways in which the language can grow and evolve in the future. Future Swift versions can add new, orthogonal aspects to the ABI, but any inefficiencies or inflexibilities present when stability is declared will (effectively) persist forever for that platform.</p>
<p>ABI changes that are new and orthogonal are called <em>ABI-additive</em> changes. ABI-additive changes may be taken advantage of when the minimum targeted Swift version supports them. This allows us to extend or progressively lock down more of the ABI. These may be ABI additions to support new features or that allow for more efficient data access. Examples appear throughout this document.</p>
<h3 id="What-Does-ABI-Stability-Enable"><a href="#What-Does-ABI-Stability-Enable" class="headerlink" title="What Does ABI Stability Enable?"></a>What Does ABI Stability Enable?</h3><p>ABI stability enables OS vendors to embed a Swift standard library and runtime that is compatible with applications built with older or newer versions of Swift. This would remove the need for apps to distribute their own copy of these libraries on those platforms. It also allows for better decoupling of tools and better integration into the OS.</p>
<p>As noted earlier, ABI stability is necessary, though not sufficient, for binary frameworks. Module format stability is also required and is beyond the scope of this document.</p>
<h3 id="Library-Evolution"><a href="#Library-Evolution" class="headerlink" title="Library Evolution"></a>Library Evolution</h3><p>Expressive and performance-focused languages which have binary interfaces tend to exhibit the <a href="https://en.wikipedia.org/wiki/Fragile_binary_interface_problem">fragile binary interface problem</a>, which makes it difficult for any library or component to change over time without requiring every user to recompile with new versions of that library. A major push in Swift currently is the plan for <a href="https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst">Library Evolution</a>, which aims to grant flexibility for library authors to maintain backwards and forwards binary compatibility. Many implementation concerns therein could have an impact on ABI.</p>
<p>One of the goals of rolling out ABI stability is to remain flexible enough to accommodate library evolution changes without limiting the design space. Library evolution concerns will be addressed in each individual section, though a common refrain will be that the details are still undecided.</p>
<h2 id="Components-of-the-Swift-ABI"><a href="#Components-of-the-Swift-ABI" class="headerlink" title="Components of the Swift ABI"></a>Components of the Swift ABI</h2><hr>
<p>In practice, ABI concerns can be tightly coupled. But, as a conceptual model, I’d like to break them out into 6 separate classifications:</p>
<ol>
<li><p>Types, such as structs and classes, must have a defined in-memory layout for instances of that type. For binary entities to interoperate, they must share the same layout conventions. This layout is discussed in the <a href="#data-layout">Data Layout</a> section.</p>
</li>
<li><p>Type metadata is used extensively by Swift programs, the Swift runtime, reflection, and tools such as debuggers and visualizers. This metadata must either have a defined memory layout, or have a set of defined APIs for querying the metadata of a type. Type metadata is discussed in the <a href="#metadata">Type Metadata</a> section.</p>
</li>
<li><p>Every exported or external symbol in a library needs a unique name upon which binary entities can agree. Swift provides function overloading and contextual name spaces (such as modules and types), which means that any name in source code might not be globally unique. A unique name is produced through a technique called <em>name mangling</em>. Swift’s name mangling scheme is discussed in the <a href="#mangling">Mangling</a> section.</p>
</li>
<li><p>Functions must know how to call each other, which entails such things as the layout of the call stack, what registers are preserved, and ownership conventions. Calling conventions are discussed in the <a href="#calling-convention">Calling Convention</a> section.</p>
</li>
<li><p>Swift ships with a runtime library which handles such things as dynamic casting, reference counting, reflection, etc. Compiled Swift programs make external calls out to this runtime. Thus, Swift runtime API is Swift ABI. Runtime API stability is discussed in the <a href="#runtime">Runtime</a> section.</p>
</li>
<li><p>Swift ships with a standard library that defines many common types, structures, and operations on these. For a shipped standard library to work with applications written in different versions of Swift, it must expose a stable API. Thus, Swift Standard Library API is Swift ABI, as well as the layout of many of the types it defines. Swift standard library ABI stability concerns are discussed in the <a href="#standard-library">Standard Library</a> section.</p>
</li>
</ol>
<h2 id="Data-Layout"><a href="#Data-Layout" class="headerlink" title="Data Layout"></a>Data Layout</h2><hr>
<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>First, let’s define some common terminology.</p>
<ul>
<li>An <em>object</em> is a stored entity of some type, meaning it has a location in memory or in registers. Objects can be values of struct/enum type, class instances, references to class instances, values of protocol type, or even closures. This is <a href="https://en.wikipedia.org/wiki/Object_%28computer_science%29">in contrast to</a> the class-based-OO definition of object as being an instance of a class.</li>
<li>A <em>data member</em> of an object is any value that requires layout within the object itself. Data members include an object’s stored properties and associated values.</li>
<li>A <em>spare bit</em> is a bit that is unused by objects of a given type. These often arise due to things such as alignment, padding, and address spaces, further described below.</li>
<li>An <em>extra inhabitant</em> is a bit pattern that does not represent a valid value for objects of a given type. For example, a simple C-like enum with 3 cases can fit in 2 bits, where it will have one extra inhabitant: the fourth unused bit pattern.</li>
<li>Data layout*, also known as type layout, specifies the in-memory layout of an object’s data. This includes the size of an object in memory, the alignment of an object (defined later), and how to find each data member within an object.</li>
</ul>
<p>An object has a statically known layout if the compiler is able to determine its layout at compilation time. Objects whose layout is not determinable until runtime have <em>opaque layout</em>. Such objects are further discussed in the <a href="#opaque-layout">opaque layout section</a></p>
<h4 id="Layout-and-Properties-of-Types"><a href="#Layout-and-Properties-of-Types" class="headerlink" title="Layout and Properties of Types"></a>Layout and Properties of Types</h4><p>For every type <code>T</code> in Swift with statically known layout, the ABI specifies a means to determine:</p>
<ul>
<li>The <em>alignment</em> for that type: for <code>x : T</code>, the address of <code>x</code> modulo alignment is always zero.</li>
<li>The <em>size</em> for that type: the byte size (possibly 0) without padding at the end.</li>
<li>The <em>offset</em> for each data member (if applicable): the address at which every member resides, relative to the object’s base address.</li>
</ul>
<p>Derived from alignment and size is the <em>stride</em> of the type, which is the size of objects of that type rounded up to alignment (minimum 1). The stride is mostly useful for objects laid out contiguously in memory, such as in arrays.</p>
<p> Some types have interesting properties:</p>
<ul>
<li>A type is <em>trivial</em>, also known as POD (“plain ol’ data”), if it merely stores data and has no extra copy, move, or destruction semantics. Trivial objects can be copied by replicating their bits, and are destroyed through deallocation. A type is trivial only if all data members are also trivial.</li>
<li>A type is <em>bitwise movable</em> if there are no side table references dependent on its address. A <a href="https://doc.rust-lang.org/book/ownership.html#move-semantics">move</a> operation can occur when an object is copied from one location into another and the original location is no longer used. Bitwise movable objects are moved by performing a bitwise copy and then invalidating the original location. A type is bitwise movable only if all its data members are also bitwise movable. All trivial types are bitwise movable.</li>
</ul>
<p>An example of a trivial type is a Point struct that contains two Double fields: an x coordinate and a y coordinate. This struct is trivial, as it can be copied merely by copying its bits and its destruction performs no extra operations.</p>
<p>An example of a bitwise movable, but non-trivial, type is a struct that contains a reference to a class instance. Objects of that type cannot be copied merely by copying their bits, because a retain operation must be performed on the reference. Upon destruction, such objects must perform a release. However, the object can be moved from one address to another by copying its bits provided the original location is invalidated, keeping the overall retain count unchanged.</p>
<p>An example of a type that is neither trivial nor bitwise movable is a struct containing a weak reference. Weak references are tracked in a side table so that they can be nil-ed out when the referenced object is destroyed. When moving an object of such type from one address to another, the side table must be updated to refer to the weak reference’s new address.</p>
<h4 id="Opaque-Layout"><a href="#Opaque-Layout" class="headerlink" title="Opaque Layout"></a>Opaque Layout</h4><p>Opaque layout occurs whenever the layout is not known until runtime. This can come up for unspecialized generics, which do not have a known layout at compilation time. It can also come up for resilient types, which are described in the <a href="#layout-library-evolution">next section</a>.</p>
<p>The size and alignment of an object of opaque layout, as well as whether it is trivial or bitwise movable, is determined by querying its value witness table, which is described further in the <a href="#value-witness-table">value witness table section</a>. The offsets for data members are determined by querying the type’s metadata, which is described further in the <a href="#value-metadata">value metadata section</a>. Objects of opaque layout must typically be passed indirectly, described further in the <a href="#function-signature-lowering">function signature lowering section</a>. The Swift runtime interacts with objects of opaque layout through pointers, and thus they must be addressable, described further in the <a href="#abstraction-levels">abstraction levels section</a>.</p>
<p>In practice, layout might be partially-known at compilation time. An example is a generic struct over type <code>T</code> that stores an integer as well as an object of type <code>T</code>. In this case, the layout of the integer itself is known and its location within the generic struct might be as well, depending on the specifics of the layout algorithm. However, the generic stored property has opaque layout, and thus the struct overall has an unknown size and alignment. We are investigating how to most efficiently lay out partially-opaque aggregates [ <a href="https://bugs.swift.org/browse/SR-3722">SR-3722</a> ]. This will likely entail placing the opaque members at the end in order to guarantee known offsets of non-opaque data members.</p>
<h4 id="Library-Evolution-1"><a href="#Library-Evolution-1" class="headerlink" title="Library Evolution"></a>Library Evolution</h4><p>Library evolution introduces <em>resilient</em> layouts of public types by default and provides new annotations that freeze the layout for performance. A resilient layout avoids many of the pitfalls of the fragile binary problem by making the layout opaque. Resilient types have far more freedom to change and evolve without breaking binary compatibility: public data members can be rearranged, added, and even removed (by providing a computed getter/setter instead). The new annotations provide the ability to relinquish these freedoms by making stricter guarantees about their layout in order to be more efficiently compiled and accessed.</p>
<p>In order to allow for cross-module optimizations for modules that are distributed together, there is the concept of a <em>resilience domain</em>. A resilience domain is a grouping of modules which are version-locked with each other and thus do not have binary compatibility across multiple version requirements with each other. See <a href="https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#resilience-domains">Resilience Domains</a> for more details.</p>
<p>Resilient types are required to have opaque layout when exposed outside their resilience domain. Inside a resilience domain, this requirement is lifted and their layout may be statically known or opaque as determined by their type (see <a href="#opaque-layout">previous section</a> ).</p>
<p>Annotations may be applied to a library’s types in future versions of that library, in which case the annotations are versioned, yet the library remains binary compatible. How this will impact the ABI is still under investigation [ <a href="https://bugs.swift.org/browse/SR-3911">SR-3911</a> ].</p>
<h4 id="Abstraction-Levels"><a href="#Abstraction-Levels" class="headerlink" title="Abstraction Levels"></a>Abstraction Levels</h4><p>All types in Swift conceptually exist at multiple levels of abstraction. For example, an <code>Int</code> value is of a concrete type and can be passed to functions in registers. But, that same value might be passed to a function expecting a generic type <code>T</code>, which has opaque layout. Since the function is expecting its argument to be passed indirectly, the integer value must be promoted to the stack. When that value has type <code>T</code>, it is said to be at a higher abstraction level than when it was an integer. Moving between abstraction levels is done through a process called <em>reabstraction</em>.</p>
<p>For many types in Swift, reabstraction involves directly copying the value to memory so that it is addressable. Reabstraction may be more complicated for tuples and higher-order functions, explained later in the <a href="#tuples">tuples layout section</a> and the <a href="#lowering-higher-order-functions">function signature lowering section</a>.</p>
<h3 id="A-Tour-of-Types"><a href="#A-Tour-of-Types" class="headerlink" title="A Tour of Types"></a>A Tour of Types</h3><p>What follows is a breakdown of the different kinds of types in Swift and what needs to be specified.</p>
<h4 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h4><p>The layout algorithm for structs should result in an efficient use of space, possibly by laying out fields in a different order than declared [ <a href="https://bugs.swift.org/browse/SR-3723">SR-3723</a> ]. We may want a fully declaration-order-agnostic algorithm to allow data members to be reordered in source without breaking binary compatibility [ <a href="https://bugs.swift.org/browse/SR-3724">SR-3724</a> ]. We also need to consider whether, by default, we want to ensure struct data members are addressable (i.e. byte-aligned) or if we’d rather do bit-packing to save space [ <a href="https://bugs.swift.org/browse/SR-3725">SR-3725</a> ].</p>
<p>Zero sized structs do not take up any space as data members and struct members may be laid out in the padding of sub-structs. We may want to explore whether there are implementation benefits to capping alignment at some number, e.g. 16 on many platforms [ <a href="https://bugs.swift.org/browse/SR-3912">SR-3912</a> ].</p>
<h4 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h4><p>Tuples are similar to anonymous structs, but they differ in that they exhibit structural subtyping: a tuple of type e.g. <code>(Bool, Bool)</code> can be passed anywhere expecting generic types <code>(T, U)</code>. But, the type <code>(T, U)</code> exists at a higher abstraction level than <code>(Bool, Bool)</code>. Due to this, tuples may face more expensive reabstraction costs if their layout is aggressively packed. Reabstracting such a tuple would involve splitting and promoting each element into their own addresses.</p>
<p>This may be an argument for a simple, declaration-order, non bit-packed layout algorithm for tuples. Tuples are often used for small local values and rarely persisted across ABI boundaries in a way that aggressive packing is performance-critical. This would also be more consistent with how fixed-size C arrays are presented in Swift, which are imported as tuples.</p>
<p>We should investigate whether to aggressively bit-pack tuple elements similarly to structs, paying the reabstraction costs, or if the benefits are not worth the costs [ <a href="https://bugs.swift.org/browse/SR-3726">SR-3726</a> ].</p>
<p>Tuples should be binary compatible between labeled and unlabeled tuples of the same type and structure.</p>
<h4 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h4><p>A value of enum type exists as one of many variants or cases. Determining which is the job of the <em>discriminator</em>, also known as a tag, which is an integer value denoting which case is presently stored. To save space, discriminators can be put in spare bits or be represented by extra inhabitants.</p>
<p><code>@closed</code> enums, that is enums that can’t have cases added to them later, can be classified into the following:</p>
<ul>
<li>Degenerate - zero cased, or single cased without an associated value</li>
<li>Trivial - no associated values</li>
<li>Single payload - an enum where only one case has associated values</li>
<li>Multi-payload - an enum that has multiple cases with associated values</li>
</ul>
<p>Degenerate enums take zero space. Trivial enums are just their discriminator.</p>
<p>Single payload enums try to fit their discriminator in the payload’s extra inhabitants for the non-payload cases, otherwise they will store the discriminator after the payload. When the discriminator is stored after the payload, the bits are not set for the payload case. The payload is guaranteed to be layout compatible with the enum as the payload case does not use any extra inhabitants. Storing the discriminator after the payload may also result in more efficient layout of aggregates containing the enum, due to alignment.</p>
<p>The layout algorithm for multi-payload enums is more complicated and still needs to be developed [ <a href="https://bugs.swift.org/browse/SR-3727">SR-3727</a> ]. The algorithm should try to rearrange payloads so as to coalesce cases and save space. This rearrangement can also improve performance and code size. For example, if ARC-ed payload components reside in the same location, operations like copy can be done directly on the values without extensive switching.</p>
<p>Enum raw values are not ABI, as they are implemented as code present in the computed property getter and setter. <code>@objc</code> enums are C-compatible, which means they must be trivial.</p>
<p>Library evolution adds the notion of <code>@open</code> enums (which will also be resilient), which allow library owners to add new cases and reorder existing cases without breaking binary compatibility. How this is accomplished is still to be determined.</p>
<h4 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h4><p>There are two constructs present when discussing about class layout: <em>class instances</em>, which reside on the heap, and <em>references</em> to class instances, which are reference-counted pointers.</p>
<h4 id="Class-Instances"><a href="#Class-Instances" class="headerlink" title="Class Instances"></a>Class Instances</h4><p>The layout of class instances is mostly opaque. This is to avoid the vexing problem of <a href="https://en.wikipedia.org/wiki/Fragile_binary_interface_problem">fragile binary interfaces</a>, also known as the “fragile base class problem”, in which seemingly minor changes to a base class break binary compatibility with subclasses.</p>
<p>The run-time type of a non-final class instance or a class existential is not known statically. To facilitate dynamic casts, the object must store a pointer to its type, called the <em>isa</em> pointer. The <em>isa</em> pointer is always stored at offset 0 within the object. How that type is represented and what information it provides is part of the class’s metadata and is covered in the <a href="#class-metadata">class metadata section</a>. Similarly, the function for a non-final method call is also not known statically and is dispatched based on the run-time type. Method dispatch is covered in the <a href="#method-dispatch">method dispatch section</a>.</p>
<p>Class instances will, as part of ABI-stability, guarantee a word-sized field of opaque data following the isa field that may be used for reference counting by the runtime [ <a href="https://bugs.swift.org/browse/SR-4353">SR-4353</a> ]. But, the format and conventions of this opaque data will not be ABI at first in order to have more flexibility for language or implementation changes. Instead, runtime functions provide the means to interact with reference counts. This opaque data and its conventions may be locked down for more efficient access in the future, which will be an ABI-additive change.</p>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><p>Classes are reference types. This means that Swift code dealing with class instances does so through references, which are pointers at the binary level. These references participate in <a href="https://en.wikipedia.org/wiki/Automatic_Reference_Counting">automatic reference counting</a> (ARC).</p>
<p>References to Objective-C-compatible class instances (i.e. those that inherit from an Objective-C class or are imported from Objective-C) must provide the same bit-level guarantees to the Objective-C runtime as Objective-C references. Thus, such references are opaque: they have no guarantees other than that nil is 0 and provide no extra inhabitants.</p>
<p>References to native, non-Objective-C-compatible Swift class instances do not have this constraint. The alignment of native Swift class instances is part of ABI, providing spare bits in the lower bits of references. Platforms may also provide spare bits (typically upper bits) and extra inhabitants (typically lower addresses) for references due to limited address spaces.</p>
<p>We may want to explore using spare bits in references to store local reference counts in order to perform some ARC operations more efficiently [ <a href="https://bugs.swift.org/browse/SR-3728">SR-3728</a> ]. These would need to be flushed to the object whenever a reference may escape or the local reference count reaches zero. If these local reference counts can cross ABI boundaries, then such a change will have to be implemented in an ABI-additive way with deployment target checking.</p>
<h4 id="Existential-Containers"><a href="#Existential-Containers" class="headerlink" title="Existential Containers"></a>Existential Containers</h4><p>Any discussion of existentials quickly becomes bogged down in obscure terminology, so let’s first establish some background surrounding the terms <em>existential values</em>, <em>existential containers</em>, and <em>witness tables</em>.</p>
<p>In type theory, an <a href="https://en.wikipedia.org/wiki/Type_system#Existential_types">existential type</a> describes an interface of an abstract type. Values of an existential type are <em>existential values</em>. These arise in Swift when an object’s type is a protocol: storing or passing an object of protocol type means that the actual run-time type is opaque (not known at compile time, and thus neither is its layout). But, that opaque type has known interfaces because that type conforms to the protocol.</p>
<p>A type’s conformance to a protocol consists of functions (whether methods or getters and setters), but the specific addresses of those functions are not known at compilation time for existential values as their actual type is not known until run time. This is a similar situation as with references to non-final class instances, and is solved using a <a href="#method-dispatch">similar technique</a>. <em>Witness tables</em> are tables of function pointers implementing a protocol conformance and are further discussed in the <a href="#witness-tables">witness table section</a>.</p>
<p><em>Existential containers</em> store values of protocol or protocol composition type alongside corresponding witness tables for each protocol conformance. For existentials that are not class-constrained (may be value types or classes), the container needs to store:</p>
<ul>
<li>the value itself: either in an inline buffer or as a pointer to out-of-line storage</li>
<li>a pointer to the type metadata</li>
<li>a witness table pointer for every conformance.</li>
</ul>
<p>Class-constrained existentials omit the metadata pointer (as the object itself contains a pointer to its type), as well as any excess inline buffer space. <code>Any</code>, which is an existential value without any conformances, has no witness table pointer.</p>
<p>We are re-evaluating the inline buffer size for existential containers prior to ABI stability [ <a href="https://bugs.swift.org/browse/SR-3340">SR-3340</a> ]. We are also considering making the out-of-line allocation be copy-on-write (COW) [ <a href="https://bugs.swift.org/browse/SR-4330">SR-4330</a> ]. We should also explore “exploding” existential parameters, i.e. converting an existential parameter into a protocol-constrained generic parameter [ <a href="https://bugs.swift.org/browse/SR-4331">SR-4331</a> ].</p>
<h3 id="Declaring-Stability"><a href="#Declaring-Stability" class="headerlink" title="Declaring Stability"></a>Declaring Stability</h3><p>ABI stability means nailing down type layout and making decisions about how to handle the concerns of Library Evolution. The end result will be a technical specification of the layout algorithms that future compilers must adhere to in order to ensure binary compatibility [ <a href="https://bugs.swift.org/browse/SR-3730">SR-3730</a> ].</p>
<p>For all of the areas discussed above, more aggressive layout improvements may be invented in the post-ABI stability future. For example, we may want to explore rearranging and packing nested type data members with outer type data members. Such improvements would have to be done in an ABI-additive fashion through deployment target and/or min-version checking. This may mean that the module file will need to track per-type ABI versioning information.</p>
<p>A potentially out of date description of Swift’s current type layout can be found in the <a href="https://github.com/apple/swift/blob/master/docs/ABI.rst#type-layout">Type Layout docs</a>.</p>
<h2 id="Type-Metadata"><a href="#Type-Metadata" class="headerlink" title="Type Metadata"></a>Type Metadata</h2><hr>
<p>While data layout specifies the layout of objects of a given type, <em>type metadata</em> holds information about the types themselves. The information available and how to access this information is part of Swift ABI.</p>
<p>Swift keeps metadata records for every <em>concrete type</em>. Concrete types include all non-generic types as well as generic types with concrete type parameters. These records are created by the compiler as well as lazily created at run time (e.g. for generic type instantiations). This metadata stores information about its type, discussed in each section below.</p>
<p>A potential approach to stability mechanism is to provide metadata read/write functions alongside the runtime to interact with metadata, giving some freedom to the underlying structures to grow and change. This effectively makes large portions of metadata opaque. But, certain fields require access to be as efficient as possible (e.g. dynamic casts, calling into witness tables) and the performance hit from going through an intermediary function would be unacceptable. Thus, we will probably freeze the performance-critical parts and use accessor functions for the rest [ <a href="https://bugs.swift.org/browse/SR-3923">SR-3923</a> ].</p>
<p>Metadata has many historical artifacts in its representation that we want to clean up [ <a href="https://bugs.swift.org/browse/SR-3924">SR-3924</a> ]. We also want to make small tweaks to present more semantic information in the metadata, to enable better future tooling and features such as reflection [ <a href="https://bugs.swift.org/browse/SR-3925">SR-3925</a> ]. Some of these need to be done before declaring ABI stability and some may be additive.</p>
<h3 id="Declaring-Stability-1"><a href="#Declaring-Stability-1" class="headerlink" title="Declaring Stability"></a>Declaring Stability</h3><p>Stabilizing the ABI means producing a precise technical specification for the fixed part of the metadata layout of all language constructs so that future compilers and tools can continue to read and write them. A prose description is not necessarily needed, though explanations are useful. We will also want to carve out extra space for areas where it is likely to be needed for future functionality [ <a href="https://bugs.swift.org/browse/SR-3731">SR-3731</a> ].</p>
<p>For more, but potentially out of date, details see the <a href="https://github.com/apple/swift/blob/master/docs/ABI.rst#type-metadata">Type Metadata docs</a>.</p>
<h3 id="Generic-Parameters"><a href="#Generic-Parameters" class="headerlink" title="Generic Parameters"></a>Generic Parameters</h3><p>Swift has a powerful generics system, which shows up both at compilation time (through specialization optimizations) and at run time when the type is unknown. Swift types may be parameterized over generic types, and thus every type’s metadata describes whether generic type parameters are present and if so provides information about them.</p>
<p>At run time, objects only have concrete types. If the type in source code is generic, the concrete type is an instantiation of that generic type. Generic instantiation metadata provide type metadata for each generic type parameter. If the generic type is constrained, corresponding <a href="#witness-tables">witness tables</a> for each protocol conformance are also provided in the metadata.</p>
<h3 id="Value-Metadata"><a href="#Value-Metadata" class="headerlink" title="Value Metadata"></a>Value Metadata</h3><p>Named value types store the type name (currently mangled but we are investigating un-mangled [ <a href="https://bugs.swift.org/browse/SR-3926">SR-3926</a> ]) and a pointer to the type’s parent for nested types.</p>
<p>Value type metadata also has kind-specific entries. Struct metadata stores information about its fields, field offsets, field names, and field metadata. Enum metadata stores information about its cases, payload sizes, and payload metadata. Tuple metadata stores information about its elements and labels.</p>
<h4 id="Value-Witness-Tables"><a href="#Value-Witness-Tables" class="headerlink" title="Value Witness Tables"></a>Value Witness Tables</h4><p>Every concrete type has a <em>value witness table</em> that provides information about how to lay out and manipulate values of that type. When a value type has <a href="#opaque-layout">opaque layout</a>, the actual layout and properties of that value type are not known at compilation time, so the value witness table is consulted.</p>
<p>The value witness table stores whether a type is trivial and/or bitwise movable, whether there are extra inhabitants and if so how to store and retrieve them, etc. For enums, the value witness table will also provide functionality for interacting with the discriminator. There may be more efficient ways of representing enums that simplify this functionality (or provide a fast path), and that’s under investigation [ <a href="https://bugs.swift.org/browse/SR-4332">SR-4332</a> ].</p>
<p>These value witness tables may be constructed statically for known values or dynamically for some generic values. While every unique type in Swift has a unique metadata pointer, value witness tables can be shared by types so long as the information provided is identical (i.e. same layout). Value witness tables always represent a type at its highest <a href="#abstraction-levels">abstraction level</a>. The value witness table entries and structure need to be locked down for ABI stability [ <a href="https://bugs.swift.org/browse/SR-3927">SR-3927</a> ].</p>
<h3 id="Class-Metadata"><a href="#Class-Metadata" class="headerlink" title="Class Metadata"></a>Class Metadata</h3><p>Swift class metadata is layout-compatible with Objective-C class objects on Apple’s platforms, which places requirements on the contents of the first section of class metadata. In this first section, entries such as super class pointers, instance size, instance alignment, flags, and opaque data for the Objective-C runtime are stored.</p>
<p>Following that are superclass members, parent type metadata, generic parameter metadata, class members, and <em>vtables</em>, described below. Library evolution may present many changes to what exactly is present and will likely make many of the contents opaque to accommodate changes [ <a href="https://bugs.swift.org/browse/SR-4343">SR-4343</a> ].</p>
<h4 id="Method-Dispatch"><a href="#Method-Dispatch" class="headerlink" title="Method Dispatch"></a>Method Dispatch</h4><p>Invoking a non-final instance method involves calling a function that is not known at compile time: it must be resolved at run time. This is solved through the use of a <em>vtable</em>, or virtual method table (so called because overridable methods are also known as “virtual” methods). A <em>vtable</em> is a table of function pointers to a class or subclass’s implementation of overridable methods. If the vtable is determined to be part of ABI, it needs a layout algorithm that also provides flexibility for library evolution.</p>
<p>Alternatively, we may decide to perform inter-module calls through opaque <em>thunks</em>, or compiler-created intermediary functions, which then perform either direct or vtable dispatch as needed [ <a href="https://bugs.swift.org/browse/SR-3928">SR-3928</a> ]. This enables greater library evolution without breaking binary compatibility by allowing internal class hierarchies to change. This would also unify non-final method dispatch between open and non-open classes while still allowing for aggressive compiler optimizations like de-virtualization for non-open classes. This approach would make vtables not be ABI, as that part of the type metadata would effectively be opaque to another module.</p>
<h3 id="Protocol-and-Existential-Metadata"><a href="#Protocol-and-Existential-Metadata" class="headerlink" title="Protocol and Existential Metadata"></a>Protocol and Existential Metadata</h3><h4 id="Protocol-Witness-Tables"><a href="#Protocol-Witness-Tables" class="headerlink" title="Protocol Witness Tables"></a>Protocol Witness Tables</h4><p>The protocol witness table is a function table of a type’s conformance to the protocol’s interfaces. If the protocol also has an associated type requirement, then the witness table will store the metadata for the associated type. Protocol witness tables are used with <a href="#existential-containers">existential containers</a> where the run time type is not known.</p>
<p>Protocol witness tables may be created dynamically by the runtime or statically by the compiler. The layout of a protocol witness table is ABI and we need to determine a layout algorithm that also accommodates library evolution concerns, where additional protocol requirements may be added with default fall-backs [ <a href="https://bugs.swift.org/browse/SR-3732">SR-3732</a> ].</p>
<h4 id="Existential-Metadata"><a href="#Existential-Metadata" class="headerlink" title="Existential Metadata"></a>Existential Metadata</h4><p>Existential type metadata contains the number of witness tables present, whether the type is class-constrained, and a <em>protocol descriptor</em> for each protocol constraint. A protocol descriptor describes an individual protocol constraint, such as whether it is class-constrained, the size of conforming witness tables, and protocol descriptors for any protocols it refines. Protocol descriptors are layout compatible with the Objective-C runtime’s protocol records on Apple platforms. The format of the existential type metadata needs to be reviewed as part of the ABI definition [ <a href="https://bugs.swift.org/browse/SR-4341">SR-4341</a> ].</p>
<h3 id="Function-Metadata"><a href="#Function-Metadata" class="headerlink" title="Function Metadata"></a>Function Metadata</h3><p>In addition to common metadata entries, function type metadata stores information about the function signature: parameter and result type metadata, calling convention, per-parameter ownership conventions, and whether the function throws. Function type metadata always represents the function at its highest abstraction level, which is explained later in the <a href="#lowering-higher-order-functions">function signature lowering section</a>. Function parameters are currently modeled with a tuple-based design, but this should be updated to match modern Swift [ <a href="https://bugs.swift.org/browse/SR-4333">SR-4333</a> ]. As more ownership semantics are modeled, more information may be stored about each parameter.</p>
<h2 id="Mangling"><a href="#Mangling" class="headerlink" title="Mangling"></a>Mangling</h2><hr>
<p>Mangling is used to produce unique symbols. It applies to both external (public) symbols as well as internal or hidden symbols. Only the mangling scheme for external symbols is part of ABI.</p>
<p>ABI stability means a stable mangling scheme, fully specified so that future compilers and tools can honor it. For a potentially out-of-date specification of what the mangling currently looks like, see the <a href="https://github.com/apple/swift/blob/master/docs/ABI.rst#mangling">Name Mangling docs</a>.</p>
<p>There are some corner cases currently in the mangling scheme that should be fixed before declaring ABI stability. We need to come up with a canonicalization of generic and protocol requirements to allow for order-agnostic mangling [ <a href="https://bugs.swift.org/browse/SR-3733">SR-3733</a> ]. We also may decide to more carefully mangle variadicity of function parameters, etc [ <a href="https://bugs.swift.org/browse/SR-3734">SR-3734</a> ]. Most often, though, mangling improvements focus on reducing symbol size.</p>
<p>Mangling design centers around coming up with short and efficient manglings that still retain important properties such as uniqueness and integration with existing tools and formats. Given the prevalence of public symbols in libraries and frameworks, and debugging symbols in applications, the symbol names themselves can make up a significant portion of binary size. Reducing this impact is a major focus of stabilizing the mangling. Post-ABI-stability, any new manglings or techniques must be additive and must support the existing manglings.</p>
<p>There are many ways to improve the existing mangling without major impact on existing tools. Throughout these endeavors, we will be empirically measuring and tracking symbol size and its impact on binary size. ABI work on mangling focuses on producing <em>compact manglings</em> and using <em>suffix differentiation</em>.</p>
<h3 id="Compact-Manglings"><a href="#Compact-Manglings" class="headerlink" title="Compact Manglings"></a>Compact Manglings</h3><p>Minor tweaks to shorten the mangling can have a beneficial impact on all Swift program binary sizes. These tweaks should compact existing manglings while preserving a simple unique mapping. One example is not distinguishing between struct/enum in mangling structures, which would also provide more library evolution freedom [ <a href="https://bugs.swift.org/browse/SR-3930">SR-3930</a> ]. We are considering dropping some internal witness table symbols when they don’t provide any meaningful information conducive to debugging [ <a href="https://bugs.swift.org/browse/SR-3931">SR-3931</a> ]. We recently overhauled word substitutions in mangling, with the goal of reducing as much redundancy in names as possible [ <a href="https://bugs.swift.org/browse/SR-4344">SR-4344</a> ].</p>
<p>There are other aggressive directions to investigate as well, such as mangling based on a known overload set for non-resilient functions. This does have the downside of making manglings unstable when new overloads are added, so its benefits would have to be carefully weighed [ <a href="https://bugs.swift.org/browse/SR-3933">SR-3933</a> ].</p>
<p>Any more ambitious reimagining of how to store symbols such as aggressive whole-library symbol name compression would have to be done in tight coupling with existing low level tools. Unfortunately, this might make some of the more ambitious options infeasible in time for ABI stability. They could be rolled out as ABI-additive using deployment target checking in the future.</p>
<h3 id="Suffix-Differentiation"><a href="#Suffix-Differentiation" class="headerlink" title="Suffix Differentiation"></a>Suffix Differentiation</h3><p>There are many existing low level tools and formats that store and consume the symbol information, and some of them use efficient storage techniques such as tries. Suffix differentiation is about adjusting the mangling in ways that take advantage of them: by distinguishing manglings through suffixes, i.e. having common shared prefixes. This is currently underway and is resulting in binary size reductions for platforms that use these techniques [ <a href="https://bugs.swift.org/browse/SR-3932">SR-3932</a> ].</p>
<h2 id="Calling-Convention"><a href="#Calling-Convention" class="headerlink" title="Calling Convention"></a>Calling Convention</h2><hr>
<p>For the purposes of this document, “standard calling convention” refers to the C calling convention for a given platform (see <a href="#platform-abis">appendix</a> ), and “Swift calling convention” refers to the calling convention used by Swift code when calling other Swift code. One of the first steps toward ABI stability is for Swift to adopt the Swift calling convention [ <a href="https://bugs.swift.org/browse/SR-4346">SR-4346</a> ]. The Swift runtime uses the standard calling convention, though it may make alterations (see section <a href="#runtime-calling-convention">Runtime calling convention</a> ).</p>
<p>Calling convention stability pertains to public interfaces. The Swift compiler is free to choose any convention for internal (intra-module) functions and calls.</p>
<p>For rationale and potentially-out-of-date details, see the <a href="https://github.com/apple/swift/blob/master/docs/CallingConvention.rst">Swift Calling Convention Whitepaper</a>. As part of nailing down the calling conventions, that document will either be updated with the final specifications of the calling conventions or else moved to a rationale document and a more succinct and rigorous specification put in its place.</p>
<h3 id="Register-convention"><a href="#Register-convention" class="headerlink" title="Register convention"></a>Register convention</h3><p>This section will be using the terms <em>callee-saved</em> and <em>scratch</em> to classify registers as part of a register convention.</p>
<ul>
<li>A <em>callee-saved register</em> must be preserved over the duration of a function call. If a called function (the <em>callee</em> ) wishes to change the value stored in the register, it must restore it before returning.</li>
<li>A <em>scratch</em> register, also known as caller-saved or callee-clobbered, is not preserved over the duration of a function call. If the register’s value must be preserved, code surrounding a function call must save and restore the value.</li>
</ul>
<p>Swift uses roughly the same categorization of registers as the standard calling convention. But, for some platforms, the Swift calling convention adds additional situational uses of some callee-saved registers: the <em>call context</em> register and the <em>error</em> register.</p>
<h4 id="Call-Context-Register"><a href="#Call-Context-Register" class="headerlink" title="Call Context Register"></a>Call Context Register</h4><p>The value held in the <em>call context</em> register depends on the kind of function called:</p>
<ul>
<li>Instance methods on class types: pointer to self</li>
<li>Class methods: pointer to type metadata (which may be subclass metadata)</li>
<li>Mutating method on value types: pointer to the value (i.e. value is passed indirectly)</li>
<li>Non-mutating methods on value types: self may fit in one or more registers, else passed indirectly</li>
<li><em>Thick closures</em>, i.e. closures requiring a context: the closure context</li>
</ul>
<p>Having the call context register be callee-saved is advantageous. It keeps the register stable across calls, where the context is very likely to be used and reused in subsequent or nested calls. Additionally, this makes partial application free as well as converting thin closures to thick.</p>
<h4 id="Error-Register"><a href="#Error-Register" class="headerlink" title="Error Register"></a>Error Register</h4><p>Throwing functions communicate error values to their callers through the <em>error</em> register on some platforms. The error register holds a pointer to the error value if an error occurred, otherwise 0. The caller of a throwing function is expected to quickly check for 0 before continuing on with non-error code, otherwise branching to code to handle or propagate the error. Using a callee-saved register for the error register enables free conversion from non-throwing to throwing functions, which is required to honor the subtyping relationship.</p>
<h3 id="Function-Signature-Lowering"><a href="#Function-Signature-Lowering" class="headerlink" title="Function Signature Lowering"></a>Function Signature Lowering</h3><p>Function signature lowering is the mapping of a function’s source-language type, which includes formal parameters and results, all the way down to a physical convention, which dictates what values are stored in what registers and what values to pass on the stack.</p>
<p>ABI stability requires nailing down and fully specifying this algorithm so that future Swift versions can lower Swift types to the same physical call signature as prior Swift versions [ <a href="https://bugs.swift.org/browse/SR-4349">SR-4349</a> ]. More in-depth descriptions and rationale of function signature lowering can be found in the <a href="https://github.com/apple/swift/blob/master/docs/CallingConvention.rst#function-signature-lowering">function signature lowering docs</a>.</p>
<p>Lowering the result value is usually done first, with a certain number of registers designated to hold the result value if it fits, otherwise the result value is passed on the stack. A good heuristic is needed for the limit and is architecture specific (e.g. 4 registers on modern 64-bit architectures) [ <a href="https://bugs.swift.org/browse/SR-3946">SR-3946</a> ].</p>
<p>Next comes lowering parameters, which proceeds greedily by trying to fit values into registers from left-to-right, though some parameters may be re-ordered. For example, closures are best placed at the end to take advantage of ABI compatibility between thick closures and thin ones without a context.</p>
<p>Some values must be passed and returned indirectly as they are <em>address only</em>. Address only values include <a href="#type-properties">non-bitwise-copyable</a> values, values with <a href="#opaque-layout">opaque layout</a>, and non-class-constrained <a href="#existential-containers">existential values</a>. Even if the runtime type would normally be passed in a register, or even if the type is statically known at the call-site, if the callee receives or returns values with opaque layout, they must be passed or returned indirectly.</p>
<p>We should investigate whether it makes sense to split values with partially opaque layout by passing the non-opaque parts in registers [ <a href="https://bugs.swift.org/browse/SR-3947">SR-3947</a> ].</p>
<p>Parameter ownership is not reflected in the physical calling convention, though it will be noted in the mangling of the function name. Default argument expressions will not be ABI, as they will be emitted into the caller. This means that a library can add, modify, or remove default argument expressions without breaking binary compatibility (though modifying/removing may break source compatibility).</p>
<h4 id="Lowering-Higher-Order-Functions"><a href="#Lowering-Higher-Order-Functions" class="headerlink" title="Lowering Higher-Order Functions"></a>Lowering Higher-Order Functions</h4><p>Passing or returning higher-order functions may involve undergoing <a href="#abstraction-levels">reabstraction</a>, which requires that the compiler creates a thunk mapping between the actual calling convention and the expected calling convention.</p>
<p>For example, let’s say there are two functions:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(<span class="keyword">_</span> i: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> i+<span class="number">1</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span>&lt;T,U&gt;<span class="params">(<span class="keyword">_</span> f: <span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>, <span class="keyword">_</span> x: <span class="type">T</span>) -&gt; <span class="type">U</span> &#123; <span class="keyword">return</span> f(x) &#125;</span><br></pre></td></tr></table></figure>

<p><code>apply</code>‘s function parameter <code>f</code> must take and return its values indirectly, as <code>T</code> and <code>U</code> have opaque layout. If <code>add1</code> is passed to <code>apply</code>, the compiler will create a thunk for <code>apply</code> to call that takes a parameter indirectly and calls <code>add1</code> by passing it in register. The thunk will then receive the result in register and return it indirectly back to <code>apply</code>.</p>
<h3 id="Stack-Invariants"><a href="#Stack-Invariants" class="headerlink" title="Stack Invariants"></a>Stack Invariants</h3><p>Calling conventions include invariants about the call stack, such as stack alignment. Unless there is a very compelling reason to deviate, Swift should just honor the stack invariants of the standard calling convention. This is because Swift functions may share their call stack with non-Swift code. For example a Swift function that calls an Objective-C function, which in turn calls another Swift function, would want to maintain the proper stack alignment (and any other stack invariants) for all calls. This is far simpler if they both honor the same invariants.</p>
<h3 id="Runtime-Calling-Convention"><a href="#Runtime-Calling-Convention" class="headerlink" title="Runtime Calling Convention"></a>Runtime Calling Convention</h3><p>The Swift runtime uses the standard calling convention, though it may evolve to preserve more invariants. It’s likely beneficial to introduce one or a number of tweaks to the scratch register sets of some runtime functions. Swift code that makes a call into the runtime assumes some registers are scratch, i.e. clobbered by the runtime function. But, some runtime functions may not need as many scratch registers and can guarantee more registers as callee-saved. Every formerly-scratch register that is denoted callee-saved (i.e. runtime function saved) relieves the register pressure of the surrounding Swift code making the runtime call.</p>
<p>Such changes to runtime functions can be rolled out incrementally in the future, and they are backwards compatible so long as no version of that function ever clobbers the now-saved registers. But, such a change is ratcheting, that is every register that is changed to be runtime-saved can no longer go back to being scratch without breaking binary compatibility. If the reduced scratch register set causes the runtime function to spill, then the whole exercise was pointless and actively harmful. Great care should be taken and testing applied for any change to ensure that the runtime function never spills in the future.</p>
<h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p>Swift exposes a runtime that provides APIs for compiled code. Calls into the Swift runtime are produced by the compiler for concerns such as memory management and run-time type information. Additionally, the runtime exposes low-level reflection APIs that are useful to the standard library and some users.</p>
<p>Every existing runtime function will need to be audited for its desirability and behavior [ <a href="https://bugs.swift.org/browse/SR-3735">SR-3735</a> ]. For every function, we need to evaluate whether we want the API as is:</p>
<ul>
<li>If yes, then we need to precisely specify the semantics and guarantees of the API.</li>
<li>If not, we need to either change, remove, or replace the API, and precisely specify the new semantics.</li>
</ul>
<p>The runtime is also responsible for lazily creating new type metadata entries at run time, either for generic type instantiations or for resilient constructs. Library evolution in general introduces a whole new category of needs from the runtime by making data and metadata more opaque, requiring interaction to be done through runtime APIs. Additionally, ownership semantics may require new runtime APIs or modifications to existing APIs. These new runtime needs are still under investigation [ <a href="https://bugs.swift.org/browse/SR-4352">SR-4352</a> ].</p>
<p>There are many potential future directions to open up the ABI and operate on less-opaque data directly, as well a techniques such as call-site caching. These are ABI-additive, and will be interesting to explore in the future.</p>
<p>For a potentially-out-of-date listing of runtime symbols and some details, see the <a href="https://github.com/apple/swift/blob/master/docs/Runtime.md">Runtime docs</a>.</p>
<h2 id="Standard-Library"><a href="#Standard-Library" class="headerlink" title="Standard Library"></a>Standard Library</h2><hr>
<p>Any standard library API shipped post-ABI-stability must be supported into the future to ensure binary compatibility. The standard library will also be utilizing resilience annotations and <em>inlineable</em> code. Inlineable code is code that is bundled with the client’s code, and is available for inlining to the optimizer if it decides to do so. The standard library faces the following (non-exhaustive) list of challenges for ensuring binary compatibility:</p>
<ul>
<li>Published public functions and types cannot be removed or changed in ways that break binary compatibility.</li>
<li>Choosing what code to make inlineable will affect performance and flexibility.</li>
<li>Internal functions called by inlineable code become ABI, and are subject to the same binary compatibility concerns as public functions.</li>
<li>Non-resilient types cannot change their layout.</li>
<li>Protocols cannot add new requirements.</li>
</ul>
<h3 id="Inlineability"><a href="#Inlineability" class="headerlink" title="Inlineability"></a>Inlineability</h3><p>Inlineable code that calls internal functions makes those internal functions ABI, as the client code will be making external calls to them. Thus, many internal interfaces in the standard library will need to be locked down if called from inlineable code. Whether to mark code inlineable will have to carefully weigh performance requirements against keeping flexibility for future changes.</p>
<p>This tradeoff between performance and flexibility also affects the ability to deploy bug fixes and performance improvements to users. Users that have inlined code from the standard library will not be able to get bug fixes and performance improvements in an OS update without performing a recompilation with the new library. For more information on this topic, see <a href="https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#inlineable-functions">Inlineable Functions</a>.</p>
<h3 id="Upcoming-Changes"><a href="#Upcoming-Changes" class="headerlink" title="Upcoming Changes"></a>Upcoming Changes</h3><p>While the standard library is already ensuring source stability, it will be changing many of its fundamental underlying representations this year. When ABI stability lands, the standard library will be severely limited in the kinds of changes it can make to existing APIs and non-resilient types. Getting the standard library in the right place is of critical importance.</p>
<p>The programming model for String is still being redesigned [ <a href="https://bugs.swift.org/browse/SR-4354">SR-4354</a> ], and many types such as Int are undergoing implementation changes [ <a href="https://bugs.swift.org/browse/SR-3196">SR-3196</a> ]. At the same time, the standard library is simultaneously switching to new compiler features such as conditional conformances to clean up and deliver the best APIs [ <a href="https://bugs.swift.org/browse/SR-3458">SR-3458</a> ].</p>
<p>Another goal of Swift is to improve the applicability of Swift to systems programming. Ownership semantics may make a large impact, including things such as improved <code>inout</code> semantics that allow for efficient and safe array slicing. Providing the right abstractions for efficient use of contiguous memory is still under investigation [ <a href="https://bugs.swift.org/browse/SR-4355">SR-4355</a> ].</p>
<h2 id="Next-Steps"><a href="#Next-Steps" class="headerlink" title="Next Steps"></a>Next Steps</h2><p>All progress and issue tracking will be done through JIRA on <a href="https://bugs.swift.org/">bugs.swift.org</a>, using the “AffectsABI” label. We will make an ABI stability dashboard to more easily monitor specifics and progress. The next step is to start making issues for everything that needs fixing and issues for the directions we want to explore.</p>
<p>This document will be a living document until ABI stability is reached, updated with new findings and JIRA issues as they come up. After ABI stability is achieved, this document should be succeeded by technical specifications of Swift’s ABI.</p>
<p>Issue tracking alone doesn’t effectively communicate the overall progress and when ABI stability can be expected to land. Some issues take longer than others and there isn’t a good indication of how long the known tasks will take, nor of how many unknown issues are yet to be filed. For that, a higher level view of the overall status will be provided, possibly on <a href="https://swift.org/">swift.org</a>.</p>
<p><a href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md">Swift ABI Stability Manifesto</a></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【八】泛型</title>
    <url>/2018/04/03/2018-04-03-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E5%85%AB%E3%80%91%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>和大多数先进语言一样，Swift 拥有不少能被归类于泛型编程下的特性。使用泛型代码，你可以写出可重用的函数和数据结构，只要它们满足你所定义的约束，它们就能够适用于各种类型。比如，像是 <code>Array</code> 和 <code>Set</code> 等多个类型，实际上是它们中的元素类型就是泛型抽象。我们也可以创建泛型方法，它们可以对输入或者输出的类型进行泛型处理。<code>func identity&lt;A&gt;(input: A) -&gt; A</code> 就定义了一个可以作用于任意类型 A 的函数。某种意义上，我们甚至可以认为带有关联类型的协议是“泛型协议”。关联类型允许我们对特定的实现进行抽象。<code>IteratorProtocol</code> 协议就是一个这样的例子：它所生成的 <code>Element</code> 就是一个泛型。</p>
<p>泛型编程的目的是表达算法或者数据结构所要求的核心接口。比如，考虑内建集合一章中的 <code>last(where:)</code> 函数。将它写为 <code>Array</code> 的一个扩展原本是最明显的选择，但是 <code>Array</code> 其实包含了很多 <code>last(where:)</code> 并不需要的特性。通过确认核心接口到底是什么，也就是说，找到想要实现的功能的最小需求，我们可以将这个函数定义在宽阔得多的类型范围内。在这个例子中，<code>last(where:)</code> 只有一个需求：它需要能够逆序遍历一系列元素。所以，将这个算法定义为 <code>Sequence</code> 的扩展是更好的选择 (我们也可以为 <code>BidirectionalCollection</code> 添加一个更高效的实现)。</p>
<a id="more"></a>

<p>在本章中，我们会研究如何书写泛型代码。我们会先看一看什么是重载 (overloading) ，因为这个概念和泛型紧密相关。然后我们会使用泛型的方式，基于不同的假设，来为一个算法提供多种实现。之后我们将讨论一些你在为集合书写泛型算法时会遇到的常见问题，了解这些问题后你就将能使用泛型数据类型来重构代码，并使它们易于测试，更加灵活。最后，我们会谈一谈编译器是如何处理泛型代码的，以及要如何优化我们的泛型代码以获取更高性能的问题。</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><hr>
<p>拥有同样名字，但是参数或返回类型不同的多个方法互相称为重载方法，方法的重载并不意味着泛型。不过和泛型类似，我们可以将多种类型使用在同一个接口上。</p>
<h4 id="自由函数的重载"><a href="#自由函数的重载" class="headerlink" title="自由函数的重载"></a>自由函数的重载</h4><p>Swift 有一系列的复杂规则来确定到底使用哪个重载函数，这套规则基于函数是否是泛型，以及传入的参数是怎样的类型来确定使用优先级。整套规则十分复杂，不过它们可以被总结为一句话，那就是“选择最具体的一个”。也就是说，<strong>非通用的函数会优先于通用函数被使用</strong>。</p>
<p>来看下面这个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span>&lt;View: UIView&gt;<span class="params">(<span class="keyword">_</span> view: View)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s a \(type(of: view)), frame: \(view.frame)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="keyword">_</span> view: UILabel)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> text = view.text ?? <span class="string">&quot;(empty)&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s a label, text: \(text)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入 <code>UILabel</code> 将会调用专门针对 <code>label</code> 的重载，而传入其他的视图将会调用到泛型函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: <span class="type">CGRect</span>(x: <span class="number">20</span>, y: <span class="number">20</span>, width: <span class="number">200</span>, height: <span class="number">32</span>))</span><br><span class="line">label.text = <span class="string">&quot;Password&quot;</span></span><br><span class="line">log(label) <span class="comment">// It&#x27;s a label, text: Password</span></span><br><span class="line"><span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">50</span>))</span><br><span class="line">log(button) <span class="comment">// It&#x27;s a UIButton, frame: (0.0, 0.0, 100.0, 50.0)</span></span><br></pre></td></tr></table></figure>

<p><strong>要特别注意，重载的使用是在编译期间静态决定的。也就是说，编译器会依据变量的静态类型来决定要调用哪一个重载，而不是在运行时根据值的动态类型来决定。</strong>我们如果将上面的 <code>label</code> 和 <code>button</code> 都放到一个 <code>UIView</code> 数组中，并对它们迭代并调用 <code>log</code> 的话，使用的都是泛型重载的版本：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> views = [label, button] <span class="comment">// Type of views is [UIView]</span></span><br><span class="line"><span class="keyword">for</span> view <span class="keyword">in</span> views &#123;</span><br><span class="line">    log(view)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> It&#x27;s a UILabel, frame: (20.0, 20.0, 200.0, 32.0)</span></span><br><span class="line"><span class="comment"> It&#x27;s a UIButton, frame: (0.0, 0.0, 100.0, 50.0)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><code>view</code> 的静态类型是 <code>UIView</code>，<code>UILabel</code> 本来应该使用更专门的另一个重载，但是因为重载并不会考虑运行时的动态类型，所以两者都使用了 <code>UIView</code> 的泛型重载。</p>
<h4 id="运算符的重载"><a href="#运算符的重载" class="headerlink" title="运算符的重载"></a>运算符的重载</h4><p>当使用操作符重载时，编译器会表现出一些奇怪的行为。Matt Gallagher 指出，即使泛型版本应该是更好的选择（而且应该在一个普通函数调用时被选择）的时候，类型检查器也还是会去选择那些非泛型的重载，而不去选择泛型重载。</p>
<p>我们来看一个幂运算的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 幂运算比乘法运算优先级更高</span></span><br><span class="line">precedencegroup <span class="type">ExponentiationPrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span>: <span class="keyword">left</span></span><br><span class="line">    higherThan: <span class="type">MultiplicationPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> **: <span class="type">ExponentiationPrecedence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> **<span class="params">(lhs: Double, rhs: Double)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pow(lhs, rhs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> **<span class="params">(lhs: Float, rhs: Float)</span></span> -&gt; <span class="type">Float</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> powf(lhs, rhs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们添加一个整数的重载，让它对所有的整数类型有效，这里我们对所有满足 <code>BinaryInteger</code> 的类型定义了一个重载。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> **&lt;I: BinaryInteger&gt;<span class="params">(lhs: I, rhs: I)</span></span> -&gt; <span class="type">I</span> &#123;</span><br><span class="line">    <span class="comment">// 转换为 Int64，使用 Double 的重载计算结果</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="type">Double</span>(<span class="type">Int64</span>(lhs)) ** <span class="type">Double</span>(<span class="type">Int64</span>(rhs))</span><br><span class="line">    <span class="keyword">return</span> <span class="type">I</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的泛型看起来没什么问题，但是在我们使用整型调用 <code>**</code> 的时候，<strong>编译器会报错说 <code>**</code> 存在歧义</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 错误：操作符 &#x27;**&#x27; 的使用存在歧义。</span></span><br></pre></td></tr></table></figure>

<p><strong>要解释原因，我们需要回到我们在本节一开头说道的：对于重载的运算符，类型检查器会去使用非泛型版本的重载，而不考虑泛型版本。显然，编译器忽略了整数的泛型重载，因此它无法确定是去调用 <code>Double</code> 的重载还是 <code>Float</code> 的重载，因为两者对于整数字面量输入来说，是相同优先级的可选项（Swift 编译器会将整数字面量在需要时自动向上转换为 <code>Double</code> 或者 <code>Float</code> ），所以编译器报错说存在歧义。要让编译器选择正确的重载，我们需要至少将一个参数显式地声明为整数类型，或者明确提供返回值的类型：</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intResult: <span class="type">Int</span> = <span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<h4 id="使用泛型约束进行重载"><a href="#使用泛型约束进行重载" class="headerlink" title="使用泛型约束进行重载"></a>使用泛型约束进行重载</h4><p><strong>当你在写一些可以被用多种算法表达的同样的操作，并且算法对它们的泛型参数又有不同的要求的代码的时候，你可能经常会遇到带有泛型代码的重载。假设我们要写一个算法，来确定一个数组中的所有元素是不是都被包含在另一个数组中。换句话说，我们想要知道第一个数组是不是第二个数组的子集 (这里元素的顺序不重要)。标准库中提供了一个叫做 <code>isSubset(of:)</code> 的方法，不过这个方法只适用于像 <code>Set</code> 这样满足 <code>SetAlgebra</code> 协议的类型。</strong></p>
<p>我们可以写一个适用于更宽广范围的 <code>isSubset(of:)</code>，它看起来可能是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 当且仅当 `self` 中的所有元素都包含在 `other` 中，返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isSubset</span><span class="params">(of other: [Element])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> other.<span class="built_in">contains</span>(element) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> oneToThree = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> fiveToOne = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">oneToThree.isSubset(of: fiveToOne) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这个 <code>isSubset</code> 的版本有一个重大缺陷，那就是性能。这里的算法的时间复杂度是 O(nm)，其中 n 和 m 分别代表两个数组的元素个数。也就是说，随着输入的增多，这个函数的最坏情况的耗时将成平方增加。这是因为 <code>contains</code> 在数组中的复杂度是线性的 O(m)，这个函数会迭代源序列中的元素，逐个检查它是够匹配给定的元素。而 <code>contains</code> 是在另一个迭代最初数组的元素的循环中被调用了，这个循环也很类似，是一个线性时间复杂度的循环。所以我们是在一个 O(n) 循环里执行了一个 O(m) 的循环，结果这个函数的复杂度就是 O(nm)。</p>
<p>我们可以通过要求元素满足 <code>Hashable</code> 来收紧序列元素类型的限制来写出性能更好的版本。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 如果 `self` 中的所有元素都包含在 `other` 中，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isSubset</span><span class="params">(of other: [Element])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> otherSet = <span class="type">Set</span>(other)</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> otherSet.<span class="built_in">contains</span>(element) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样查找操作就可以在常数时间内进行了。</p>
<p>类型检查器会使用它所能找到的最精确的重载。这里 <code>isSubset</code> 的两个版本都是泛型函数，所以非泛型函数先于泛型函数的规则并不适用。不过因为 <code>Hashable</code> 是对 <code>Equatable</code> 的扩展，所以要求 <code>Hashable</code> 的版本更加精确。有了这些约束，我们可能可以像例子中的 <code>isSubset</code> 这样写出更加高效的算法，所以编译器假设更加具体的函数会是更好的选择。</p>
<p><code>isSubset</code> 还可以更加通用，到现在位置，它只接受一个数组并对其检查。但是 <code>Array</code> 是一个具体的类型。实际上 <code>isSubset</code> 并不需要这么具体，在两个版本中只有两个函数调用，那就是两者中都有的 <code>contains</code> 以及 <code>Hashable</code> 版本中的 <code>Set.init</code>。这两种情况下，这些函数只要求输入类型满足 <code>Sequence</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 根据序列是否包含给定元素返回一个布尔值。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(<span class="keyword">_</span> element: Element)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Set</span>&lt;<span class="title">Element</span>: <span class="title">Hashable</span>&gt;:</span></span><br><span class="line"><span class="class">    <span class="title">SetAlgebra</span>, <span class="title">Hashable</span>, <span class="title">Collection</span>, <span class="title">ExpressibleByArrayLiteral</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/// 通过一个有限序列创建新的集合。</span></span><br><span class="line">    <span class="keyword">init</span>&lt;<span class="type">Source</span>: <span class="type">Sequence</span>&gt;(<span class="keyword">_</span> sequence: <span class="type">Source</span>)</span><br><span class="line">    <span class="keyword">where</span> <span class="type">Source</span>.<span class="type">Element</span> == <span class="type">Element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，<code>isSubset</code> 中 <code>other</code> 只需要是遵守 <code>Sequence</code> 的任意类型就可以了。另外，<code>self</code> 和 <code>other</code> 这两个序列类型并不需要是同样的类型。我们只需要其中的元素类型相同就能进行操作。下面是针对任意两种序列重写的 <code>Hashable</code> 版本的函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 如果 `self` 中的所有元素都包含在 `other` 中，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isSubset</span>&lt;S: Sequence&gt;<span class="params">(of other: S)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">        <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Element</span> == <span class="type">Element</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> otherSet = <span class="type">Set</span>(other)</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> otherSet.<span class="built_in">contains</span>(element) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在两个序列不需要有相同的类型了，这为我们开启了更多的可能性。比如，你可以传入一个数字的 <code>CountableRange</code> 来进行检查：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>].isSubset(of: <span class="number">1</span>...<span class="number">10</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>我们可以对可判等的元素的函数作出同样的更改。</p>
<h4 id="使用闭包对行为进行参数化"><a href="#使用闭包对行为进行参数化" class="headerlink" title="使用闭包对行为进行参数化"></a>使用闭包对行为进行参数化</h4><p>使用闭包对行为参数化，指的就是闭包表达式，类似于 <code>Array</code> 的 <code>map</code> ，<code>filter</code> ，<code>reduce</code> 这些函数。 我们的 <code>isSubset</code> 函数还有更加通用化的可能，对于那些不遵循 <code>Equatable</code> 的序列要怎么办？比如 <code>Array</code> 的元素也是 <code>Array</code> 的时候，本身 <code>Array</code> 无法遵循 <code>Equatable</code> ，因为 <code>Array</code> 元素本身就可能不能判等。</p>
<p>遇到这种情况的时候，我们可以将判等的工作交给调用者去实现，使用闭包。标准库中的 <code>contains</code> 函数就是一个很好的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 根据序列是否包含满足给定断言的元素，返回一个布尔值。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(<span class="keyword">where</span> predicate: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>)</span><br><span class="line">        <span class="keyword">rethrows</span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>contains</code> 函数很强大，你可以用它来对一个序列进行各种条件的检查。用于我们的 <code>isSubset</code> 函数上后，就像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isSubset</span>&lt;S: Sequence&gt;<span class="params">(of other: S,</span></span></span><br><span class="line"><span class="function"><span class="params">                               by areEquivalent: <span class="params">(Element, S.Element)</span></span></span> -&gt; <span class="type">Bool</span>)</span><br><span class="line">        -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> other.<span class="built_in">contains</span>(<span class="keyword">where</span>: &#123; areEquivalent(element, $<span class="number">0</span>) &#125;) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以将 <code>isSubset</code> 用在数组的数组上了，只需要为它提供一个闭包表达式，并使用 <code>==</code> 来对数组进行比较。<strong>不幸的是，如果我们导入了 <code>Foundation</code>，另一个对类型检查器的性能优化将会导致编译器不再确定到底应该使用哪个 <code>==</code>，从而使编译发生错误。我们需要在代码的某个地方加上类型标注：</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">2</span>]].isSubset(of: [[<span class="number">1</span>,<span class="number">2</span>] <span class="keyword">as</span> [<span class="type">Int</span>], [<span class="number">3</span>,<span class="number">4</span>]]) &#123; $<span class="number">0</span> == $<span class="number">1</span> &#125; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="对集合采用泛型操作"><a href="#对集合采用泛型操作" class="headerlink" title="对集合采用泛型操作"></a>对集合采用泛型操作</h3><hr>
<p>集合上的泛型算法通常会带出一些特殊的问题，特别在与索引和切片一起使用时更是如此。在这节中，我们通过两个依赖于正确处理索引和切片的例子，来看看如何解决这些问题。</p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>说到二分查找，相信大家都会马上想起自己写的最简单的二分查找法。例如下面这个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 返回 `value` 第一次出现在 `self` 中的索引值，</span></span><br><span class="line">    <span class="comment">/// 如果 `value` 不存在，返回 `nil`</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - 要求: `isOrderedBefore` 是在 `self` 中元素上</span></span><br><span class="line">    <span class="comment">/// 的严格弱序，且数组中的元素已经按它进行过排序</span></span><br><span class="line">    <span class="comment">/// - 复杂度: O(log `count`)</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">for</span> value: Element,</span></span></span><br><span class="line"><span class="function"><span class="params">                      areInIncreasingOrder: <span class="params">(Element, Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Int?</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">right</span> = <span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">left</span> &lt;= <span class="keyword">right</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> mid = (<span class="keyword">left</span> + <span class="keyword">right</span>) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">let</span> candidate = <span class="keyword">self</span>[mid]</span><br><span class="line">            <span class="keyword">if</span> areInIncreasingOrder(candidate,value) &#123;</span><br><span class="line">                <span class="keyword">left</span> = mid + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> areInIncreasingOrder(value,candidate) &#123;</span><br><span class="line">                <span class="keyword">right</span> = mid - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 由于 isOrderedBefore 的要求，如果两个元素互无顺序关系，那么它们一定相等</span></span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">for</span> value: Element)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.binarySearch(<span class="keyword">for</span>: value, areInIncreasingOrder: &lt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个简单的二分查找算法，其实有一个 Bug。</p>
<blockquote>
<p>在数组非常大的情况下，将两个索引值相加有可能会造成溢出 (比如 <code>count</code> 很接近 <code>Int.max</code>，并且要搜索的元素是数组最后一个元素时的情况)。不过，将距离的一半加到左侧索引时，这个问题就不会发生。当然了，想要触发这个 bug 的机会其实很小。  </p>
</blockquote>
<p>现在我们来改善一下既有的算法设计，以前二分查找算法都是基于普通数组的，但是在 Swift 中，有一些特殊的数组，像是 <code>ArraySlice</code> ，上面的算法是无法直接在 <code>ArraySlice</code> 数组中运行的，当我们在计算中间下标的时候，会出现一个 Bug，因为 <code>ArraySlice</code> 的下标并不一定是从 0 开始。所以我们定义二分查找算法的时候，不能定义在普通的数组 <code>Array</code> 上，我们应该定义在 <code>RandomAccessCollection</code>。</p>
<h4 id="泛型二分查找"><a href="#泛型二分查找" class="headerlink" title="泛型二分查找"></a>泛型二分查找</h4><p>如果你把 Int 索引的要求去掉，将会发生一些编译错误。原来的代码需要进行一些重写才能完全满足泛型的要求。下面是完全泛型化之后的版本：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">RandomAccessCollection</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">for</span> value: Element, areInIncreasingOrder: <span class="params">(Element, Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Index?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> !isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = startIndex</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">right</span> = index(before: endIndex)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">left</span> &lt;= <span class="keyword">right</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> dist = <span class="built_in">distance</span>(from: <span class="keyword">left</span>, to: <span class="keyword">right</span>)</span><br><span class="line">            <span class="keyword">let</span> mid = index(<span class="keyword">left</span>, offsetBy: dist / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> candidate = <span class="keyword">self</span>[mid]</span><br><span class="line">            <span class="keyword">if</span> areInIncreasingOrder(candidate, value) &#123;</span><br><span class="line">                <span class="keyword">left</span> = index(after: mid)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> areInIncreasingOrder(value, candidate) &#123;</span><br><span class="line">                <span class="keyword">right</span> = index(before: mid)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">RandomAccessCollection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">for</span> value: Element)</span></span> -&gt; <span class="type">Index?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(<span class="keyword">for</span>: value, areInIncreasingOrder: &lt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strAry = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span>]</span><br><span class="line">strAry.binarySearch(<span class="keyword">for</span>: <span class="string">&quot;d&quot;</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ArraySlice 并不一定是从下标为 0 开始</span></span><br><span class="line"><span class="keyword">let</span> subStrAry = strAry[<span class="number">3</span>..&lt;<span class="number">5</span>] <span class="comment">// [&quot;d&quot;, &quot;e&quot;]</span></span><br><span class="line">subStrAry.binarySearch(<span class="keyword">for</span>: <span class="string">&quot;d&quot;</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>改动虽小，意义重大。首先，<code>left</code> 和 <code>right</code> 变量现在不再是整数类型了。我们使用了起始索引和结束索引值。这些值可能是整数，但它们也可能是像是 <code>String</code> 的索引，<code>Dictionary</code> 的索引，或者是 <code>Set</code> 的索引这样的非透明索引，它们是无法随机访问的。</p>
<h3 id="使用泛型进行代码设计"><a href="#使用泛型进行代码设计" class="headerlink" title="使用泛型进行代码设计"></a>使用泛型进行代码设计</h3><hr>
<p>让我们来写一些与网络服务交互的函数。比如，获取用户列表的数据，并将它解析为 <code>User</code> 数据类型。我们创建一个 <code>loadUsers</code> 函数，它可以从网上异步加载用户，并且在完成后通过一个回调来传递获取到的用户列表。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadUsers</span><span class="params">(callback: <span class="params">([User]?)</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    <span class="keyword">let</span> usersURL = webserviceURL.appendingPathComponent(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">try</span>? <span class="type">Data</span>(contentsOf: usersURL)</span><br><span class="line">    <span class="keyword">let</span> json = data.flatMap &#123;</span><br><span class="line">        <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: $<span class="number">0</span>, options: [])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> users = (json <span class="keyword">as</span>? [<span class="type">Any</span>]).flatMap &#123; jsonObject <span class="keyword">in</span></span><br><span class="line">        jsonObject.flatMap(<span class="type">User</span>.<span class="keyword">init</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    callback(users)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数有个严重的问题，代码的重用性非常差，如果我们想要写一个相同的函数来加载其他资源，我们可能需要复制这里的大部分代码。打个比方，我们需要一个加载博客文章的函数，它看起来是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadBlogPosts</span><span class="params">(callback: <span class="params">([BlogPost])</span></span></span>? -&gt; ())</span><br></pre></td></tr></table></figure>

<h4 id="提取共通功能"><a href="#提取共通功能" class="headerlink" title="提取共通功能"></a>提取共通功能</h4><p>相比于复制粘贴，将函数中 User 相关的部分提取出来，将其他部分进行重用，会是更好的方式。我们可以将 URL 路径和解析转换的函数作为参数传入。因为我们希望可以传入不同的转换函数，所以我们将 loadResource 声明为 A 的泛型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadResource</span>&lt;A&gt;<span class="params">(at path: String,</span></span></span><br><span class="line"><span class="function"><span class="params">                     parse: <span class="params">(<span class="keyword">Any</span>)</span></span></span> -&gt; <span class="type">A?</span>, callback: (<span class="type">A?</span>) -&gt; ())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> resourceURL = webserviceURL.appendingPathComponent(path)</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">try</span>? <span class="type">Data</span>(contentsOf: resourceURL)</span><br><span class="line">    <span class="keyword">let</span> json = data.flatMap &#123;</span><br><span class="line">        <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: $<span class="number">0</span>, options: [])</span><br><span class="line">    &#125;</span><br><span class="line">    callback(json.flatMap(parse))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以将 <code>loadUsers</code> 函数基于 <code>loadResource</code> 重写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadUsers</span><span class="params">(callback: <span class="params">([User]?)</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    loadResource(at: <span class="string">&quot;/users&quot;</span>, parse: jsonArray(<span class="type">User</span>.<span class="keyword">init</span>), callback: callback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用了一个辅助函数，<code>jsonArray</code>，它首先尝试将一个 <code>Any</code> 转换为一个 <code>Any</code> 的数组，接着对每个元素用提供的解析函数进行解析，如果期间任何一步发生了错误，则返回 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jsonArray</span>&lt;A&gt;<span class="params">(<span class="keyword">_</span> transform: @escaping <span class="params">(<span class="keyword">Any</span>)</span></span></span> -&gt; <span class="type">A?</span>) -&gt; (<span class="type">Any</span>) -&gt; [<span class="type">A</span>]? &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; array <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> array = array <span class="keyword">as</span>? [<span class="type">Any</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array.flatMap(transform)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于加载博客文章的函数，我们只需要替换请求路径和解析函数就行了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadBlogPosts</span><span class="params">(callback: <span class="params">([BlogPost]?)</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    loadResource(at: <span class="string">&quot;/posts&quot;</span>, parse: jsonArray(<span class="type">BlogPost</span>.<span class="keyword">init</span>), callback: callback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建泛型数据类型"><a href="#创建泛型数据类型" class="headerlink" title="创建泛型数据类型"></a>创建泛型数据类型</h4><p><code>loadResource</code> 函数中的 <code>path</code> 和 <code>parse</code> 耦合非常紧密，一旦你改变了其中一个，你很可能也需要改变另一个。我们可以将它们打包进一个结构体中，用来描述要加载的资源。和函数一样，这个结构体也可以是泛型的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resource</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> path: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> parse: (<span class="type">Any</span>) -&gt; <span class="type">A?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadSynchronously</span><span class="params">(callback: <span class="params">(A?)</span></span></span> -&gt; ()) &#123;</span><br><span class="line">        <span class="keyword">let</span> resourceURL = webserviceURL.appendingPathComponent(path)</span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">try</span>? <span class="type">Data</span>(contentsOf: resourceURL)</span><br><span class="line">        <span class="keyword">let</span> json = data.flatMap &#123;</span><br><span class="line">            <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: $<span class="number">0</span>, options: [])</span><br><span class="line">        &#125;</span><br><span class="line">        callback(json.flatMap(parse))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadAsynchronously</span><span class="params">(callback: @escaping <span class="params">(A?)</span></span></span> -&gt; ()) &#123;</span><br><span class="line">        <span class="keyword">let</span> resourceURL = webserviceURL.appendingPathComponent(path)</span><br><span class="line">        <span class="keyword">let</span> session = <span class="type">URLSession</span>.shared</span><br><span class="line">        session.dataTask(with: resourceURL) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> json = data.flatMap &#123;</span><br><span class="line">                <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: $<span class="number">0</span>, options: [])</span><br><span class="line">            &#125;</span><br><span class="line">            callback(json.flatMap(<span class="keyword">self</span>.parse))</span><br><span class="line">            &#125;.resume()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于之前的用顶层函数来定义资源，我们现在可以定义 <code>Resource</code> 结构体实例，这让我们可以很容易地添加新的资源，而不必创建新的函数。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift学习</tag>
      </tags>
  </entry>
  <entry>
    <title>多任务卡片动画实现原理</title>
    <url>/2018/04/04/2018-04-04-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%A1%E7%89%87%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><hr>
<p><img src="/my_pictures/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%A1%E7%89%87%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1.gif"></p>
<h3 id="控件-—-UICollectionView"><a href="#控件-—-UICollectionView" class="headerlink" title="控件 — UICollectionView"></a>控件 — UICollectionView</h3><hr>
<p>这个动画是用 <code>UICollectionView</code> 实现的，简单讲下 <code>UICollectionView</code> 的工作原理。这里用到的 <code>UICollectionView</code> 也就3部分：<code>ViewController</code>（简称VC）、<code>UICollectionViewCell</code>、<code>UICollectionViewLayout</code>。</p>
<ol>
<li><p><code>ViewController</code> ：<br>在VC里，<code>UICollectionView</code> 的用法跟 <code>UITableView</code> 的用法类似。这里的初始化方法与 <code>UITableview</code> 有所不同，多了个 <code>collectionViewLayout</code> 属性，每个 <code>collectionView</code> 都会绑定一个 <code>UICollectionViewLayout</code> 对象， <code>collectionView</code> 根据这个 <code>layout</code> 对象来布局 <code>cell</code> 。</p>
</li>
<li><p><code>UICollectionViewCell</code> ：<br>这里用的 <code>Cell</code> 实现起来和 <code>UITableViewCell</code> 没什么大区别，我们只要实现它的 <code>initwithFrame</code> 的初始化方法即可，然后实现你想要的布局。</p>
</li>
</ol>
<a id="more"></a>

<ol start="3">
<li><code>UICollectionViewLayout</code> ：<br><a href="https://developer.apple.com/reference/uikit/uicollectionviewlayout">UICollectionViewLayout</a></li>
</ol>
<p><code>UICollectionViewLayout</code> 是让 <code>UICollectionView</code> 千变万化的精髓所在，所以上面的动画的重点也就是在 <code>layout</code> 里实现的。<br>系统提供了一个 <code>UICollectionViewFlowLayout</code> ，是一个流式布局，可以通过设置 <code>scrollDirection</code> 来指定滚动方向，如果这个系统提供的布局不能满足我们的需求，那我们就要自己实现一个 <code>UICollectionViewLayout </code> 的子类来达到我们想要的效果了，接下来说下自定义的 <code>layout</code> 需要重写哪几个方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当layout第一次展示时调用，显式或隐式地调用invalidatedlayout也会调用prepareLayout，During each layout update, the collection view calls this method first to give your layout object a chance to prepare for the upcoming layout operation</span></span><br><span class="line">- (<span class="keyword">void</span>)prepareLayout；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回collectionView的contentSize，来决定collectionView的滚动范围</span></span><br><span class="line">- (CGSize)collectionViewContentSize；</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the content offset to use after an animated layout update or change。如果你的动画有两个layout的切换，那么这个方法至关重要，用它来返回一个目标contentOffset，能保证动画的正常表现。</span></span><br><span class="line">-(CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset；</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the layout attributes for all of the cells and views in the specified rectangle.</span></span><br><span class="line">- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重中之重的方法，用来计算指定indexPath所对应的布局信息。这里的布局信息是一个UICollectionViewLayoutAttributes对象，我们可以通过frame、center、transform3D、transform来控制cell的表现状态。最后将这个attributes对象返回给上层使用。</span></span><br><span class="line">-(UICollectionViewLayoutAttributes*)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath；</span><br></pre></td></tr></table></figure>

<h3 id="动画实现细节"><a href="#动画实现细节" class="headerlink" title="动画实现细节"></a>动画实现细节</h3><hr>
<p>上面是关于 <code>UICollectionView</code> 的一些初步介绍，还有很多使用细节待君探索。接下来说下我们这个动画的实现细节吧。</p>
<p>上面的动画中，包括了位移、缩放、透明度三个方面的变化，我们先来谈谈重点的位移部分吧。</p>
<p>思路：动画的效果是，随着手指的滑动， <code>cell</code> 从上往下慢慢位移，位移的过程中速度越来越快；相反，如果往上滑动， <code>cell</code> 移动的速度就慢慢变小。这里的自变量是  <code>collectionView.contentOffset.y</code>（竖直方向），因变量是 <code>cell.center.y</code> （或者说 <code>cell.frame.origin.y</code> ），所以需要为他们之间找一个函数，这个函数需要满足上面的动画效果。</p>
<p>根据变化的规律，先确定一个初步的函数：</p>
<p><img src="/my_pictures/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%A1%E7%89%87%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-2.png"></p>
<p>它符合从小到大变化递增的特性，可以通过一些在线工具查看函数的图像来比较直观的看到函数的变化规律</p>
<p>可以看到这个函数是有两段的，那我们需要的只是左边这部分，因为当我们手指下滑的时候， <code>collectionView.contentOffset.y</code> 实际上是变小的，而 <code>cell.origin.y</code> 却是在变大的，所以左边半部分的变化正是我们想要的。</p>
<p>然而 </p>
<p><img src="/my_pictures/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%A1%E7%89%87%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-3.png"> </p>
<p>并不能满足要求，需要将它①向右拉伸m个点、②向上拉伸n个点，也就是要构造一个函数：</p>
<p><img src="/my_pictures/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%A1%E7%89%87%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-4.png"></p>
<p>这里解释一下m、n的值的含义。</p>
<p>将 </p>
<p><img src="/my_pictures/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%A1%E7%89%87%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-5.png"></p>
<p>做上述两步变化，m = 600，n = 500，生成如下函数</p>
<p><img src="/my_pictures/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%A1%E7%89%87%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-6.png"></p>
<p>函数与 x 轴交点是 (600,0)，与 y 轴交点是 (0,500)。<br>(0,500) 比较好理解，就是当 <code>collectionView.contentOffset.y</code> 等于 0 的时候， <code>cell</code> 对应的y坐标为 500。<br>(600,0) 也不难理解，就是当我们手指往上滑 600 个点，使 <code>collectionView.contentOffset.y=600</code> 时，这个时候 <code>cell.origin.y</code> 会等于 0。</p>
<h3 id="函数的具体应用"><a href="#函数的具体应用" class="headerlink" title="函数的具体应用"></a>函数的具体应用</h3><hr>
<h4 id="定义第-0-个-cell-的位移函数"><a href="#定义第-0-个-cell-的位移函数" class="headerlink" title="定义第 0 个 cell 的位移函数"></a>定义第 0 个 <code>cell</code> 的位移函数</h4><p>假设第 0 个 <code>cell</code>（简称 <code>cell0</code> ）对应函数的 m、n 分别为 n0 = 250，m0 = 1000，即当 <code>collectionView.contentOffset.y=0</code> 时， <code>cell0.origin.y=250</code> ；当我们往上滑1000个点， <code>collectionView.contentOffset.y=1000</code> 时， <code>cell0.origin.y=0</code> 。同理，<br><strong>ni 则表示当 <code>contentOffset.y=0</code> 时，第 i 个 <code>cell</code> 的 y 坐标。mi 则表示当 <code>contentOffset.y=mi</code> 时，第 i 个 <code>cell</code> 的 y 坐标为 0。</strong></p>
<p>所以对于第 0 个 <code>cell</code> ，我们可以给出一个函数来计算它的 y 坐标：</p>
<p><img src="/my_pictures/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%A1%E7%89%87%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-7.png"></p>
<p>这里 x 是指 <code>collectionView.contentOffset.y</code> ，y0 是指 <code>cell0.origin.y</code> ；</p>
<h4 id="生成第-i-个-cell-的位移函数"><a href="#生成第-i-个-cell-的位移函数" class="headerlink" title="生成第 i 个 cell 的位移函数"></a>生成第 i 个 cell 的位移函数</h4><p>定义了cell0 的位置函数，就可以以一定规律生成 cell1、cell2…… 的位置函数了，也就是生成每个cell 的 m、n 值。</p>
<h4 id="mi-的计算"><a href="#mi-的计算" class="headerlink" title="mi 的计算"></a>mi 的计算</h4><p><strong>我们可以定义，当手指往下滑动140个点时，第1个 cell 会运动到第2个 cell的位置</strong>，以此类推，每个 <code>cell</code> 会运动到下一个 <code>cell</code> 的位置。所以我们定义 $m_i=m_{i-1}+140$ 也就是 $m_i=m_0 + itimes140$; （ps:这里140决定了 cell 之间的间距，当然可以根据需求改变这个值来调整视觉效果）</p>
<h4 id="ni-的计算"><a href="#ni-的计算" class="headerlink" title="ni 的计算"></a>ni 的计算</h4><p>需要通过 $y_0=((1000-x)/1000)^4times250$ 来计算。我们知道，当 x=0 时，$y_0=n_0=250$。在上一步计算时，我们定义了手指往下滑140时第0个 <code>cell</code> 会运动到第1个 <code>cell</code> 的位置，也就是说 <code>cell1</code> 的位置 $n_1$ 可以由 $y_0=((1000-x)/1000)^4times250$ 得到，**这里 x 的值应该是手指从 0 下滑140个点，也就是 <code>collectionView.contentOffset.y=-140</code> ，所以x=(-140)**。（ps：往下滑动时 <code>contentOffset.y</code> 是递减的，所以这里的x是负的140。）所以</p>
<p><img src="/my_pictures/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%A1%E7%89%87%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-8.png"></p>
<p>同理，可以推出 ni 的公式：</p>
<p><img src="/my_pictures/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%A1%E7%89%87%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-9.png">、</p>
<h4 id="yi-的公式"><a href="#yi-的公式" class="headerlink" title="yi 的公式"></a>yi 的公式</h4><p>ok，mi 和ni 都可由 m0、n0 得到，那么 yi 的公式</p>
<p><img src="/my_pictures/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%A1%E7%89%87%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-10.png"></p>
<p>就可以转化成 m0 和 n0 的表达式，即</p>
<p><img src="/my_pictures/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%A1%E7%89%87%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-11.png"></p>
<p>虽然这个函数看起来挺长的，但是其中 m0和n0 都是我们定的初始值，140 也是我们定义的常量。变量 x 就是 <code>contentOffset.y</code> 。所以到此我们已经能根据手指的滑动，计算出每个 <code>cell</code> 的 y 坐标，从而实现了这个滚动动画。</p>
<h4 id="公式体现在下面的函数里"><a href="#公式体现在下面的函数里" class="headerlink" title="公式体现在下面的函数里"></a>公式体现在下面的函数里</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 公式</span></span><br><span class="line"><span class="comment">//根据下标、当前偏移量来获取对应的y坐标</span></span><br><span class="line">-(CGFloat)getOriginYWithOffsetY:(CGFloat)offsetY row:(NSInteger)row</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 公式： y0 = ((m0 - x)/m0)^4*n0</span></span><br><span class="line">    <span class="comment">// 公式:  yi=((m0 + i*140-x)/(m0 + i*140))^4*((m0+140*i)/m0)^4*n0</span></span><br><span class="line">    CGFloat x = offsetY;    <span class="comment">//这里offsetY就是自变量x</span></span><br><span class="line">    CGFloat ni = [self defaultYWithRow:row];</span><br><span class="line">    CGFloat mi = self.m0+row*self.deltaOffsetY;</span><br><span class="line">    CGFloat tmp = mi - x;</span><br><span class="line">    tmp = fmaxf(<span class="number">0</span>, tmp);    <span class="comment">//不小于0</span></span><br><span class="line">    CGFloat y = powf((tmp)/mi, <span class="number">4</span>)*ni;</span><br><span class="line"><span class="comment">//    NSLog(@&quot;%d--y:%f &quot;,(int)row,y);</span></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当contentOffset.y=0时每个cell的y值</span></span><br><span class="line">-(CGFloat)defaultYWithRow:(NSInteger)row</span><br><span class="line">&#123;</span><br><span class="line">    CGFloat x0 = <span class="number">0</span>;     <span class="comment">//初始状态</span></span><br><span class="line">    CGFloat xi = x0 - self.deltaOffsetY*row;</span><br><span class="line">    CGFloat ni = powf((self.m0 - xi)/self.m0, <span class="number">4</span>)*self.n0;</span><br><span class="line"><span class="comment">//    NSLog(@&quot;defaultY-%d: %f&quot;,(int)row,ni);</span></span><br><span class="line">    <span class="keyword">return</span> ni;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转自"><a href="#转自" class="headerlink" title="转自"></a>转自</h3><ul>
<li><a href="http://www.code4app.com/thread-11971-1-1.html">仿多任务卡片动画</a></li>
</ul>
]]></content>
      <categories>
        <category>转帖</category>
      </categories>
      <tags>
        <tag>转帖日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 进阶【九】协议</title>
    <url>/2018/04/08/2018-04-08-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E4%B9%9D%E3%80%91%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>Swift 的协议和 Objective-C 的协议不同。<strong>Swift 协议可以被用作代理，也可以让你对接口进行抽象 (比如 <code>IteratorProtocol</code> 和 <code>Sequence</code> )。它们和 Objective-C 协议的最大不同在于我们可以让结构体和枚举类型满足协议。除此之外，Swift 协议还可以有关联类型。我们还可以通过协议扩展的方式为协议添加方法实现。</strong>我们会在面向协议编程的部分讨论所有这些内容。</p>
<p>协议允许我们进行动态派发，也就是说，在运行时程序会根据消息接收者的类型去选择正确的方法实现。</p>
<p>在面向对象编程中，子类是在多个类之间共享代码的有效方式。不过在 Swift 中，<code>Sequence</code> 中的代码共享是通过协议和协议扩展来实现的。通过这么做，<code>Sequence</code> 协议和它的扩展在结构体和枚举这样的值类型中依然可用，而这些值类型是不支持子类继承的。</p>
<p>协议扩展是一种可以在不共享基类的前提下共享代码的方法。协议定义了一组最小可行的方法集合，以供类型进行实现。而类型通过扩展的方式在这些最小方法上实现更多更复杂的特性。</p>
<a id="more"></a>

<h3 id="面向协议编程"><a href="#面向协议编程" class="headerlink" title="面向协议编程"></a>面向协议编程</h3><hr>
<p>比如在一个图形应用中，我们想要进行两种渲染：我们会将图形使用 <code>Core Graphics</code> 的 <code>CGContext</code> 渲染到屏幕上，或者创建一个 SVG 格式的图形文件。我们可以从定义绘图 API 的最小功能集的协议开始进行实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Drawing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">addEllipse</span><span class="params">(rect: CGRect, fill: UIColor)</span></span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">addRectangle</span><span class="params">(rect: CGRect, fill: UIColor)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>协议的最强大的特性之一就是我们可以以追溯的方式来修改任意类型，让它们满足协议。对于 <code>CGContext</code>，我们可以添加扩展来让它满足 <code>Drawing</code> 协议。对于 <code>SVG</code> 我们一样可以通过扩展让它满足 <code>Drawing</code> 协议。</p>
<p>我们现在就可以写出独立于渲染目标的代码了；下面的代码只对 <code>context</code> 变量实现了 <code>Drawing</code> 协议进行了假设。如果我们决定使用 <code>CGContext</code> 来初始化一个 <code>context</code>，我们并不需要改变代码的任何部分：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> context: <span class="type">Drawing</span> = <span class="type">SVG</span>()</span><br><span class="line"><span class="keyword">let</span> rect1 = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> rect2 = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">50</span>, height: <span class="number">50</span>)</span><br><span class="line">context.addRectangle(rect: rect1, fill: .yellow)</span><br><span class="line">context.addEllipse(rect: rect2, fill: .blue)</span><br><span class="line">context</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;svg&gt;</span></span><br><span class="line"><span class="comment">&lt;rect cy=&quot;0.0&quot; fill=&quot;#010100&quot; ry=&quot;100.0&quot; rx=&quot;100.0&quot; cx=&quot;0.0&quot;/&gt;</span></span><br><span class="line"><span class="comment">&lt;ellipse cy=&quot;0.0&quot; fill=&quot;#000001&quot; ry=&quot;50.0&quot; rx=&quot;50.0&quot; cx=&quot;0.0&quot;/&gt;</span></span><br><span class="line"><span class="comment">&lt;/svg&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h4><p>Swift 的协议的另一个强大特性是我们可以使用完整的方法实现来扩展一个协议。你可以扩展你自己的协议，也可以对已有协议进行扩展。</p>
<p>通过在扩展中添加 <code>addCircle</code>，我们就可以在 <code>CGContext</code> 和   中使用它了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Drawing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">addCircle</span><span class="params">(center: CGPoint, radius: CGFloat, fill: UIColor)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> diameter = radius * <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> origin = <span class="type">CGPoint</span>(x: center.x - radius, y: center.y - radius)</span><br><span class="line">        <span class="keyword">let</span> size = <span class="type">CGSize</span>(width: diameter, height: diameter)</span><br><span class="line">        <span class="keyword">let</span> rect = <span class="type">CGRect</span>(origin: origin, size: size)</span><br><span class="line">        addEllipse(rect: rect, fill: fill)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过协议进行代码共享相比与通过继承的共享，有这几个优势：</strong></p>
<ul>
<li>我们不需要被强制使用某个父类。</li>
<li>我们可以让已经存在的类型满足协议 (比如我们让 <code>CGContext</code> 满足了 <code>Drawing</code> )。子类就没那么灵活了，如果 <code>CGContext</code> 是一个类的话，我们无法以追溯的方式去变更它的父类。</li>
<li>协议既可以用于类，也可以用于结构体，而父类就无法和结构体一起使用了。</li>
<li>最后，当处理协议时，我们无需担心方法重写或者在正确的时间调用 <code>super</code> 这样的问题。</li>
</ul>
<h4 id="在协议扩展中重写方法"><a href="#在协议扩展中重写方法" class="headerlink" title="在协议扩展中重写方法"></a>在协议扩展中重写方法</h4><p>作为协议的作者，当你想在扩展中添加一个协议方法，你有两种方法。首先，你可以只在扩展中进行添加，就像我们上面 <code>addCircle</code> 所做的那样。或者，你还可以在协议定义本身中添加这个方法的声明，让它成为协议要求的方法。协议要求的方法是动态派发的，而仅定义在扩展中的方法是静态派发的。它们的区别虽然很微小，但不论对于协议的作者还是协议的使用者来说，都十分重要。</p>
<p>首先，我们对 <code>SVG</code> 写一个 <code>addCircle</code> 扩展：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SVG</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">addCircle</span><span class="params">(center: CGPoint, radius: CGFloat, fill: UIColor)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> attributes: [<span class="type">String</span>:<span class="type">String</span>] = [</span><br><span class="line">            <span class="string">&quot;cx&quot;</span>: <span class="string">&quot;\(center.x)&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cy&quot;</span>: <span class="string">&quot;\(center.y)&quot;</span>,</span><br><span class="line">            <span class="string">&quot;r&quot;</span>: <span class="string">&quot;\(radius)&quot;</span>,</span><br><span class="line">        ]</span><br><span class="line">        attributes[<span class="string">&quot;fill&quot;</span>] = <span class="type">String</span>(hexColor: fill)</span><br><span class="line">        append(node: <span class="type">XMLNode</span>(tag: <span class="string">&quot;circle&quot;</span>, attributes: attributes))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在如果我们创建一个 <code>SVG</code> 实例并调用它的 <code>addCircle</code> 方法，结果将和你期待的一致：编译器将选择 <code>addCircle</code> 的最具体的版本，也就是定义在 <code>SVG</code> 扩展上的版本。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sample = <span class="type">SVG</span>()</span><br><span class="line">sample.addCircle(center: .zero, radius: <span class="number">20</span>, fill: .red)</span><br><span class="line"><span class="built_in">print</span>(sample)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> &lt;svg&gt;</span></span><br><span class="line"><span class="comment"> &lt;circle cy=&quot;0.0&quot; fill=&quot;#010000&quot; r=&quot;20.0&quot; cx=&quot;0.0&quot;/&gt;</span></span><br><span class="line"><span class="comment"> &lt;/svg&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>如果像下面这样调用的话，它并不会使用 <code>SVG</code> 的 <code>addCircle</code> 方法。它调用的是 <code>Drawing</code> 中的 <code>addCircle</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> otherSample: <span class="type">Drawing</span> = <span class="type">SVG</span>()</span><br><span class="line">otherSample.addCircle(center: .zero, radius: <span class="number">20</span>, fill: .red)</span><br><span class="line"><span class="built_in">print</span>(otherSample)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> &lt;svg&gt;</span></span><br><span class="line"><span class="comment"> &lt;ellipse cy=&quot;-20.0&quot; fill=&quot;#010000&quot; ry=&quot;40.0&quot; rx=&quot;40.0&quot; cx=&quot;-20.0&quot;/&gt;</span></span><br><span class="line"><span class="comment"> &lt;/svg&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>我们可以这样考虑这个行为：当我们对存在容器调用 <code>addCircle</code> 时，方法是静态派发的，也就是说，它总是会使用 <code>Drawing</code> 的扩展。如果它是动态派发，那么它肯定需要将方法的接收者 <code>SVG</code> 类型考虑在内。</p>
<p>想要将 <code>addCircle</code> 变为动态派发，我们可以将它添加到协议定义里：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Drawing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">addEllipse</span><span class="params">(rect: CGRect, fill: UIColor)</span></span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">addRectangle</span><span class="params">(rect: CGRect, fill: UIColor)</span></span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">addCircle</span><span class="params">(center: CGPoint, radius: CGFloat, fill: UIColor)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="协议的两种类型"><a href="#协议的两种类型" class="headerlink" title="协议的两种类型"></a>协议的两种类型</h3><hr>
<p>带有关联类型的协议和普通的协议是不同的。对于那些在协议定义中在任何地方使用了 <code>Self</code> 的协议来说也是如此。Swift 3 中，这样的协议不能被当作独立的类型来使用。这个限制可能会在今后实现了完整的泛型系统后被移除，但是在那之前，我们都必须要面对和处理这个限制。</p>
<h4 id="类型抹消"><a href="#类型抹消" class="headerlink" title="类型抹消"></a>类型抹消</h4><p>我们可以将 <code>Drawing</code> 作为一个类型来使用。但是，对于 <code>IteratorProtocol</code> 来说，因为存在关联类型，这是不可能的 (至少现在还不可能)。编译器会给出这样的错误：“‘ <code>IteratorProtocol</code> ’ 协议含有 <code>Self</code> 或者关联类型，因此它只能被当作泛型约束使用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterator: <span class="type">IteratorProtocol</span> = <span class="type">ConstantIterator</span>() <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>这就是说，将 <code>IteratorProtocol</code> 是一个不完整的类型。我们必须为它指明关联类型，否则单是关联类型的协议是没有意义的。</p>
<blockquote>
<p>Swift 团队指出过他们想要支持泛用存在 (generalized existentials)。这个特性将允许那些含有关联类型的协议也可以被当作独立的值来使用，这样它们就可以用来进行类型抹消了。如果你想要了解未来这方面会如何发展，你可以在 <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160229/011666.html">Swift 泛型声明</a>一文中找到详细信息。  </p>
</blockquote>
<h3 id="带有-Self-的协议"><a href="#带有-Self-的协议" class="headerlink" title="带有 Self 的协议"></a>带有 Self 的协议</h3><hr>
<p>带有 Self 要求的协议在行为上和那些带有关联类型的协议很相似。最简单的带有 Self 的协议是 <code>Equatable</code>。它有一个 (运算符形式的) 方法，用来比较两个元素：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要为你自己的类型实现 <code>Equatable</code> 并不难。比如，我们有两个简单的 <code>MonetaryAmount</code> 结构体，我们可以通过比较它们的属性值来比较两个值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MonetaryAmount</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currency: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> amountInCents: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: MonetaryAmount, rhs: MonetaryAmount)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.currency == rhs.currency &amp;&amp;</span><br><span class="line">            lhs.amountInCents == rhs.amountInCents</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不能简单地用 <code>Equatable</code> 来作为类型进行变量声明：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误：因为 &#x27;Equatable&#x27; 中有 Self 或者关联类型的要求，</span></span><br><span class="line"><span class="comment">// 所以它只能被用作泛型约束</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="type">Equatable</span> = <span class="type">MonetaryAmount</span>(currency: <span class="string">&quot;EUR&quot;</span>, amountInCents: <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>这个关联类型所面临的问题是一样的：在这个 (不正确) 的声明中，我们并不清楚 Self 到底应该是什么。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift学习</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift 文档：Error Handling</title>
    <url>/2018/04/09/2018-04-09-RxSwift%20%E6%96%87%E6%A1%A3%EF%BC%9AError%20Handling/</url>
    <content><![CDATA[<h2 id="Error-Handling-错误处理"><a href="#Error-Handling-错误处理" class="headerlink" title="Error Handling - 错误处理"></a>Error Handling - 错误处理</h2><hr>
<p>一旦序列里面产出了一个 <code>error</code> 事件，整个序列将被终止。RxSwift 主要有两种错误处理机制：</p>
<ul>
<li>retry - 重试</li>
<li>catch - 恢复</li>
</ul>
<h4 id="retryWhen"><a href="#retryWhen" class="headerlink" title="retryWhen"></a>retryWhen</h4><p>如果请求 <code>JSON</code> 失败，我们需要等待5秒后进行重试操作，重试4次如果全部失败则抛出错误：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求 JSON 失败时，等待 5 秒后重试，</span></span><br><span class="line"><span class="comment">// 重试 4 次后仍然失败，就将错误抛出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> maxRetryCount = <span class="number">4</span>       <span class="comment">// 最多重试 4 次</span></span><br><span class="line"><span class="keyword">let</span> retryDelay: <span class="type">Double</span> = <span class="number">5</span>  <span class="comment">// 重试延时 5 秒</span></span><br><span class="line"></span><br><span class="line">rxJson</span><br><span class="line">    .retryWhen &#123; (rxError: <span class="type">Observable</span>&lt;<span class="type">Error</span>&gt;) -&gt; <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> rxError.flatMapWithIndex &#123; (error, index) -&gt; <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> index &lt; maxRetryCount <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="type">Observable</span>.error(error)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.timer(retryDelay, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(...)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>我们用 <code>flatMapWithIndex</code> 这个操作符，因为它可以给我们提供错误的索引数 <code>index</code>。然后用这个索引数判断是否超过最大重试数，如果超过了，就将错误抛出。如果没有超过，就等待 5 秒后重试。</p>
<h4 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h4><p>如果我们只是想给用户一个错误提示，我们可以自定义一个 <code>Result</code> 枚举来进行处理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义一个枚举类型 Result</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">T</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">Swift</span>.<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如如下的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当用户点击更新按钮时，</span></span><br><span class="line"><span class="comment">// 就立即取出修改后的用户信息。</span></span><br><span class="line"><span class="comment">// 然后发起网络请求，进行更新操作，</span></span><br><span class="line"><span class="comment">// 一旦操作失败就提示用户失败原因</span></span><br><span class="line"></span><br><span class="line">updateUserInfoButton.rx.tap</span><br><span class="line">    .withLatestFrom(rxUserInfo)</span><br><span class="line">    .flatMapLatest &#123; userInfo -&gt; <span class="type">Observable</span>&lt;<span class="type">Void</span>&gt; <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> update(userInfo)</span><br><span class="line">    &#125;</span><br><span class="line">    .observeOn(<span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .subscribe(onNext: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;用户信息更新成功&quot;</span>)</span><br><span class="line">    &#125;, onError: &#123; error <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;用户信息更新失败： \(error.localizedDescription)&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>修改之后：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">updateUserInfoButton.rx.tap</span><br><span class="line">    .withLatestFrom(rxUserInfo)</span><br><span class="line">    .flatMapLatest &#123; userInfo -&gt; <span class="type">Observable</span>&lt;<span class="type">Result</span>&lt;<span class="type">Void</span>&gt;&gt; <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> update(userInfo)</span><br><span class="line">            .<span class="built_in">map</span>(<span class="type">Result</span>.success)  <span class="comment">// 转换成 Result</span></span><br><span class="line">            .catchError &#123; error <span class="keyword">in</span> <span class="type">Observable</span>.just(<span class="type">Result</span>.failure(error)) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .observeOn(<span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .subscribe(onNext: &#123; result <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">switch</span> result &#123;           <span class="comment">// 处理 Result</span></span><br><span class="line">        <span class="keyword">case</span> .success:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;用户信息更新成功&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;用户信息更新失败： \(error.localizedDescription)&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>这样我们的错误事件被包装成了 <code>Result.failure(Error)</code> 元素。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift 文档：Observable &amp; Observer</title>
    <url>/2018/04/09/2018-04-09-RxSwift%20%E6%96%87%E6%A1%A3%EF%BC%9AObservable%20&amp;%20Observer/</url>
    <content><![CDATA[<h2 id="Observer-观察者"><a href="#Observer-观察者" class="headerlink" title="Observer - 观察者"></a>Observer - 观察者</h2><hr>
<h3 id="AnyObserver"><a href="#AnyObserver" class="headerlink" title="AnyObserver"></a>AnyObserver</h3><hr>
<p><code>AnyObserver</code> 可以用来描叙任意一种观察者。</p>
<p>例如：</p>
<p>打印网络请求结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">URLSession</span>.shared.rx.data(request: <span class="type">URLRequest</span>(url: url))</span><br><span class="line">    .subscribe(onNext: &#123; data <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Data Task Success with count: \(data.count)&quot;</span>)</span><br><span class="line">    &#125;, onError: &#123; error <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Data Task Error: \(error)&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>可以看作是：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer: <span class="type">AnyObserver</span>&lt;<span class="type">Data</span>&gt; = <span class="type">AnyObserver</span> &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next(<span class="keyword">let</span> data):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Data Task Success with count: \(data.count)&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Data Task Error: \(error)&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">URLSession</span>.shared.rx.data(request: <span class="type">URLRequest</span>(url: url))</span><br><span class="line">    .subscribe(observer)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>用户名提示语是否隐藏：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">usernameValid</span><br><span class="line">    .bind(to: usernameValidOutlet.rx.isHidden)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>可以看做是：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer: <span class="type">AnyObserver</span>&lt;<span class="type">Bool</span>&gt; = <span class="type">AnyObserver</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next(<span class="keyword">let</span> isHidden):</span><br><span class="line">        <span class="keyword">self</span>?.usernameValidOutlet.isHidden = isHidden</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usernameValid</span><br><span class="line">    .bind(to: observer)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><hr>
<p><code>Binder</code> 主要有以下两个特征：</p>
<ul>
<li>不会处理错误事件</li>
<li>确保绑定都是在给定 <code>Scheduler</code> 上执行（默认 <code>MainScheduler</code>）</li>
</ul>
<p>一旦产生错误事件，在调试环境下将执行 <code>fatalError</code>，在发布环境下将打印错误信息。</p>
<p>在 <code>AnyObserver</code> 时，我们举了一个这样的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer: <span class="type">AnyObserver</span>&lt;<span class="type">Bool</span>&gt; = <span class="type">AnyObserver</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next(<span class="keyword">let</span> isHidden):</span><br><span class="line">        <span class="keyword">self</span>?.usernameValidOutlet.isHidden = isHidden</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usernameValid</span><br><span class="line">    .bind(to: observer)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>由于这个观察者是一个 <strong>UI 观察者</strong>，所以它在响应事件时，只会处理 <code>next</code> 事件，并且更新 <code>UI</code> 的操作需要在主线程上执行。</p>
<p>因此一个更好的方案就是使用 <code>Binder</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer: <span class="type">Binder</span>&lt;<span class="type">Bool</span>&gt; = <span class="type">Binder</span>(usernameValidOutlet) &#123; (view, isHidden) <span class="keyword">in</span></span><br><span class="line">    view.isHidden = isHidden</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usernameValid</span><br><span class="line">    .bind(to: observer)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h4 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h4><p>由于页面是否隐藏是一个常用的观察者，所以应该让所有的 <code>UIView</code> 都提供这种观察者：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isHidden: <span class="type">Binder</span>&lt;<span class="type">Bool</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Binder</span>(<span class="keyword">self</span>.base) &#123; view, hidden <span class="keyword">in</span></span><br><span class="line">            view.isHidden = hidden</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usernameValid</span><br><span class="line">    .bind(to: usernameValidOutlet.rx.isHidden)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>这样你不必为每个 UI 控件单独创建该观察者。这就是 <code>usernameValidOutlet.rx.isHidden</code> 的由来，许多 <code>UI</code> 观察者 都是这样创建的：</p>
<ul>
<li>按钮是否可点击 <code>button.rx.isEnabled</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UIControl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEnabled: <span class="type">Binder</span>&lt;<span class="type">Bool</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Binder</span>(<span class="keyword">self</span>.base) &#123; control, value <span class="keyword">in</span></span><br><span class="line">            control.isEnabled = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>label</code> 的当前文本 <code>label.rx.text</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UILabel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> text: <span class="type">Binder</span>&lt;<span class="type">String?</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Binder</span>(<span class="keyword">self</span>.base) &#123; label, text <span class="keyword">in</span></span><br><span class="line">            label.text = text</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Observable-amp-Observer-既是可被监听的序列也是观察者"><a href="#Observable-amp-Observer-既是可被监听的序列也是观察者" class="headerlink" title="Observable &amp; Observer 既是可被监听的序列也是观察者"></a>Observable &amp; Observer 既是可被监听的序列也是观察者</h2><hr>
<p>在我们所遇到的事物中，有一部分非常特别。它们既是可被监听的序列也是观察者。</p>
<h3 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h3><hr>
<p><code>AsyncSubject</code> 将在源 <code>Observable</code> 产生完成事件后，发出最后一个元素（仅仅只有最后一个元素），如果源 <code>Observable</code> 没有发出任何元素，只有一个完成事件。那 <code>AsyncSubject</code> 也只有一个完成事件。<br>它会对随后的观察者发出最终元素。如果源 <code>Observable</code> 因为产生了一个 <code>error</code> 事件而中止， <code>AsyncSubject</code> 就不会发出任何元素，而是将这个 <code>error</code> 事件发送出来。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> subject = <span class="type">AsyncSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">&quot;Subscription: 1 Event:&quot;</span>, $<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">&quot;🐶&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🐱&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🐹&quot;</span>)</span><br><span class="line">subject.onCompleted()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🐹)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: completed</span></span><br></pre></td></tr></table></figure>

<h3 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h3><hr>
<p><code>PublishSubject</code> 将对观察者发送订阅后产生的元素，而在订阅前发出的元素将不会发送给观察者。如果你希望观察者接收到所有的元素，你可以通过使用 <code>Observable</code> 的 <code>create</code> 方法来创建 <code>Observable</code>，或者使用 <code>ReplaySubject</code>。</p>
<p>如果源 <code>Observable</code> 因为产生了一个 <code>error</code> 事件而中止， <code>PublishSubject</code> 就不会发出任何元素，而是将这个 <code>error</code> 事件发送出来。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> subject = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">&quot;Subscription: 1 Event:&quot;</span>, $<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">&quot;🐶&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🐱&quot;</span>)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">&quot;Subscription: 2 Event:&quot;</span>, $<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">&quot;🅰️&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🅱️&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🐶)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🐱)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🅰️)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🅰️)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🅱️)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🅱️)</span></span><br></pre></td></tr></table></figure>

<h3 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h3><hr>
<p><code>ReplaySubject</code> 将对观察者发送全部的元素，无论观察者是何时进行订阅的。</p>
<p>这里存在多个版本的 <code>ReplaySubject</code>，有的只会将最新的 <code>n</code> 个元素发送给观察者，有的只会将限制时间段内最新的元素发送给观察者。</p>
<p>如果把 <code>ReplaySubject</code> 当作观察者来使用，注意不要在多个线程调用 <code>onNext</code>, <code>onError</code> 或 <code>onCompleted</code>。这样会导致无序调用，将造成意想不到的结果。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> subject = <span class="type">ReplaySubject</span>&lt;<span class="type">String</span>&gt;.create(bufferSize: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">&quot;Subscription: 1 Event:&quot;</span>, $<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">&quot;🐶&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🐱&quot;</span>)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">&quot;Subscription: 2 Event:&quot;</span>, $<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">&quot;🅰️&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🅱️&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🐶)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🐱)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🐱)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🅰️)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🅰️)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🅱️)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🅱️)</span></span><br></pre></td></tr></table></figure>

<h3 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h3><hr>
<p>当观察者对 <code>BehaviorSubject</code> 进行订阅时，它会将源 <code>Observable</code> 中最新的元素发送出来（如果不存在最新的元素，就发出默认元素）。然后将随后产生的元素发送出来。<br>如果源 <code>Observable</code> 因为产生了一个 <code>error</code> 事件而中止， <code>BehaviorSubject</code> 就不会发出任何元素，而是将这个 <code>error</code> 事件发送出来。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> subject = <span class="type">BehaviorSubject</span>(value: <span class="string">&quot;🔴&quot;</span>)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">&quot;Subscription: 1 Event:&quot;</span>, $<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">&quot;🐶&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🐱&quot;</span>)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">&quot;Subscription: 2 Event:&quot;</span>, $<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">&quot;🅰️&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🅱️&quot;</span>)</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">&quot;Subscription: 3 Event:&quot;</span>, $<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">&quot;🍐&quot;</span>)</span><br><span class="line">subject.onNext(<span class="string">&quot;🍊&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🔴)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🐶)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🐱)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🐱)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🅰️)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🅰️)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🅱️)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🅱️)</span></span><br><span class="line"><span class="comment">// Subscription: 3 Event: next(🅱️)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🍐)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🍐)</span></span><br><span class="line"><span class="comment">// Subscription: 3 Event: next(🍐)</span></span><br><span class="line"><span class="comment">// Subscription: 1 Event: next(🍊)</span></span><br><span class="line"><span class="comment">// Subscription: 2 Event: next(🍊)</span></span><br><span class="line"><span class="comment">// Subscription: 3 Event: next(🍊)</span></span><br></pre></td></tr></table></figure>

<h3 id="ControlProperty"><a href="#ControlProperty" class="headerlink" title="ControlProperty"></a>ControlProperty</h3><hr>
<p><code>ControlProperty</code> 专门用于描述 UI 控件属性的，它具有以下特征：</p>
<ul>
<li>不会产生 <code>error</code> 事件</li>
<li>一定在 <code>MainScheduler</code> 订阅（主线程订阅）</li>
<li>一定在 <code>MainScheduler</code> 监听（主线程监听）</li>
<li>共享状态变化</li>
</ul>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift 文档：Observable</title>
    <url>/2018/04/09/2018-04-09-RxSwift%20%E6%96%87%E6%A1%A3%EF%BC%9AObservable/</url>
    <content><![CDATA[<h2 id="Observable-可被监听的序列"><a href="#Observable-可被监听的序列" class="headerlink" title="Observable - 可被监听的序列"></a>Observable - 可被监听的序列</h2><hr>
<h4 id="所有的事物都是序列"><a href="#所有的事物都是序列" class="headerlink" title="所有的事物都是序列"></a>所有的事物都是序列</h4><p><code>Observable</code> 可以用于描述元素异步产生的序列。这样我们生活中许多事物都可以通过它来表示。</p>
<h4 id="如何创建序列"><a href="#如何创建序列" class="headerlink" title="如何创建序列"></a>如何创建序列</h4><p>创建序列最直接的方法就是调用 <code>Observable.create</code>，然后在构建函数里面描述元素的产生过程。 <code>observer.onNext(0)</code> 就代表产生了一个元素，他的值是 <code>0</code>。后面又产生了 <code>9</code> 个元素分别是 <code>1, 2, ... 8, 9</code> 。最后，用 <code>observer.onCompleted()</code> 表示元素已经全部产生，没有更多元素了。</p>
<a id="more"></a>

<p>你可以用这种方式来封装功能组件，例如，闭包回调：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">JSON</span> = <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> json: <span class="type">Observable</span>&lt;<span class="type">JSON</span>&gt; = <span class="type">Observable</span>.create &#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: ...) &#123; data, <span class="keyword">_</span>, error <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> error == <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            observer.onError(error!)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> data = data,</span><br><span class="line">            <span class="keyword">let</span> jsonObject = <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: data, options: .mutableLeaves)</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                observer.onError(<span class="type">DataError</span>.cantParseJSON)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        observer.onNext(jsonObject)</span><br><span class="line">        observer.onCompleted()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    task.resume()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123; task.cancel() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在闭包回调中，如果任务失败，就调用 <code>observer.onError(error!)</code>。如果获取到目标元素，就调用 <code>observer.onNext(jsonObject)</code>。由于我们的这个序列只有一个元素，所以在成功获取到元素后，就直接调用 <code>observer.onCompleted()</code> 来表示任务结束。最后 <code>Disposables.create &#123; task.cancel() &#125;</code> 说明如果数据绑定被清除（订阅被取消）的话，就取消网络请求。</p>
<p>这样一来我们就将传统的闭包回调转换成序列了。然后可以用 <code>subscribe</code> 方法来响应这个请求的结果。</p>
<h3 id="Single"><a href="#Single" class="headerlink" title="Single"></a>Single</h3><hr>
<p><code>Single</code> 是 <code>Observable</code> 的另外一个版本。不像 <code>Observable</code> 可以发出多个元素，它要么只能发出一个元素，要么产生一个 <code>error</code> 事件。</p>
<ul>
<li>发出一个元素，或一个 error 事件</li>
<li>不会共享状态变化</li>
</ul>
<p>一个比较常见的例子就是执行 <code>HTTP</code> 请求，然后返回一个应答或错误。不过你也可以用 <code>Single</code> 来描述任何只有一个元素的序列。</p>
<h4 id="如何创建-Single"><a href="#如何创建-Single" class="headerlink" title="如何创建 Single"></a>如何创建 Single</h4><p>创建 <code>Single</code> 和创建 <code>Observable</code> 非常相似：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRepo</span><span class="params">(<span class="keyword">_</span> repo: String)</span></span> -&gt; <span class="type">Single</span>&lt;[<span class="type">String</span>: <span class="type">Any</span>]&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Single</span>&lt;[<span class="type">String</span>: <span class="type">Any</span>]&gt;.create &#123; single <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">&quot;https://api.github.com/repos/\(repo)&quot;</span>)!</span><br><span class="line">        <span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: url) &#123;</span><br><span class="line">            data, <span class="keyword">_</span>, error <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">                single(.error(error))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> data = data,</span><br><span class="line">                <span class="keyword">let</span> json = <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: data, options: .mutableLeaves),</span><br><span class="line">                <span class="keyword">let</span> result = json <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">Any</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">                    single(.error(<span class="type">DataError</span>.cantParseJSON))</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            single(.success(result))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        task.resume()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123; task.cancel() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>订阅提供一个 <code>SingleEvent</code> 的枚举：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingleEvent</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">Element</span>)</span><br><span class="line">    <span class="keyword">case</span> error(<span class="type">Swift</span>.<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意 <code>Single</code> 与普通 <code>Observable</code> 序列的事件枚举的不同。</strong></p>
<h3 id="Completable"><a href="#Completable" class="headerlink" title="Completable"></a>Completable</h3><hr>
<p><code>Completable</code> 是 <code>Observable</code> 的另外一个版本。不像 <code>Observable</code> 可以发出多个元素，它要么只能产生一个 <code>completed</code> 事件，要么产生一个 <code>error</code> 事件。</p>
<ul>
<li>发出零个元素</li>
<li>发出一个 <code>completed</code> 事件或者一个 <code>error</code> 事件</li>
<li>不会共享状态变化</li>
</ul>
<p><code>Completable</code> 适用于那种你只关心任务是否完成，而不需要在意任务返回值的情况。它和 <code>Observable&lt;Void&gt;</code> 有点相似。</p>
<h4 id="如何创建-Completable"><a href="#如何创建-Completable" class="headerlink" title="如何创建 Completable"></a>如何创建 Completable</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cacheLocally</span><span class="params">()</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; completable <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// Store some data locally</span></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> success <span class="keyword">else</span> &#123;</span><br><span class="line">            completable(.error(<span class="type">CacheError</span>.failedCaching))</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        completable(.completed)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>订阅提供一个 <code>CompletableEvent</code> 的枚举：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CompletableEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> error(<span class="type">Swift</span>.<span class="type">Error</span>)</span><br><span class="line">    <span class="keyword">case</span> completed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h3><hr>
<p><code>Maybe</code> 是 <code>Observable</code> 的另外一个版本。它介于 <code>Single</code> 和 <code>Completable</code> 之间，它要么只能发出一个元素，要么产生一个 <code>completed</code> 事件，要么产生一个 <code>error</code> 事件。</p>
<p>发出一个元素或者一个 <code>completed</code> 事件或者一个 <code>error</code> 事件<br>不会共享状态变化<br>如果你遇到那种可能需要发出一个元素，又可能不需要发出时，就可以使用 <code>Maybe</code>。</p>
<h4 id="如何创建-Maybe"><a href="#如何创建-Maybe" class="headerlink" title="如何创建 Maybe"></a>如何创建 Maybe</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateString</span><span class="params">()</span></span> -&gt; <span class="type">Maybe</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Maybe</span>&lt;<span class="type">String</span>&gt;.create &#123; maybe <span class="keyword">in</span></span><br><span class="line">        maybe(.success(<span class="string">&quot;RxSwift&quot;</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// OR</span></span><br><span class="line">        </span><br><span class="line">        maybe(.completed)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// OR</span></span><br><span class="line">        </span><br><span class="line">        maybe(.error(error))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h3><hr>
<p><code>Driver</code> 是一个精心准备的特征序列。它主要是为了简化 <code>UI</code> 层的代码。不过如果你遇到的序列具有以下特征，你也可以使用它：</p>
<ul>
<li>不会产生 <code>error</code> 事件</li>
<li>一定在 <code>MainScheduler</code> 监听（主线程监听）</li>
<li>共享状态变化</li>
</ul>
<p>这些都是驱动 <code>UI</code> 的序列所具有的特征。</p>
<h4 id="为什么要使用-Driver-？"><a href="#为什么要使用-Driver-？" class="headerlink" title="为什么要使用 Driver ？"></a>为什么要使用 Driver ？</h4><p>我们举个例子来说明一下，为什么要使用 <code>Driver</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> results = query.rx.text</span><br><span class="line">    .throttle(<span class="number">0.3</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .flatMapLatest &#123; query <span class="keyword">in</span></span><br><span class="line">        fetchAutoCompleteItems(query)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="string">&quot;\($0.count)&quot;</span> &#125;</span><br><span class="line">    .bind(to: resultCount.rx.text)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .bind(to: resultsTableView.rx.items(cellIdentifier: <span class="string">&quot;Cell&quot;</span>)) &#123;</span><br><span class="line">        (<span class="keyword">_</span>, result, cell) <span class="keyword">in</span></span><br><span class="line">        cell.textLabel?.text = <span class="string">&quot;\(result)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>这段代码的主要目的是：</p>
<ul>
<li>取出用户输入稳定后的内容</li>
<li>向服务器请求一组结果</li>
<li>将返回的结果绑定到两个 <code>UI</code> 元素上：<code>tableView</code> 和 显示结果数量的<code>label</code></li>
</ul>
<p>那么这里存在什么问题？</p>
<ul>
<li>如果 <code>fetchAutoCompleteItems</code> 的序列产生了一个错误（网络请求失败），这个错误将取消所有绑定，当用户输入一个新的关键字时，是无法发起新的网络请求。</li>
<li>如果 <code>fetchAutoCompleteItems</code> 在后台返回序列，那么刷新页面也会在后台进行，这样就会出现异常崩溃。</li>
<li>返回的结果被绑定到两个 <code>UI</code> 元素上。那就意味着，每次用户输入一个新的关键字时，就会分别为两个 <code>UI</code> 元素发起 <code>HTTP</code> 请求，这并不是我们想要的结果。</li>
</ul>
<p>一个更好的方案是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> results = query.rx.text</span><br><span class="line">    .throttle(<span class="number">0.3</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .flatMapLatest &#123; query <span class="keyword">in</span></span><br><span class="line">        fetchAutoCompleteItems(query)</span><br><span class="line">            .observeOn(<span class="type">MainScheduler</span>.instance)  <span class="comment">// 结果在主线程返回</span></span><br><span class="line">            .catchErrorJustReturn([])           <span class="comment">// 错误被处理了，这样至少不会终止整个序列</span></span><br><span class="line">    &#125;</span><br><span class="line">    .share(replay: <span class="number">1</span>)                             <span class="comment">// HTTP 请求是被共享的</span></span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="string">&quot;\($0.count)&quot;</span> &#125;</span><br><span class="line">    .bind(to: resultCount.rx.text)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .bind(to: resultsTableView.rx.items(cellIdentifier: <span class="string">&quot;Cell&quot;</span>)) &#123;</span><br><span class="line">        (<span class="keyword">_</span>, result, cell) <span class="keyword">in</span></span><br><span class="line">        cell.textLabel?.text = <span class="string">&quot;\(result)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下是使用 <code>Driver</code> 优化后的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> results = query.rx.text.asDriver()        <span class="comment">// 将普通序列转换为 Driver</span></span><br><span class="line">    .throttle(<span class="number">0.3</span>, scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .flatMapLatest &#123; query <span class="keyword">in</span></span><br><span class="line">        fetchAutoCompleteItems(query)</span><br><span class="line">            .asDriver(onErrorJustReturn: [])  <span class="comment">// 仅仅提供发生错误时的备选返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="string">&quot;\($0.count)&quot;</span> &#125;</span><br><span class="line">    .drive(resultCount.rx.text)               <span class="comment">// 这里改用 `drive` 而不是 `bindTo`</span></span><br><span class="line">    .disposed(by: disposeBag)                 <span class="comment">// 这样可以确保必备条件都已经满足了</span></span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .drive(resultsTableView.rx.items(cellIdentifier: <span class="string">&quot;Cell&quot;</span>)) &#123;</span><br><span class="line">        (<span class="keyword">_</span>, result, cell) <span class="keyword">in</span></span><br><span class="line">        cell.textLabel?.text = <span class="string">&quot;\(result)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>任何可被监听的序列都可以被转换为 <code>Driver</code>，只要他满足 3 个条件：</p>
<ul>
<li>不会产生 <code>error</code> 事件</li>
<li>一定在 <code>MainScheduler</code> 监听（主线程监听）</li>
<li>共享状态变化</li>
</ul>
<p>那么要如何确定条件都被满足？通过 Rx 操作符来进行转换。<code>asDriver(onErrorJustReturn: [])</code> 相当于以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> safeSequence = xs</span><br><span class="line">    .observeOn(<span class="type">MainScheduler</span>.instance)       <span class="comment">// 主线程监听</span></span><br><span class="line">    .catchErrorJustReturn(onErrorJustReturn) <span class="comment">// 无法产生错误</span></span><br><span class="line">    .share(replay: <span class="number">1</span>, scope: .whileConnected)<span class="comment">// 共享状态变化</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">Driver</span>(raw: safeSequence)           <span class="comment">// 封装</span></span><br></pre></td></tr></table></figure>

<p>最后使用 <code>drive</code> 而不是 <code>bindTo</code></p>
<p><code>drive</code> 方法只能被 <code>Driver</code> 调用。这意味着，如果你发现代码所存在 <code>drive</code>，那么这个序列不会产生错误事件并且一定在主线程监听。这样你可以安全的绑定 <code>UI</code> 元素。</p>
<h3 id="ControlEvent"><a href="#ControlEvent" class="headerlink" title="ControlEvent"></a>ControlEvent</h3><hr>
<p><code>ControlEvent</code> 专门用于描述 UI 控件所产生的事件，它具有以下特征：</p>
<ul>
<li>不会产生 <code>error</code> 事件</li>
<li>一定在 <code>MainScheduler</code> 订阅（主线程订阅）</li>
<li>一定在 <code>MainScheduler</code> 监听（主线程监听）</li>
<li>共享状态变化</li>
</ul>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift 文档：Schedulers</title>
    <url>/2018/04/09/2018-04-09-RxSwift%20%E6%96%87%E6%A1%A3%EF%BC%9ASchedulers/</url>
    <content><![CDATA[<h2 id="Schedulers-调度器"><a href="#Schedulers-调度器" class="headerlink" title="Schedulers - 调度器"></a>Schedulers - 调度器</h2><hr>
<p><code>Schedulers</code> 是 Rx 实现多线程的核心模块，它主要用于控制任务在哪个线程或队列运行。</p>
<p>如果你曾经使用过 <code>GCD</code>， 那你对以下代码应该不会陌生：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后台取得数据，主线程处理结果</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global(qos: .userInitiated).async &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">try</span>? <span class="type">Data</span>(contentsOf: url)</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="keyword">self</span>.data = data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>如果用 <code>RxSwift</code> 来实现，大致是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rxData: <span class="type">Observable</span>&lt;<span class="type">Data</span>&gt; = ...</span><br><span class="line">    </span><br><span class="line">rxData</span><br><span class="line">    .subscribeOn(<span class="type">ConcurrentDispatchQueueScheduler</span>(qos: .userInitiated))</span><br><span class="line">    .observeOn(<span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .subscribe(onNext: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] data <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>?.data = data</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h4 id="使用-subscribeOn"><a href="#使用-subscribeOn" class="headerlink" title="使用 subscribeOn"></a>使用 <code>subscribeOn</code></h4><p>我们用 <code>subscribeOn</code> 来决定数据序列的构建函数在哪个 <code>Scheduler</code> 上运行。以上例子中，由于获取 <code>Data</code> 需要花很长的时间，所以用 <code>subscribeOn</code> 切换到后台 <code>Scheduler</code> 来获取 <code>Data</code>。这样可以避免主线程被阻塞。</p>
<h4 id="使用-observeOn"><a href="#使用-observeOn" class="headerlink" title="使用 observeOn"></a>使用 <code>observeOn</code></h4><p>我们用 <code>observeOn</code> 来决定在哪个 <code>Scheduler</code> 监听这个数据序列。以上例子中，通过使用 <code>observeOn</code> 方法切换到主线程来监听并且处理结果。</p>
<p>一个比较典型的例子就是，在后台发起网络请求，然后解析数据，最后在主线程刷新页面。你就可以先用 <code>subscribeOn</code> 切到后台去发送请求并解析数据，最后用 <code>observeOn</code> 切换到主线程更新页面。</p>
<h4 id="MainScheduler"><a href="#MainScheduler" class="headerlink" title="MainScheduler"></a>MainScheduler</h4><p><code>MainScheduler</code> 代表主线程。如果你需要执行一些和 UI 相关的任务，就需要切换到该 <code>Scheduler</code> 运行。</p>
<h4 id="SerialDispatchQueueScheduler"><a href="#SerialDispatchQueueScheduler" class="headerlink" title="SerialDispatchQueueScheduler"></a>SerialDispatchQueueScheduler</h4><p><code>SerialDispatchQueueScheduler</code> 抽象了窜行 <code>DispatchQueue</code>。如果你需要执行一些窜行任务，可以切换到这个 <code>Scheduler</code> 运行。</p>
<h4 id="ConcurrentDispatchQueueScheduler"><a href="#ConcurrentDispatchQueueScheduler" class="headerlink" title="ConcurrentDispatchQueueScheduler"></a>ConcurrentDispatchQueueScheduler</h4><p><code>ConcurrentDispatchQueueScheduler</code> 抽象了并行 <code>DispatchQueue</code>。如果你需要执行一些并发任务，可以切换到这个 <code>Scheduler</code> 运行。</p>
<h4 id="OperationQueueScheduler"><a href="#OperationQueueScheduler" class="headerlink" title="OperationQueueScheduler"></a>OperationQueueScheduler</h4><p><code>OperationQueueScheduler</code> 抽象了 <code>NSOperationQueue</code>。</p>
<p>它具备 <code>NSOperationQueue</code> 的一些特点，例如，你可以通过设置 <code>maxConcurrentOperationCount</code>，来控制同时执行并发任务的最大数量。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift 文档：函数响应式编程</title>
    <url>/2018/04/09/2018-04-09-RxSwift%20%E6%96%87%E6%A1%A3%EF%BC%9A%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="函数响应式编程"><a href="#函数响应式编程" class="headerlink" title="函数响应式编程"></a>函数响应式编程</h3><hr>
<p>函数响应式编程是种编程范式。它是通过构建函数操作数据序列，然后对这些序列做出响应的编程方式。它结合了函数式编程以及响应式编程。</p>
<h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><p><strong>函数式编程是种编程范式，它需要我们将函数作为参数传递，或者作为返回值返还。我们可以通过组合不同的函数来得到想要的结果。</strong></p>
<p>函数试编程的优点：</p>
<ul>
<li>灵活</li>
<li>高复用</li>
<li>简洁</li>
<li>易维护</li>
<li>适应各种需求变化</li>
</ul>
<h4 id="函数式编程-gt-函数响应式编程"><a href="#函数式编程-gt-函数响应式编程" class="headerlink" title="函数式编程 -&gt; 函数响应式编程"></a>函数式编程 -&gt; 函数响应式编程</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设用户在进入页面到离开页面期间，总共点击按钮 3 次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮点击序列</span></span><br><span class="line"><span class="keyword">let</span> taps: <span class="type">Array</span>&lt;<span class="type">Void</span>&gt; = [(), (), ()]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次点击后弹出提示框</span></span><br><span class="line">taps.forEach &#123; showAlert() &#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>这样处理点击事件是非常理想的，但是问题是这个序列里面的元素（点击事件）是异步产生的，传统序列是无法描叙这种元素异步产生的情况。为了解决这个问题，于是就产生了可被监听的序列 <code>Observable&lt;Element&gt;</code> 。它也是一个序列，只不过这个序列里面的元素可以是同步产生的，也可以是异步产生的:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按钮点击序列</span></span><br><span class="line"><span class="keyword">let</span> taps: <span class="type">Observable</span>&lt;<span class="type">Void</span>&gt; = button.rx.tap.asObservable()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次点击后弹出提示框</span></span><br><span class="line">taps.subscribe(onNext: &#123; showAlert() &#125;)</span><br></pre></td></tr></table></figure>

<p>这里 <code>taps</code> 就是按钮点击事件的序列。然后我们通过弹出提示框，来对每一次点击事件做出响应。这种编程方式叫做响应式编程。我们结合函数式编程以及响应式编程就得到了函数响应式编程。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">passwordOutlet.rx.text.orEmpty</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span>.characters.<span class="built_in">count</span> &gt;= minimalPasswordLength &#125;</span><br><span class="line">    .bind(to: passwordValidOutlet.rx.isHidden)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p><strong>我们通过不同的构建函数，来创建所需要的数据序列。最后通过适当的方式来响应这个序列。这就是函数响应式编程。</strong></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift 文档：如何选择操作符？</title>
    <url>/2018/04/11/2018-04-11-RxSwift%20%E6%96%87%E6%A1%A3%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="我想要创建一个-Observable"><a href="#我想要创建一个-Observable" class="headerlink" title="我想要创建一个 Observable"></a>我想要创建一个 <code>Observable</code></h3><ul>
<li>产生特定的一个元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/just.html">just</a><ul>
<li>经过一段延时： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html">timer</a></li>
</ul>
</li>
<li>从一个序列拉取元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/from.html">from</a></li>
<li>重复的产生某一个元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/repeatElement.html">repeatElement</a></li>
<li>存在自定义逻辑： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/create.html">create</a></li>
<li>每次订阅时产生： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/deferred.html">deferred</a></li>
<li>每隔一段时间，发出一个元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/interval.html">interval</a><ul>
<li>在一段延时后： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html">timer</a></li>
</ul>
</li>
<li>一个空序列，只有一个完成事件： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/empty.html">empty</a></li>
<li>一个任何事件都没有产生的序列： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/never.html">never</a></li>
</ul>
<a id="more"></a>

<h3 id="我想要创建一个-Observable-通过组合其他的-Observables"><a href="#我想要创建一个-Observable-通过组合其他的-Observables" class="headerlink" title="我想要创建一个 Observable 通过组合其他的 Observables"></a>我想要创建一个 <code>Observable</code> 通过组合其他的 <code>Observables</code></h3><ul>
<li>任意一个 <code>Observable</code> 产生了元素，就发出这个元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/merge.html">merge</a></li>
<li>让这些 <code>Observables</code> 一个接一个的发出元素，当上一个 <code>Observable</code> 元素发送完毕后，下一个 <code>Observable</code> 才能开始发出元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concat.html">concat</a></li>
<li>组合多个 <code>Observables</code> 的元素<ul>
<li>当每一个 <code>Observable</code> 都发出一个新的元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/zip.html">zip</a></li>
<li>当任意一个 <code>Observable</code> 发出一个新的元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/combineLatest.html">combineLatest</a></li>
</ul>
</li>
</ul>
<h3 id="我想要转换-Observable的元素后，再将它们发出来"><a href="#我想要转换-Observable的元素后，再将它们发出来" class="headerlink" title="我想要转换 Observable的元素后，再将它们发出来"></a>我想要转换 <code>Observable</code>的元素后，再将它们发出来</h3><ul>
<li>对每个元素直接转换： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/map.html">map</a></li>
<li>转换到另一个 <code>Observable</code> ： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMap.html">flatMap</a><ul>
<li>只接收最新的元素转换的 <code>Observable</code> 所产生的元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMapLatest.html">flatMapLatest</a></li>
<li>每一个元素转换的 <code>Observable</code> 按顺序产生元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concatMap.html">concatMap</a></li>
</ul>
</li>
<li>基于所有遍历过的元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html">scan</a></li>
</ul>
<h3 id="我想要将产生的每一个元素，拖延一段时间后再发出"><a href="#我想要将产生的每一个元素，拖延一段时间后再发出" class="headerlink" title="我想要将产生的每一个元素，拖延一段时间后再发出"></a>我想要将产生的每一个元素，拖延一段时间后再发出</h3><ul>
<li><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delay.html">delay</a></li>
</ul>
<h3 id="我想要将产生的事件封装成元素发送出来"><a href="#我想要将产生的事件封装成元素发送出来" class="headerlink" title="我想要将产生的事件封装成元素发送出来"></a>我想要将产生的事件封装成元素发送出来</h3><ul>
<li>将他们封装成 <code>Event&lt;Element&gt;</code> ： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/materialize.html">materialize</a><ul>
<li>然后解封出来： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/dematerialize.html">dematerialize</a></li>
</ul>
</li>
</ul>
<h3 id="我想要忽略掉所有的-next-事件，只接收-completed-和-error-事件"><a href="#我想要忽略掉所有的-next-事件，只接收-completed-和-error-事件" class="headerlink" title="我想要忽略掉所有的 next 事件，只接收 completed 和 error 事件"></a>我想要忽略掉所有的 <code>next</code> 事件，只接收 <code>completed</code> 和 <code>error</code> 事件</h3><ul>
<li> <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/ignoreElements.html">ignoreElements</a></li>
</ul>
<h3 id="我想创建一个新的-Observable-在原有的序列前面加入一些元素"><a href="#我想创建一个新的-Observable-在原有的序列前面加入一些元素" class="headerlink" title="我想创建一个新的 Observable 在原有的序列前面加入一些元素"></a>我想创建一个新的 <code>Observable</code> 在原有的序列前面加入一些元素</h3><ul>
<li><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/startWith.html">startWith</a></li>
</ul>
<h3 id="我想从-Observable-中收集元素，缓存这些元素之后在发出"><a href="#我想从-Observable-中收集元素，缓存这些元素之后在发出" class="headerlink" title="我想从 Observable 中收集元素，缓存这些元素之后在发出"></a>我想从 <code>Observable</code> 中收集元素，缓存这些元素之后在发出</h3><ul>
<li><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/buffer.html">buffer</a></li>
</ul>
<h3 id="我想将-Observable-拆分成多个-Observables"><a href="#我想将-Observable-拆分成多个-Observables" class="headerlink" title="我想将 Observable 拆分成多个 Observables"></a>我想将 <code>Observable</code> 拆分成多个 <code>Observables</code></h3><ul>
<li> <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/window.html">window</a></li>
<li>基于元素的共同特征： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/groupBy.html">groupBy</a></li>
</ul>
<h3 id="我想只接收-Observable中特定的元素"><a href="#我想只接收-Observable中特定的元素" class="headerlink" title="我想只接收 Observable中特定的元素"></a>我想只接收 <code>Observable</code>中特定的元素</h3><ul>
<li>发出唯一的元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/single.html">single</a></li>
</ul>
<h3 id="我想重新从-Observable中发出某些元素"><a href="#我想重新从-Observable中发出某些元素" class="headerlink" title="我想重新从 Observable中发出某些元素"></a>我想重新从 <code>Observable</code>中发出某些元素</h3><ul>
<li>通过判定条件过滤出一些元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/filter.html">filter</a></li>
<li>仅仅发出头几个元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html">take</a></li>
<li>仅仅发出尾部的几个元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeLast.html">takeLast</a></li>
<li>仅仅发出第 n 个元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/elementAt.html">elementAt</a></li>
<li>跳过头几个元素<ul>
<li>跳过头 n 个元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html">skip</a></li>
<li>跳过头几个满足判定的元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html">skipWhile</a> ， <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html">skipWhileWithIndex</a></li>
<li>跳过某段时间内产生的头几个元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html">skip</a></li>
<li>跳过头几个元素直到另一个 <code>Observable</code> 发出一个元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipUntil.html">skipUntil</a></li>
</ul>
</li>
<li>只取头几个元素<ul>
<li>只取头几个满足判定的元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html">takeWhile</a> ， <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html">takeWhileWithIndex</a></li>
<li>只取某段时间内产生的头几个元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html">take</a></li>
<li>只取头几个元素直到另一个 <code>Observable</code> 发出一个元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeUntil.html">takeUntil</a></li>
</ul>
</li>
<li>周期性的对 <code>Observable</code> 抽样： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/sample.html">sample</a></li>
<li>发出那些元素，这些元素产生后的特定的时间内，没有新的元素产生： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/debounce.html">debounce</a></li>
<li>直到元素的值发生变化，才发出新的元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html">distinctUntilChanged</a><ul>
<li>并提供元素是否相等的判定函数： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html">distinctUntilChanged</a></li>
</ul>
</li>
<li>在开始发出元素时，延时后进行订阅： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delaySubscription.html">delaySubscription</a></li>
</ul>
<h3 id="我想要从一些-Observables-中，只取第一个产生元素的-Observable"><a href="#我想要从一些-Observables-中，只取第一个产生元素的-Observable" class="headerlink" title="我想要从一些 Observables 中，只取第一个产生元素的 Observable"></a>我想要从一些 <code>Observables</code> 中，只取第一个产生元素的 <code>Observable</code></h3><ul>
<li> <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/amb.html">amb</a></li>
</ul>
<h3 id="我想评估-Observable的全部元素"><a href="#我想评估-Observable的全部元素" class="headerlink" title="我想评估 Observable的全部元素"></a>我想评估 <code>Observable</code>的全部元素</h3><ul>
<li>并且对每个元素应用聚合方法，待所有元素都应用聚合方法后，发出结果： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/reduce.html">reduce</a></li>
<li>并且对每个元素应用聚合方法，每次应用聚合方法后，发出结果： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html">scan</a></li>
</ul>
<h3 id="我想把-Observable转换为其他的数据结构：as…"><a href="#我想把-Observable转换为其他的数据结构：as…" class="headerlink" title="我想把 Observable转换为其他的数据结构：as…"></a>我想把 <code>Observable</code>转换为其他的数据结构：as…</h3><h3 id="我想在某个-Scheduler-应用操作符"><a href="#我想在某个-Scheduler-应用操作符" class="headerlink" title="我想在某个 Scheduler 应用操作符"></a>我想在某个 <a href="rxswift_core/schedulers.html">Scheduler</a> 应用操作符</h3><ul>
<li><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/subscribeOn.html">subscribeOn</a></li>
<li>在某个 <a href="rxswift_core/schedulers.html">Scheduler</a> 监听： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/observeOn.html">observeOn</a></li>
</ul>
<h3 id="我想要-Observable-发生某个事件时-采取某个行动"><a href="#我想要-Observable-发生某个事件时-采取某个行动" class="headerlink" title="我想要 Observable 发生某个事件时, 采取某个行动"></a>我想要 <code>Observable</code> 发生某个事件时, 采取某个行动</h3><ul>
<li><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/do.html">do</a></li>
</ul>
<h3 id="我想要-Observable-发出一个-error-事件"><a href="#我想要-Observable-发出一个-error-事件" class="headerlink" title="我想要 Observable 发出一个 error 事件"></a>我想要 <code>Observable</code> 发出一个 <code>error</code> 事件</h3><ul>
<li><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/error.html">error</a></li>
<li>如果规定时间内没有产生元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html">timeout</a></li>
</ul>
<h3 id="我想要-Observable发生错误时，优雅的恢复"><a href="#我想要-Observable发生错误时，优雅的恢复" class="headerlink" title="我想要 Observable发生错误时，优雅的恢复"></a>我想要 <code>Observable</code>发生错误时，优雅的恢复</h3><ul>
<li>如果规定时间内没有产生元素，就切换到备选 <code>Observable</code> ： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html">timeout</a></li>
<li>如果产生错误，将错误替换成某个元素 ： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html">catchErrorJustReturn</a></li>
<li>如果产生错误，就切换到备选 <code>Observable</code> ： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html">catchError</a></li>
<li>如果产生错误，就重试 ： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/retry.html">retry</a></li>
</ul>
<h3 id="我创建一个-Disposable-资源，使它与-Observable-具有相同的寿命"><a href="#我创建一个-Disposable-资源，使它与-Observable-具有相同的寿命" class="headerlink" title="我创建一个 Disposable 资源，使它与 Observable 具有相同的寿命"></a>我创建一个 <code>Disposable</code> 资源，使它与 <code>Observable</code> 具有相同的寿命</h3><ul>
<li><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/using.html">using</a></li>
</ul>
<h3 id="我创建一个-Observable-，直到我通知它可以产生元素后，才能产生元素"><a href="#我创建一个-Observable-，直到我通知它可以产生元素后，才能产生元素" class="headerlink" title="我创建一个 Observable ，直到我通知它可以产生元素后，才能产生元素"></a>我创建一个 <code>Observable</code> ，直到我通知它可以产生元素后，才能产生元素</h3><ul>
<li><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/publish.html">publish</a></li>
<li>并且，就算是在产生元素后订阅，也要发出全部元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/replay.html">replay</a></li>
<li>并且，一旦所有观察者取消观察，他就被释放掉： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/refCount.html">refCount</a></li>
<li>通知它可以产生元素了： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/connect.html">connect</a></li>
</ul>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift 文档：操作符</title>
    <url>/2018/04/11/2018-04-11-RxSwift%20%E6%96%87%E6%A1%A3%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="just-、-from-和-of"><a href="#just-、-from-和-of" class="headerlink" title="just 、 from 和 of"></a>just 、 from 和 of</h2><hr>
<p><code>just</code> 和 <code>from</code> 都能够将元素转化为 <code>Observable</code> 但是他们有本质的区别：</p>
<h3 id="just"><a href="#just" class="headerlink" title="just"></a>just</h3><p>创建 <code>Observable</code> 发出<strong>唯一的一个元素</strong>。 <code>just</code> 操作符将某一个元素转换为 <code>Observable</code>。</p>
<p>示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oJust = <span class="type">Observable</span>.just([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">oJust.subscribe(onNext: &#123;</span><br><span class="line">    <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.dispose()</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>相当于</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oJust = <span class="type">Observable</span>&lt;<span class="type">Array</span>&lt;<span class="type">Int</span>&gt;&gt;.create &#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    observer.onNext([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="from"><a href="#from" class="headerlink" title="from"></a>from</h3><p>将其他类型或者数据结构转换为 <code>Observable</code> 。当你在使用 <code>Observable</code> 时，如果能够直接将其他类型转换为 <code>Observable</code>，这将是非常省事的。<code>from</code> 操作符就提供了这种功能。</p>
<p>示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oFrom = <span class="type">Observable</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">oFrom.subscribe(onNext: &#123;</span><br><span class="line">    <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.dispose()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oFrom = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.create &#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="number">1</span>)</span><br><span class="line">    observer.onNext(<span class="number">2</span>)</span><br><span class="line">    observer.onNext(<span class="number">3</span>)</span><br><span class="line">    observer.onNext(<span class="number">4</span>)</span><br><span class="line">    observer.onNext(<span class="number">5</span>)</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将一个值转化为 <code>Observable</code> 可以用 <code>Observable.from(optional: &lt;_?&gt;)</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">optional</span>: <span class="type">Int?</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> value = <span class="type">Observable</span>.from(<span class="keyword">optional</span>: <span class="keyword">optional</span>)</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">optional</span>: <span class="type">Int?</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> value = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.create &#123; observer <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> element = <span class="keyword">optional</span> &#123;</span><br><span class="line">        observer.onNext(element)</span><br><span class="line">    &#125;</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="of"><a href="#of" class="headerlink" title="of"></a>of</h3><p>能将多个元素转化为 <code>Observable</code> 。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).subscribe(onNext: &#123;</span><br><span class="line">    <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.dispose()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h2 id="concat、combineLatest-和-zip"><a href="#concat、combineLatest-和-zip" class="headerlink" title="concat、combineLatest 和 zip"></a>concat、combineLatest 和 zip</h2><hr>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>让两个或多个 <code>Observables</code> <strong>按顺序</strong>串连起来。</p>
<p><code>concat</code> 操作符将多个 <code>Observables</code> 按顺序串联起来，当前一个 <code>Observable</code> 元素发送完毕后，后一个 <code>Observable</code> 才可以开始发出元素。</p>
<p><code>concat</code> 将等待前一个 <code>Observable</code> 产生完成事件后，才对后一个 <code>Observable</code> 进行订阅。如果后一个是“热” <code>Observable</code> ，在它前一个 <code>Observable</code> 产生完成事件前，所产生的元素将不会被发送出来。</p>
<p> <strong><code>startWith</code> 和它十分相似。但是 <code>startWith</code> 不是在后面添加元素，而是在前面插入元素。</strong></p>
<p><code>merge</code> 和它也是十分相似。**<code>merge</code> 并不是将多个 <code>Observables</code> 按顺序串联起来，而是将他们合并到一起，不需要 <code>Observables</code> 按先后顺序发出元素。**</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subject1 = <span class="type">BehaviorSubject</span>(value: <span class="string">&quot;🍎&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> subject2 = <span class="type">BehaviorSubject</span>(value: <span class="string">&quot;🐶&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> variable = <span class="type">Variable</span>(subject1)</span><br><span class="line"></span><br><span class="line">variable.asObservable()</span><br><span class="line">    .concat()</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject1.onNext(<span class="string">&quot;🍐&quot;</span>)</span><br><span class="line">subject1.onNext(<span class="string">&quot;🍊&quot;</span>)</span><br><span class="line"></span><br><span class="line">variable.value = subject2</span><br><span class="line"></span><br><span class="line">subject2.onNext(<span class="string">&quot;I would be ignored&quot;</span>)</span><br><span class="line">subject2.onNext(<span class="string">&quot;🐱&quot;</span>)</span><br><span class="line"></span><br><span class="line">subject1.onCompleted()</span><br><span class="line"></span><br><span class="line">subject2.onNext(<span class="string">&quot;🐭&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// next(🍎)</span></span><br><span class="line"><span class="comment">// next(🍐)</span></span><br><span class="line"><span class="comment">// next(🍊)</span></span><br><span class="line"><span class="comment">// next(🐱)</span></span><br><span class="line"><span class="comment">// next(🐭)</span></span><br></pre></td></tr></table></figure>

<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>通过一个函数将多个 <code>Observables</code> 的元素组合起来，然后将每一个组合的结果发出来。</p>
<p><img src="/my_pictures/zip.png"></p>
<p><code>zip</code> 操作符将多个(最多不超过8个) <code>Observables</code> 的元素通过一个函数组合起来，然后将这个组合的结果发出来。它会严格的按照序列的索引数进行组合。例如，返回的 <code>Observable</code> 的第一个元素，是由每一个源 <code>Observables</code> 的第一个元素组合出来的。它的第二个元素 ，是由每一个源 <code>Observables</code> 的第二个元素组合出来的。它的第三个元素 ，是由每一个源 <code>Observables</code> 的第三个元素组合出来的，以此类推。它的元素数量等于源 <code>Observables</code> 中元素数量最少的那个。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> first = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> second = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.<span class="built_in">zip</span>(first, second) &#123; $<span class="number">0</span> + $<span class="number">1</span> &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">first.onNext(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">second.onNext(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">second.onNext(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">second.onNext(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">second.onNext(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;5&quot;</span>) <span class="comment">// 并没有输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1A</span></span><br><span class="line"><span class="comment">// 2B</span></span><br><span class="line"><span class="comment">// 3C</span></span><br><span class="line"><span class="comment">// 4D</span></span><br></pre></td></tr></table></figure>

<h3 id="combineLatest（可与-zip-比较学习）"><a href="#combineLatest（可与-zip-比较学习）" class="headerlink" title="combineLatest（可与 zip 比较学习）"></a>combineLatest（可与 zip 比较学习）</h3><p>当多个 <code>Observables</code> 中任何一个发出一个元素，就发出一个元素。这个元素是由这些 <code>Observables</code> 中最新的元素，通过一个函数组合起来的。</p>
<p><img src="/my_pictures/combinelatest.png"></p>
<p><code>combineLatest</code> 操作符将多个 <code>Observables</code> 中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。这些源 <code>Observables</code> 中任何一个发出一个元素，他都会发出一个元素（前提是，这些 <code>Observables</code> 曾经发出过元素）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> second = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.combineLatest(first, second) &#123; $<span class="number">0</span> + $<span class="number">1</span> &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">first.onNext(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">second.onNext(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">second.onNext(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">second.onNext(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">second.onNext(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1A</span></span><br><span class="line"><span class="comment">// 2A</span></span><br><span class="line"><span class="comment">// 2B</span></span><br><span class="line"><span class="comment">// 2C</span></span><br><span class="line"><span class="comment">// 2D</span></span><br><span class="line"><span class="comment">// 3D</span></span><br><span class="line"><span class="comment">// 4D</span></span><br></pre></td></tr></table></figure>

<h2 id="flatMap-和-flatMapLatest"><a href="#flatMap-和-flatMapLatest" class="headerlink" title="flatMap 和 flatMapLatest"></a>flatMap 和 flatMapLatest</h2><hr>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>将 <code>Observable</code> 的元素转换成其他的 <code>Observable</code>，然后将这些 <code>Observables</code> 合并。</p>
<p><code>flatMap</code> 操作符将源 <code>Observable</code> 的每一个元素应用一个转换方法，将他们转换成 <code>Observables</code>。 然后将这些 <code>Observables</code> 的元素合并之后再发送出来。</p>
<p>这个操作符是非常有用的，例如，当 <code>Observable</code> 的元素本生拥有其他的 <code>Observable</code> 时，你可以将所有子 <code>Observables</code> 的元素发送出来。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> first = <span class="type">BehaviorSubject</span>(value: <span class="string">&quot;👦🏻&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> second = <span class="type">BehaviorSubject</span>(value: <span class="string">&quot;🅰️&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> variable = <span class="type">Variable</span>(first)</span><br><span class="line"></span><br><span class="line">variable.asObservable()</span><br><span class="line">    .flatMap &#123; $<span class="number">0</span> &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">first.onNext(<span class="string">&quot;🐱&quot;</span>)</span><br><span class="line">variable.value = second</span><br><span class="line">second.onNext(<span class="string">&quot;🅱️&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;🐶&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👦🏻</span></span><br><span class="line"><span class="comment">// 🐱</span></span><br><span class="line"><span class="comment">// 🅰️</span></span><br><span class="line"><span class="comment">// 🅱️</span></span><br><span class="line"><span class="comment">// 🐶</span></span><br></pre></td></tr></table></figure>

<h3 id="flatMapLatest"><a href="#flatMapLatest" class="headerlink" title="flatMapLatest"></a>flatMapLatest</h3><p>将 <code>Observable</code> 的元素转换成其他的 <code>Observable</code>，然后取这些 <code>Observables</code> 中<strong>最新的一个</strong>。</p>
<p><code>flatMapLatest</code> 操作符将源 <code>Observable</code> 的每一个元素应用一个转换方法，将他们转换成 <code>Observables</code>。一旦转换出一个新的 <code>Observable</code>，就只发出它的元素，旧的 <code>Observables</code> 的元素将被忽略掉。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> first = <span class="type">BehaviorSubject</span>(value: <span class="string">&quot;👦🏻&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> second = <span class="type">BehaviorSubject</span>(value: <span class="string">&quot;🅰️&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> variable = <span class="type">Variable</span>(first)</span><br><span class="line"></span><br><span class="line">variable.asObservable()</span><br><span class="line">    .flatMapLatest &#123; $<span class="number">0</span> &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">first.onNext(<span class="string">&quot;🐱&quot;</span>)</span><br><span class="line">variable.value = second</span><br><span class="line">second.onNext(<span class="string">&quot;🅱️&quot;</span>)</span><br><span class="line">first.onNext(<span class="string">&quot;🐶&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 👦🏻</span></span><br><span class="line"><span class="comment">// 🐱</span></span><br><span class="line"><span class="comment">// 🅰️</span></span><br><span class="line"><span class="comment">// 🅱️</span></span><br></pre></td></tr></table></figure>

<h2 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h2><hr>
<p>持续的将 <code>Observable</code> 的每一个元素应用一个函数，然后发出每一次函数返回的结果。</p>
<p><code>scan</code> 操作符将对第一个元素应用一个函数，将结果作为第一个元素发出。然后，将结果作为参数填入到第二个元素的应用函数中，创建第二个元素。以此类推，直到遍历完全部的元素。</p>
<p>这种操作符在其他地方有时候被称作是 <code>accumulator</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>)</span><br><span class="line">    .scan(<span class="number">1</span>) &#123; aggregateValue, newValue <span class="keyword">in</span></span><br><span class="line">        aggregateValue + newValue</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// 111</span></span><br><span class="line"><span class="comment">// 1111</span></span><br></pre></td></tr></table></figure>

<h2 id="materialize-和-dematerialize"><a href="#materialize-和-dematerialize" class="headerlink" title="materialize 和 dematerialize"></a>materialize 和 dematerialize</h2><hr>
<h3 id="materialize"><a href="#materialize" class="headerlink" title="materialize"></a>materialize</h3><p>将任何 <code>Observable</code> 转换为其事件的可观察者。</p>
<p><img src="/my_pictures/materialize.png"></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span></span><br><span class="line">    .range(start: <span class="number">1</span>, <span class="built_in">count</span>: <span class="number">3</span>)</span><br><span class="line">    .materialize()</span><br><span class="line">    .subscribe(onNext: &#123;</span><br><span class="line">        <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: bag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// next(1)</span></span><br><span class="line"><span class="comment">// next(2)</span></span><br><span class="line"><span class="comment">// next(3)</span></span><br><span class="line"><span class="comment">// completed</span></span><br></pre></td></tr></table></figure>

<p>作为对比</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span></span><br><span class="line">    .range(start: <span class="number">1</span>, <span class="built_in">count</span>: <span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123;</span><br><span class="line">        <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: bag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="dematerialize"><a href="#dematerialize" class="headerlink" title="dematerialize"></a>dematerialize</h3><p><code>dematerialize</code> 操作符将 <code>materialize</code> 转换后的元素还原</p>
<p><img src="/my_pictures/dematerialize.png"></p>
<h2 id="take-、-takeLast-和-elementAt"><a href="#take-、-takeLast-和-elementAt" class="headerlink" title="take 、 takeLast 和 elementAt"></a>take 、 takeLast 和 elementAt</h2><hr>
<h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p>仅仅从 <code>Observable</code> 中发出头 n 个元素。通过 <code>take</code> 操作符你可以只发出头 n 个元素。并且忽略掉后面的元素，直接结束序列。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">&quot;🐱&quot;</span>, <span class="string">&quot;🐰&quot;</span>, <span class="string">&quot;🐶&quot;</span>, <span class="string">&quot;🐸&quot;</span>, <span class="string">&quot;🐷&quot;</span>, <span class="string">&quot;🐵&quot;</span>)</span><br><span class="line">    .take(<span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🐱</span></span><br><span class="line"><span class="comment">// 🐰</span></span><br><span class="line"><span class="comment">// 🐶</span></span><br></pre></td></tr></table></figure>

<h3 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h3><p>仅仅从 <code>Observable</code> 中发出尾部 n 个元素，通过 <code>takeLast</code> 操作符你可以只发出尾部 n 个元素。并且忽略掉前面的元素。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">&quot;🐱&quot;</span>, <span class="string">&quot;🐰&quot;</span>, <span class="string">&quot;🐶&quot;</span>, <span class="string">&quot;🐸&quot;</span>, <span class="string">&quot;🐷&quot;</span>, <span class="string">&quot;🐵&quot;</span>)</span><br><span class="line">    .takeLast(<span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🐸</span></span><br><span class="line"><span class="comment">// 🐷</span></span><br><span class="line"><span class="comment">// 🐵</span></span><br></pre></td></tr></table></figure>

<h3 id="elementAt"><a href="#elementAt" class="headerlink" title="elementAt"></a>elementAt</h3><p>只发出 <code>Observable</code> 中的第 n 个元素，<code>elementAt</code> 操作符将拉取 <code>Observable</code> 序列中指定索引数的元素，然后将它作为唯一的元素发出。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">&quot;🐱&quot;</span>, <span class="string">&quot;🐰&quot;</span>, <span class="string">&quot;🐶&quot;</span>, <span class="string">&quot;🐸&quot;</span>, <span class="string">&quot;🐷&quot;</span>, <span class="string">&quot;🐵&quot;</span>)</span><br><span class="line">    .elementAt(<span class="number">3</span>)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🐸</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>KVC 和 Properties有什么区别？【译】</title>
    <url>/2018/04/13/2018-04-13-KVC%E5%92%8CProperties%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="但是，我仍然不明白，KVC-和属性访问（property-accessor）方法有什么区别？"><a href="#但是，我仍然不明白，KVC-和属性访问（property-accessor）方法有什么区别？" class="headerlink" title="但是，我仍然不明白，KVC 和属性访问（property accessor）方法有什么区别？"></a>但是，我仍然不明白，KVC 和属性访问（property accessor）方法有什么区别？</h3><hr>
<p>KVC 是调用属性访问器方法或以其他方式访问属性的一种方法。</p>
<p><strong>“以其他方式访问”是什么意思？</strong></p>
<p>对于 KVC 而言，没有访问器方法的实例变量会被视为非正式属性。<br>如果没有找到匹配的访问器对，它将直接获取或设置实例变量的值。<br>（是的，在现代代码中这是不值得使用的，总是为任何你想访问的任何东西声明一个 <code>@property</code>，反之，不要使用 KVC 来访问任何不属于公共属性的东西。）</p>
<p>属性访问器方法是 KVC 在其存在的情况下会调用的方法（KVC 和每个理智的程序员都倾向于直接 ivar 访问）。访问者可以获取或设置实例变量，如合成访问者所做的那样，或者访问某些其他存储。 </p>
<p>访问器是实现，属性是接口，KVC 是使用它们的一种方式。</p>
<a id="more"></a>

<h3 id="如何区分调用-setValue：forKeyPath-的点和简单访问器？"><a href="#如何区分调用-setValue：forKeyPath-的点和简单访问器？" class="headerlink" title="如何区分调用 setValue：forKeyPath 的点和简单访问器？"></a>如何区分调用 <code>setValue：forKeyPath</code> 的点和简单访问器？</h3><hr>
<p>键路径是一个字符串，而属性访问表达式是一个表达式。编译器检测属性访问表达式并将其转换为一个或多个 Objective-C 消息，而键路径由 KVC 在运行时检测。</p>
<p>所以，当你使用键路径时：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[someObject setValue:theValue forKeyPath:@<span class="string">&quot;foo.bar.baz&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>你知道这是一个键路径，因为</p>
<ol>
<li>它是一个字符串，如本例中的字符串文字语法 <code>@“...”</code> 所示;</li>
<li>将密钥路径字符串传递给 <code>setValue：forKeyPath:</code> 检测。 </li>
</ol>
<p>使用键路径是使用 KVC 来访问指定的属性。它会代表你发送任何相关的访问者消息。</p>
<p>当您使用属性访问表达式时：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">someObject.foo.bar.baz = theValue;</span><br></pre></td></tr></table></figure>

<p>你知道这是一个属性访问表达式，因为你没有用字符串标识属性。你正在使用自己的代码访问它们（发送访问者消息）。</p>
<p>没有太多理由以任何形式使用 KVC；当你在作者/编译时知道该属性时，最好声明 <code>@property</code> 并自己访问属性，无论是使用属性访问表达式还是消息表达式（<code>[[[someObject foo] bar] setBaz：theValue]</code>）。使用 KVC 的时间是在运行时间之前不知道要访问的属性，这很少见。它主要是 KVO，Cocoa Bindings，Core Animation 等部分背后的构建块技术。 </p>
<p>大多数情况下，你只需要自己访问属性。</p>
<p>原文链接：<a href="https://stackoverflow.com/questions/8191373/whats-the-difference-between-kvc-and-properties">What’s the difference between KVC and Properties?</a></p>
]]></content>
      <categories>
        <category>文章翻译</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>为 Playground 手动运行添加快捷键</title>
    <url>/2018/04/13/2018-04-13-%E4%B8%BA%20Playground%20%E6%89%8B%E5%8A%A8%E8%BF%90%E8%A1%8C%E6%B7%BB%E5%8A%A0%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>我在使用 Playground 的时候，喜欢将自定运行（Automatically Run）修改为手动运行（Manually Run），因为自动运行有时会导致我的 Xcode 卡住，体验非常不好。但是 Playground 并没有相应的快捷键去手动执行 Playground，这又导致手动运行的时候操作繁琐，每次都要靠鼠标去点，作为一个程序员怎么能忍受这种没有效率的操作 😂。接下来我们为手动执行 Playground 添加一个快捷键。</p>
<h3 id="打开系统偏好设置中的快捷键设置"><a href="#打开系统偏好设置中的快捷键设置" class="headerlink" title="打开系统偏好设置中的快捷键设置"></a>打开系统偏好设置中的快捷键设置</h3><hr>
<p>系统偏好设置 -&gt; 键盘 -&gt; 快捷键</p>
<p>选中最后一个，<code>应用快捷键</code></p>
<p><img src="/my_pictures/%E4%B8%BAPlayground%E6%89%8B%E5%8A%A8%E8%BF%90%E8%A1%8C%E6%B7%BB%E5%8A%A0%E5%BF%AB%E6%8D%B7%E9%94%AE-1.png"></p>
<a id="more"></a>

<h3 id="设置快捷键"><a href="#设置快捷键" class="headerlink" title="设置快捷键"></a>设置快捷键</h3><hr>
<p>点击加号，添加一个快捷键。应用程序选择 Xcode，菜单标题填写 <code>Execute Playground</code>，快捷键设置为自己想要的快捷键即可。</p>
<ul>
<li>注意：快捷键不能设置成 <code>command + R</code> 因为这会和 Xcode 本身的运行快捷键冲突。</li>
</ul>
<p><img src="/my_pictures/%E4%B8%BAPlayground%E6%89%8B%E5%8A%A8%E8%BF%90%E8%A1%8C%E6%B7%BB%E5%8A%A0%E5%BF%AB%E6%8D%B7%E9%94%AE-2.png"></p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift Runtime</title>
    <url>/2018/04/18/2018-04-18-Swift%20Runtime/</url>
    <content><![CDATA[<p>我们都知道 Objective-C 是一门动态的语言，有的时候我们会使用 <code>Runtime</code> 处理一些在 Objective-C 上面无法实现或者很难实现的功能。例如：在扩展中添加属性；动态的获取属性的名称，方法名等。那么究竟什么是 <code>Runtime</code>？</p>
<p><strong>什么是 <code>Runtime</code> ？</strong></p>
<p><code>Runtime</code> 简称运行时。Objective-C 就是运行时机制，也就是在程序运行时候的一些机制，其中最主要的是消息机制。对于我们熟悉的C语言，函数的调用在编译的时候会决定调用哪个函数。但对于 Objective-C 的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</p>
<p>也就有了下面这两点结论：</p>
<ol>
<li>在编译阶段，Objective-C 可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。</li>
<li>在编译阶段，C语言调用未实现的函数就会报错。</li>
</ol>
<a id="more"></a>

<h3 id="Swift-中的-Runtime"><a href="#Swift-中的-Runtime" class="headerlink" title="Swift 中的 Runtime"></a>Swift 中的 Runtime</h3><hr>
<p>好了上面说了这么多都是在说 Objective-C 的 <code>Runtime</code>，那么 Swift 的 <code>Runtime</code> 是什么样的呢？我们来写几行代码看一下。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> address: <span class="type">String?</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myPrint</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Demo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">UInt32</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> demo = <span class="type">Demo</span>()</span><br><span class="line"><span class="keyword">let</span> list = class_copyPropertyList(object_getClass(demo), &amp;<span class="built_in">count</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">numericCast</span>(<span class="built_in">count</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> item = list?[idx],</span><br><span class="line">        <span class="keyword">let</span> name = <span class="type">String</span>(utf8String: property_getName(item)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Property: \(name)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>猜一下，会输出什么？当然，<strong>这里什么都不输出</strong>！为什么？因为我们创建的类 <code>Demo</code> 是一个纯 Swift 的类，因为 Swift 是一门静态语言，所以我们对其运用 <code>Runtime</code> 机制当然是不可能获取到 <code>Demo</code> 类的属性的。如果我非要在 Swift 代码中运用 <code>Runtime</code> 技术呢？当然是有办法的。我们可以在你要获取的属性（函数同理）前用 <code>@objc</code> 修饰即可（当然加上 <code>dynamic</code> 也是可以的，不过编译器会提示错误，必须要在 <code>dynamic</code> 前添加 <code>@objc</code>），就像如下这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> name: <span class="type">String?</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> address: <span class="type">String?</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">myPrint</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Demo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在添加如下的代码来打印出方法名：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fCount: <span class="type">UInt32</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> funcList = class_copyMethodList(object_getClass(demo), &amp;fCount)</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">numericCast</span>(fCount) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> item = funcList?[idx] &#123;</span><br><span class="line">        <span class="keyword">let</span> name = <span class="type">NSStringFromSelector</span>(method_getName(item))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Method: \(name)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Property</span>: name</span><br><span class="line"><span class="type">Property</span>: address</span><br><span class="line"><span class="type">Method</span>: address</span><br><span class="line"><span class="type">Method</span>: name</span><br><span class="line"><span class="type">Method</span>: setName:</span><br><span class="line"><span class="type">Method</span>: setAddress:</span><br><span class="line"><span class="type">Method</span>: myPrint</span><br></pre></td></tr></table></figure>

<p>为什么加上 <code>@objc</code> 就有 <code>Runtime</code> 机制了呢？Swift 不是静态语言吗？</p>
<p>我们来看一下官方文档里对 <code>@objc</code> 是怎么说的。</p>
<blockquote>
<p>把这个特性用到任何可以在 Objective-C 中表示的声明上——例如，非内嵌类，协议，非泛型枚举（原始值类型只能是整数），类和协议的属性、方法（包括 <code>setter</code> 和 <code>getter</code> ），初始化&gt; &gt; 器，反初始化器，下标。 <code>objc</code> 特性告诉编译器，这个声明在 Objective-C 代码中是可用的。</p>
<p>给扩展应用这个特性与为这个扩展中所有不显式标记为 nonobjc 特性的成员应用是一样的效果。</p>
<p>用 <code>objc</code> 特性标记的类必须继承自一个 Objective-C 中定义的类。如果你把 <code>objc</code> 用到类或协议中，它会隐式地应用于该类或协议中 Objective-C 兼容的成员上。如果一个类继承自另一个&gt; 带 <code>objc</code> 特性标记或 Objective-C 中定义的类，编译器也会隐式地给这个类添加 <code>objc</code> 特性。标记为 <code>objc</code> 特性的协议不能继承自非 <code>objc</code> 特性的协议。</p>
<p><code>objc</code> 特性同样会在下面的情况中隐式地添加：</p>
<ul>
<li>声明是子类的重写，并且父类的声明有 <code>objc</code> 特性；</li>
<li>声明满足的需求来自一个拥有 <code>objc</code> 特性的协议；</li>
<li>声明有 <code>IBAction</code> , <code>IBOutlet</code> , <code>IBDesignable</code> , <code>IBInspectable</code> , <code>NSManaged</code>, 或者 <code>GKInspectable</code> 特性。</li>
</ul>
<p>如果你在一个枚举中使用 <code>objc</code> 特性，枚举名和每个成员名串联起来，作为枚举成员暴露给 Objective-C 代码。成员名首字母大写。例如，一个 Swift  <code>Planet</code> 枚举成员叫做 <code>venus</code> ，&gt; 它作为一个叫 <code>PlanetVenus</code> 的成员暴露到 Objective-C 代码中。</p>
<p><code>objc</code> 特性可以接受一个特性实参，由一个标识符组成。当你想在 Objective-C 中为 <code>objc</code> 特性标记的实体暴露一个不同的名字时，用这个特性。你可以把这个实参用在命名类，枚举，枚举成&gt; 员，协议，方法，getter，setter，初始化器。下面的例子把 ExampleClass 中 enabled 属性的getter作为 isEnabled 暴露给 Objective-C 代码，而不仅仅是属性本身的名字。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> enabled: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="meta">@objc</span>(isEnabled) <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="comment">// Return the appropriate value</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>首先有 <code>@objc</code> 这个关键字，它是用来将 Swift 的 API 暴漏给 Objective-C 和 <code>Runtime</code> 使用的，文档里也很清楚的说明了，如果你类继承自 Objective-C 的类，这个标识符就会被自动加进去，加了这标识符的属性、方法无法保证都会被运行时调用，因为 Swift 会做静态优化，想要完全被声明成动态调用，必须使用 <code>dynamic</code> 标识符修饰，当然添加了 <code>dynamic</code> 的时候，它会自己在加上 <code>@objc</code> 这个标识符。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dBool = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> dInt = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">demoTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;NSObject Class&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这时我们没有在 <code>dBool</code> 和 <code>dInt</code> 两个属性添加 <code>@objc</code> 修饰，但是 <code>Runtime</code> 时依然能够获取到，因为类继承了 Objective-C 中的 <code>NSObject</code>，他会隐式的在属相前面添加 <code>@objc</code>，同理，继承自 <code>UIViewController</code> 等的类，都有这个特性。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 并发，锁，线程同步【一】GCD</title>
    <url>/2018/04/16/2018-04-16-iOS%20%E5%B9%B6%E5%8F%91%EF%BC%8C%E9%94%81%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E3%80%90%E4%B8%80%E3%80%91GCD/</url>
    <content><![CDATA[<p>无并发，不编程。并发在开发中是非常重要的一个技术，运用并发技术，可以写出高性能的程序，并发能够有效地利用多核心 CPU 的优势来提高数据处理的速度。作为一个码农，学好并发是十分有必要的。iOS有四种多线程编程的技术，分别是：NSThread，Cocoa NSOperation，GCD（全称：Grand Central Dispatch）, pthread。今天我们就重点讲一讲 GCD 中的并发，锁和线程同步。</p>
<h2 id="GCD-中的并发"><a href="#GCD-中的并发" class="headerlink" title="GCD 中的并发"></a>GCD 中的并发</h2><hr>
<p>GCD 队列默认就是串行的（serial），在 GCD 中创建并发队列是如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> concurrent = <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.demo.concurrentQueue&quot;</span>, attributes: .concurrent)</span><br></pre></td></tr></table></figure>

<p><code>DispatchQueue</code> 的 <code>attributes</code> 参数还有一个取值：<code>initiallyInactive</code>，这是可以手动管理队列执行时间的参数。<br>当一个队列声明为 <code>initiallyInactive</code> 时，这个队列不会自动开始执行，必须要调用 <code>activate()</code> 方法。对应的还有 <code>suspend()</code> 和 <code>resume()</code>。</p>
<ul>
<li><code>activate()</code>：开始执行队列</li>
<li><code>suspend()</code>：挂起队列</li>
<li><code>resume()</code>：继续执行队列</li>
</ul>
<p>关于 <code>initiallyInactive</code> 到这里为止，我们继续说说并发队列。</p>
<a id="more"></a>

<h2 id="线程安全：锁"><a href="#线程安全：锁" class="headerlink" title="线程安全：锁"></a>线程安全：锁</h2><hr>
<p>在并发中，最重要的就是如何保证线程的安全。这就涉及到一个重要的知识点：锁。在 <code>Objective-C</code> 加锁的常见方式为 <code>@synchronized</code> 关键词和 <code>NSLock</code> 对象锁。Swift 的 GCD 中我们可以使用信号量 <code>DispatchSemaphore</code> 的方式实现加锁的目的。</p>
<p><strong>我们先来说说信号量加锁的方式。</strong></p>
<h4 id="DispatchSemaphore"><a href="#DispatchSemaphore" class="headerlink" title="DispatchSemaphore"></a>DispatchSemaphore</h4><p><code>DispatchSemaphore</code> 提供了传统计数信号量的高效实现，可用于控制跨多个执行上下文访问资源。</p>
<p>举个例子：线程 A 执行的前提是需要线程 B 执行的结果，但是 A，B 是两个异步线程。简单的来说就是如何串行的执行两个异步线程。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sema = <span class="type">DispatchSemaphore</span>(value: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    sema.wait()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    sema.signal()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure>

<p>上面的代码如果不用信号量处理，输出的结果为 <code>1 2</code>，<code>wait()</code> 就是阻塞当前队列，<code>signal()</code> 发出信号。<code>DispatchSemaphore</code> 的 <code>value</code> 参数表示初始的信号量，不要设置成负数，否则会抛出 <code>EXC_BAD_INSTRUCTION</code> 异常。另一个就是要保证 <code>wait()</code> 和 <code>signal()</code> 的平衡，也就是成对的出现。</p>
<p>简单的介绍了一下 <code>DispatchSemaphore</code>，现在我们用它来实现我们的锁。</p>
<p>思考一下锁是为什么会存在？锁就是为了解决不同线程之间同时的访问同一数据可能会造成意想不到的错误而存在。那么我们用 <code>DispatchSemaphore</code> 实现的时候，就是要保证当线程 A 访问数据的时候我们需要阻塞下一个线程 B 对这一块数据的访问，当 A 完成对数据的访问时，我们才能允许线程 B 对这一块数据的访问。理清思路，下面我们就来转换成代码表示：</p>
<p>我们可以将锁的逻辑封装在一个方法中，充分利用 Swift 函数式编程的优点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">synchronized</span><span class="params">(<span class="keyword">_</span> closure: <span class="params">()</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    sema.wait()</span><br><span class="line">    closure()</span><br><span class="line">    sema.signal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在声明 <code>DispatchSemaphore</code> 的时候，它的初始信号量 <code>value</code> 就不能是0了，必须是1（原因很简单）。所以我们必须这样声明：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sema = <span class="type">DispatchSemaphore</span>(value: <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>OK，锁“做”好了，我们就开始我们的并发。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(<span class="keyword">_</span> idx: Int)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Start sync task \(idx)&quot;</span>)</span><br><span class="line">    synchronized() &#123;</span><br><span class="line">        ary.append(idx)</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End sync task \(idx)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Main queue Start&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> concurrent = <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.demo.concurrentQueue&quot;</span>,</span><br><span class="line">                               attributes: .concurrent)</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">3</span> &#123;</span><br><span class="line">    concurrent.async &#123;</span><br><span class="line">        task(idx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Main queue End&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这样我们就能保证我们 <code>ary</code> 中的数据时正确的。</p>
<h4 id="Swift-中的-synchronized"><a href="#Swift-中的-synchronized" class="headerlink" title="Swift 中的 @synchronized"></a>Swift 中的 <code>@synchronized</code></h4><p>刚才我们介绍了信号量编写的锁，接下来我们来看看 Objective-C 中的 <code>@synchronized</code>，是的，Swift 中没有 <code>@synchronized</code> 这个东西，怎么办呢？其实 <code>@synchronized</code> 底层调用的是 <code>objc_sync_enter(_ obj: Any)</code> 和 <code>objc_sync_exit(_ obj: Any)</code>。我们就直接调用这两个方法就 OK。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">synchronized</span><span class="params">(<span class="keyword">_</span> lock: <span class="keyword">Any</span>, <span class="keyword">_</span> closure: <span class="params">()</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    objc_sync_enter(lock)</span><br><span class="line">    closure()</span><br><span class="line">    objc_sync_exit(lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>lock</code> 参数表示要加锁的对象。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">synchronized(ary) &#123;</span><br><span class="line">    ary.append(idx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顺便一提：</strong> <code>@synchronized</code> 是互斥锁，由于内部会进行异常处理，Objective-C 中性能一般。我们实现的 <code>DispatchSemaphore</code> 信号量锁，由于底层是 <code>C</code> 代码的封装，所以性能上要好点。</p>
<p>详细的解释可以参考我的另一篇文章：<a href="https://www.jianshu.com/p/e37e2c41f6bf">Swift Lock</a></p>
<h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><hr>
<p>线程的同步我们来介绍一下 GCD 中的 <code>DispatchGroup</code>。线程同步也可以用信号量的方式来实现，这里就不在啰嗦。</p>
<p>当我们想要在并发结束后输出 <code>ary</code> 中的数据的时候，我们就需要线程的同步了。首先我们声明一个 <code>DispatchGroup</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br></pre></td></tr></table></figure>

<p>我们需要用到三个方法：<code>enter()</code>，<code>leave()</code>，<code>notify(...)</code>。</p>
<ul>
<li><code>enter()</code> 表示执行的开始</li>
<li><code>leave()</code> 表示执行的结束</li>
<li><code>notify(...)</code> 所有执行都结束后执行的函数</li>
</ul>
<p>我们执行的开始就是我们的并发函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">concurrent.async &#123;</span><br><span class="line">    group.enter()</span><br><span class="line">    task(idx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行的结束就是我们的task：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(<span class="keyword">_</span> idx: Int)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Start sync task \(idx)&quot;</span>)</span><br><span class="line">    synchronized(ary) &#123;</span><br><span class="line">        ary.append(idx)</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End sync task \(idx)&quot;</span>)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们执行输出 <code>ary</code> 信息的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">group.notify(queue: .main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(ary)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C 回顾【一】之 熟悉 Objective-C</title>
    <url>/2018/04/22/2018-04-22-Objective-C%20%E5%9B%9E%E9%A1%BE%E3%80%90%E4%B8%80%E3%80%91%E4%B9%8B%20%E7%86%9F%E6%82%89%20Objective-C/</url>
    <content><![CDATA[<h3 id="Objective-C-语言的起源"><a href="#Objective-C-语言的起源" class="headerlink" title="Objective-C 语言的起源"></a>Objective-C 语言的起源</h3><hr>
<p>Objective-C 与 C++，Java 等面向对象的语言类似，不过在很多地方还是有所差别。Objective-C 使用“消息结构”（messaging structure）而非“函数调用”（function calling）。</p>
<p>消息结构的语言与函数调用的语言关键区别在于：</p>
<ul>
<li>使用消息结构的语言，其运行时所应执行的代码由运行环境决定，也就是说，在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定；</li>
<li>使用函数调用的语言，运行时所执行的代码由编译器决定；</li>
</ul>
<p><strong>要点：</strong></p>
<ul>
<li>Objective-C 为 C 语言添加了面向对象特性，是其超集。Objective-C 使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定。</li>
<li>理解 C 语言的核心概念有助于写好 Objective-C 程序。尤其要掌握内存模型与指针。</li>
</ul>
<h3 id="在类的头文件中尽量少引入其他头文件"><a href="#在类的头文件中尽量少引入其他头文件" class="headerlink" title="在类的头文件中尽量少引入其他头文件"></a>在类的头文件中尽量少引入其他头文件</h3><hr>
<p>在类的头文件中（.h）我们一般不需要知道引入的某个类的全部细节，这时候，我们可以用 <code>@class</code> 关键字去告诉编译器，知道有一个类名为 xxx 的类就好，不需要关注细节。</p>
<p>这叫做“向前声明”（forward declaring）该类。在实现文件（.m）中我们使用该类时就需要知道其所有细节，这时我们需要用 <code>#import</code> 关键字去导入 xxx 类的头文件。</p>
<p>将引入头文件的时机尽量延后，只有确有需要时才引入，这样就能减少类的使用者所需引入头文件的数量。这样能够一定程度上的<strong>减少编译的时间</strong>。</p>
<a id="more"></a>

<p>向前声明也解决了<strong>两个类相互引用的问题</strong>。如果 A 类的头文件中引用了 B 类，B 类的头文件中又引用了 A 类，那么意味着这两个类里有一个无法被正确编译。</p>
<p>但是在写继承和协议的时候，又不能避免的要在头文件中引用其他的头文件。最好的解决方式就是<strong>将协议放在一个单独的头文件中</strong>，这样就能避免如果协议是放在一个很大的头文件中的话，就需要引用那个头文件中的所有内容。这样不仅可能产生相互依赖的问题，还有可能会增加编译时间。</p>
<p><strong>要点：</strong></p>
<ul>
<li>除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合。</li>
<li>有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把“该类遵循某协议”的这条声明移至“class-continuation分类”中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。</li>
</ul>
<h3 id="多用字面量语法，少用与之等价的方法"><a href="#多用字面量语法，少用与之等价的方法" class="headerlink" title="多用字面量语法，少用与之等价的方法"></a>多用字面量语法，少用与之等价的方法</h3><hr>
<p><strong>要点：</strong></p>
<ul>
<li>应该使用字面量语法来创建字符串，数值，数组，字典。与创建此类对象的常规方法相比，这么做更加简明扼要。</li>
<li>应该通过取下标操作来访问数组下标或字典中的键所以对应的元素。</li>
<li>用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。</li>
</ul>
<h3 id="多用类型常量，少用-define-预处理指令"><a href="#多用类型常量，少用-define-预处理指令" class="headerlink" title="多用类型常量，少用 #define 预处理指令"></a>多用类型常量，少用 #define 预处理指令</h3><hr>
<p>我们在写动画的时候，很多人喜欢将动画的持续时间常量写成预处理指令的形式，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANIMATION_DURATION 0.3</span></span><br></pre></td></tr></table></figure>

<p>这样做并不算错，但是有两个问题：</p>
<ul>
<li>定义出来的常量没有类型信息。</li>
<li>预处理指令过程会把碰到的所有 <code>ANIMATION_DURATION</code> 一律替换成 0.3，这样的话，假设此指令声明在某个头文件中，那么所有引入了这个头文件的代码，其 <code>ANIMATION_DURATION</code> 都会被替换掉。</li>
</ul>
<p>改成下面的方式就会更好一点：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure>

<p>这里有个命名习惯：</p>
<ul>
<li>若常量局限于某“编译单元”（translation unit，也就是“实现文件”，implementation file）之内，则在前面加字幕k。</li>
<li>若常量在类之外可见，则通常以类名为前缀。</li>
</ul>
<p>变量一定要同时用 <code>static</code> 和 <code>const</code> 来声明。如果试图修改由 <code>const</code> 修饰符所声明的变量，那么编译器就会报错。而 <code>static</code> 修饰符则意味着该变量仅在定义此变量的编译单元中可见。在 Objective-C 中”编译单元”一词通常指每个类的实现文件（以 .m 为后缀名）。如果不加 <code>static</code>，则编译器会为它创建一个“外部符号”（external symbol）。此时若是另一个编译单元中也声明了同名变量，那么编译器就抛出一条错误信息：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">duplicate symbol _kAnimationDuration <span class="keyword">in</span>：</span><br><span class="line">    xxx.o</span><br><span class="line">    aaa.o</span><br></pre></td></tr></table></figure>

<p>实际上，如果一个变量既声明为 <code>static</code>，又声明为 <code>const</code>，那么编译器根本不会创建符号，而是会像 <code>#define</code> 预处理指令一样，把所有遇到的变量都替换为常量。不过还是要记住：用这种方式定义的常量带有类型信息。</p>
<p>如果需要对外公开某个常量。需要将常量放在“全局符号表”（global symbol table）中，以便可以在定义该常量的编译单元之外使用。应该这样来定义：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头文件中</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> xxx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现文件中</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> xxx = x;</span><br></pre></td></tr></table></figure>

<p><code>extern</code> 关键字是告诉编译器，在全局符号表中将会有一个名叫 <code>xxx</code> 的符号。也就是说，编译器无须查看其定义，即允许代码使用此常量。因为它知道，当链接成二进制文件之后，肯定能找到这个常量（如果不在实现文件中定义，编译器将会报错，二进制文件中找不到该常量）。</p>
<p><strong>要点：</strong></p>
<ul>
<li>不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。</li>
<li>在实现文件中使用 <code>static const</code> 来定义“只在编译单元内可见的常量”（translation unit specific constant）。由于此类常量不在全局符号表中，所以无须为其名称加前缀。</li>
<li>在头文件中使用 <code>extern</code> 来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常与之相关的类名做前缀。</li>
</ul>
<h3 id="用枚举表示状态、选项、状态码"><a href="#用枚举表示状态、选项、状态码" class="headerlink" title="用枚举表示状态、选项、状态码"></a>用枚举表示状态、选项、状态码</h3><hr>
<p><strong>要点：</strong></p>
<ul>
<li>应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起一个易懂的名字。</li>
<li>如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为 2 的幂，以便通过按位或操作将其组合起来。</li>
<li>用 NS_ENUM 与 NS_OPTIONS 宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。</li>
<li>在处理枚举类型的 <code>switch</code> 语句中不要实现 <code>default</code> 分支。这样的话，加入新枚举之后，编译器就会提示开发者：<code>switch</code> 语句并未处理所有枚举。</li>
</ul>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C 回顾【二】之 对象、消息、运行期</title>
    <url>/2018/04/23/2018-04-23-Objective-C%20%E5%9B%9E%E9%A1%BE%E3%80%90%E4%BA%8C%E3%80%91%E4%B9%8B%20%E5%AF%B9%E8%B1%A1%E3%80%81%E6%B6%88%E6%81%AF%E3%80%81%E8%BF%90%E8%A1%8C%E6%9C%9F/</url>
    <content><![CDATA[<p>用 Objective-C 等面向对象语言编程时，“对象”（object）就是“基本构造单元”（building block），开发者可以通过对象来存储并传递数据。在对象之间传递数据并执行任务的过程就叫做“消息传递”（Messaging）。若想编写出高效且易维护的代码，就一定要熟悉这两个特性的工作原理。</p>
<p>当应用程序运行起来以后，为其提供相关支持的代码叫做“Objective-C 运行期环境”（Objective-C runtime），它提供了一些使得对象之间能够传递消息的重要函数，并且包含创建类实例所用的全部逻辑。在理解了运行期环境中各个部分协同工作的原理之后，你的开发水平将会进一步提升。</p>
<h3 id="理解“属性”这一概念"><a href="#理解“属性”这一概念" class="headerlink" title="理解“属性”这一概念"></a>理解“属性”这一概念</h3><hr>
<p>“属性”（property）是 Objective-C 的一项特性，用于封装对象中的数据。Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”（access method）来访问，也就是 <code>getter</code> 和 <code>setter</code> 方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span>: <span class="title">NSOjbect</span> </span>&#123;</span><br><span class="line"><span class="keyword">@public</span></span><br><span class="line">    <span class="built_in">NSString</span> *_firstName;</span><br><span class="line">    <span class="built_in">NSString</span> *_lastName;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    <span class="built_in">NSString</span> *_someInternalData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>上面的代码对于写过 Java 和 C++ 程序的人来说比较熟悉，但是 Objective-C 中却很少这么做。这种写法的问题是：对象布局在编译期已经固定了，只要碰到方位 <code>_firstName</code> 变量的代码，编译器就把其替换为“偏移量”（offset），这个偏移量是“硬编码”（hardcode），表示该变量距离存放对象的内存区域的起始地址有多远。这样做目前看来没什么问题，但是如果又加了一个实例变量，那就麻烦了。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span>: <span class="title">NSOjbect</span> </span>&#123;</span><br><span class="line"><span class="keyword">@public</span></span><br><span class="line">    <span class="built_in">NSDate</span> *_dateOfBirth;</span><br><span class="line">    <span class="built_in">NSString</span> *_firstName;</span><br><span class="line">    <span class="built_in">NSString</span> *_lastName;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    <span class="built_in">NSString</span> *_someInternalData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>原来表示 <code>_firstName</code> 的偏移量现在却指向 <code>_dateOfBirth</code> 了。把偏移量硬编码于其中的那些代码都会读取到错误的值。如下图所示：</p>
<p>![](/my_pictures/Objective-C 基础温习【二】之 对象、消息、运行期-1.png)</p>
<p>如果代码使用了编译期计算出来的偏移量，那么在修改类定义之后必须重新编译，否则就会出错。例如，某个代码库中的代码使用了一份旧的类定义。如果和其相链接的代码使用了新的类定义，那么运行时就会出现不兼容的现象。</p>
<p>Objective-C 的解决方式：</p>
<ul>
<li>稳固的“应用程序二进制接口”（Application Binary Interface，ABI）。<ul>
<li>将实例变量当做一种存储偏移量所用的“特殊变量”，交由“类对象”保管。偏移量会在运行时期查找，如果类的定义变了，那么存储的偏移量也就变了，这样的话，无论何时访问实例变量，总能使用正确的偏移量。甚至可以在运行期向类中新增实例变量。</li>
</ul>
</li>
<li>尽量不要直接访问实例变量（在对象之外），而是通过存取方法来做。</li>
</ul>
<p>属性的优势：</p>
<ul>
<li>使用“点语法”相当于调用存取方法。</li>
<li>自动生成存取方法（前提是没有用 <code>@dynamic</code> 做限制）。<ul>
<li><code>@dynamic</code> 关键字会告诉编译器：不要自动创建属性所用的实例变量，也不要为其创建存取方法。而且，在编译访问属性代码时，即使编译器发现没有定义存取方法，也不会报错，它相信这些方法能在运行期找到。比方说，如果从 CoreData 框架中的 <code>NSManagedObject</code> 类里继承了一个子类，那么就需要在运行期动态创建存取方法。继承 <code>NSManagedObject</code> 时之所以要这样做，是因为子类的某些属性不是实例变量，其数据来自后端的数据库。</li>
</ul>
</li>
<li>自动生成加下划线的实例变量。</li>
<li>我们可以用 <code>@synthesize</code> 来指定实例变量的名字。（不推荐）</li>
</ul>
<h4 id="属性特质"><a href="#属性特质" class="headerlink" title="属性特质"></a>属性特质</h4><ul>
<li>原子性（atomic/nonatomic）</li>
<li>读/写权限（readwrite/readonly）</li>
<li>内存管理语义<ul>
<li><code>assign</code>：针对于“纯量类型”（scalar type，例如：<code>CGFloat</code> 或 <code>NSInteger</code>等）的简单赋值操作。</li>
<li><code>strong</code>：定义了一种“拥有关系”。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。</li>
<li><code>weak</code>：定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 <code>assign</code> 类似，然后在属性所指的对象遭到摧毁时，属性值也会清空。</li>
<li><code>unsafe_unretained</code>：此特质的语义和 <code>assign</code> 相同，但是它适用于“对象类型”，该特质表达一种“非拥有关系”，当目标对象遭到摧毁时，属性值不会自动清空（“不安全”，unsafe），这一点与 <code>weak</code> 有区别。</li>
<li><code>copy</code>：此特质所表达的所属关系与 <code>strong</code> 类似。然而设置方法并不保留新值，而是将其“拷贝”（copy）。当属性类型为 <code>NSString*</code> 时，经常用此特质来保护其封装性。</li>
</ul>
</li>
<li>方法名<ul>
<li><code>getter=&lt;name&gt;</code> 指定“获取方法”的方法名。</li>
<li><code>setter=&lt;name&gt;</code> 指定“设置方法”的方法名。这种用法不太常见。</li>
</ul>
</li>
</ul>
<p><strong>要点：</strong></p>
<ul>
<li>可以用 <code>@property</code> 语法来定义对象中所封装的数据</li>
<li>通过“特质”来指定存储数据所需要的正确语义。</li>
<li>在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义。</li>
<li>开发 iOS 程序时应该使用 <code>nonatomic</code> 属性，因为 <code>atomic</code> 属性会严重影响性能。</li>
</ul>
<h3 id="在对象内部尽量直接访问实例变量"><a href="#在对象内部尽量直接访问实例变量" class="headerlink" title="在对象内部尽量直接访问实例变量"></a>在对象内部尽量直接访问实例变量</h3><hr>
<p><strong>在读取实例变量的时候采用直接访问的形式，而在设置实例变量的时候通过属性来做。</strong>此办法既能提高读取操作的速度，又能控制对属性的写入操作。之所以要通过“设置方法”来写入实例变量，其首要原因在于，这样做能够确保相关属性的“内存管理语义”得以贯彻。选用这种做法时，需要注意两点：</p>
<ul>
<li>在初始化方法中应该如何设置属性值。这种情况下<strong>总是应该直接访问实例变量</strong>，因为子类可能会“覆写”设置方法。</li>
<li>“惰性初始化”：这种情况下<strong>必须通过“获取方法”来访问属性</strong>，否则，实例变量就永远不会初始化。</li>
</ul>
<p><strong>直接访问实例变量和通过属性访问有几点区别：</strong></p>
<ul>
<li>由于不经过 Objective-C 的“方法派发”步骤，所以直接访问实例变量的速度当然比较快。在这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存。</li>
<li>直接访问实例变量时，不会调用其“设置方法”，这就绕过了为相关属性所定义的“内存管理语义”。比方说，如果在 ARC 下直接访问一个声明为 <code>copy</code> 的属性，那么并不会拷贝该属性，只会保留新值并释放旧值。</li>
<li>如果直接访问实例变量，那么不会触发“键值观测”（KVO）通知。这样做是否会产生问题，还取决于具体的对象行为。</li>
<li>通过属性来访问有助于排查与之相关的错误，因为可以给“获取方法”和/或“设置方法”中新增“断点”，监控该属性的调用者及其访问时机。</li>
</ul>
<p><strong>要点：</strong></p>
<ul>
<li>在对象内部读取数据时，应该直接通过实例变量来读取，而写入数据时，则应通过属性来写</li>
<li>在初始化方法及 <code>dealloc</code> 方法中，总是应该直接通过实例变量来读写数据。</li>
<li>有时会使用惰性初始化技术配置某分数据，这种情况下，需要通过属性来读取数据。</li>
</ul>
<h3 id="理解“对象等同性”这一概念"><a href="#理解“对象等同性”这一概念" class="headerlink" title="理解“对象等同性”这一概念"></a>理解“对象等同性”这一概念</h3><hr>
<p><strong>要点：</strong></p>
<ul>
<li>若想检测对象的等同性，请提供 <code>isEqual:</code> 与hash方法。</li>
<li>相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。</li>
<li>不要盲目的逐个检测每条属性，而是应该依照具体需求来制定检测方案。</li>
<li>编写 hash 方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。</li>
</ul>
<h3 id="在既有类中使用关联对象存放自定义数据"><a href="#在既有类中使用关联对象存放自定义数据" class="headerlink" title="在既有类中使用关联对象存放自定义数据"></a>在既有类中使用关联对象存放自定义数据</h3><hr>
<p>“关联对象”（Associated Object）可以给某对象关联许多其他对象，这些对象通过“键”来区分。存储对象值的时候，可以指明“存储策略”（storage policy），用以维护相应的“内存管理语义”。</p>
<table>
<thead>
<tr>
<th>关联类型</th>
<th>等效的@property属性</th>
</tr>
</thead>
<tbody><tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td>assign</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>nonatomic, retain</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>nonatomic, copy</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>retain</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>copy</td>
</tr>
</tbody></table>
<p>下列方法可以管理关联对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy);</span><br></pre></td></tr></table></figure>
<p>此方法以给定的键和策略为某对象设置关联对象值。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br></pre></td></tr></table></figure>
<p>此方法根据给定的键从某对象中获取相应的关联对象值。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object);</span><br></pre></td></tr></table></figure>
<p>此方法移除指定对象的全部关联对象。</p>
<p>这种做法很有用，但是只应该在其他办法行不通时才去考虑用它。若是滥用，则很快就会令代码失控，使其难于调试。“保留环”产生的原因很难查明，因为关联对象之间的关系并没有正式的定义，其内存管理语义是在关联的时候才定义的，而不是在接口中预先定好的。使用这种写法时要小心，不能仅仅因为某处可以用该写法就一定要用它。</p>
<p><strong>要点：</strong></p>
<ul>
<li>可以通过“关联对象”机制来把两个对象连起来。</li>
<li>定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的“拥有关系”与“非拥有关系”。</li>
<li>只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的bug。</li>
</ul>
<h3 id="理解-objc-msgSend-的作用"><a href="#理解-objc-msgSend-的作用" class="headerlink" title="理解 objc_msgSend 的作用"></a>理解 objc_msgSend 的作用</h3><hr>
<p>在对象上调用方法是 Objective-C 中经常使用的功能。用 Objective-C 的术语来说，这叫做消息传递。消息有“名称”（name）或“选择器”（selector），可以接受参数，而且可能还有返回值。</p>
<p>在 Objective-C 中，如果向某对象传递消息，那就会使用动态绑定机制来决定需要调用的方法。在底层，所有方法都是普通的 C 语言函数，然而对象收到消息后，究竟该调用哪个方法则完全于运行期决定，甚至可以在程序运行时改变，这些特性使得 Objective-C 成为一门真正的动态语言。</p>
<p>给对象发消息可以这样写：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> returnValue = [someObject messageName: parameter];</span><br></pre></td></tr></table></figure>

<p>在本例中，<code>someObject</code> 叫做“接收者”（receiver），<code>messageName</code> 叫做选择器。选择器与参数合起来称为消息。编译器看到此消息后，将其转换为一条标准的 C 语言函数调用，所调用的函数乃是消息传递机制中的核心函数，叫做 <code>objc_msgSend</code>，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL cmd, ...)</span><br></pre></td></tr></table></figure>

<p>这是个可变参数函数，能接受两个或两个以上的参数。第一个参数代表接收者，第二个参数代表选择器（<code>SEL</code> 是选择器的类型），后续参数就是消息中的那些参数，其顺序不变。选择器指的是方法的名字。选择器和方法这两个词经常交替使用。编译器会把刚才那个例子中的消息转换为如下函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> returnValue = objc_msgSend(someObject, <span class="keyword">@selector</span>(messageName:), parameter);</span><br></pre></td></tr></table></figure>

<p><code>objc_msgSend</code> 函数会依据接收者与选择器的类型来调用适当的方法。为了完成此操作，<strong>该方法需要在接收者所属的类中搜寻其方法列表，如果能找到与选择器名称相符的方法，就跳至实现代码。若是找不到，那就沿着继承体系继续向上查找，等找到合适的方法之后再跳转。如果最终还是找不到相符的方法，那就执行消息转发操作。</strong></p>
<p>这么说来，想调用一个方法似乎需要很多步骤。所幸 <code>objc_msgSend</code> 会将匹配结果缓存在“快速映射表”（fast map）里面，每个类都有这样一块缓存，若是稍后还向该类发送与选择器相同的消息，那么执行起来就很快了。当然啦，这种“快速执行路径”(fast path)还是不如“静态绑定的函数调用操作”（statically bound function call）那样迅速，不过只要把选择器缓存起来了，也就不会慢很多，实际上，消息派发（message dispatch）并非应用程序的瓶颈所在。</p>
<p>前面讲的这部分内容只描述了部分消息的调用过程，其他“边界情况”（edge case）则需要交由 Objective-C 运行环境中的另一些函数来处理</p>
<ul>
<li><code>objc_msgSend_stret</code>：如果待发送的消息要返回结构体，那么可交由此函数处理。只有当 CPU 的寄存器能够容纳得下消息返回类型时，这个函数才能处理此消息。若是返回值无法容纳于 CPU 寄存器中（比如说返回的结构体太大了），那么就由另一个函数执行派发。此时，那个函数会通过分配在栈上的某个变量来处理消息所返回的结构体。</li>
<li><code>objc_msgSend_fpret</code>：如果消息返回的是浮点数，那么可交由此函数处理。在某些架构的 CPU 中调用函数时，需要对浮点数寄存器做特殊处理，也就是说，通常所用的 <code>objc_msgSend</code> 在这种情况下并不合适。这个函数是为了处理 x86 等架构 CPU 中某些令人稍觉惊讶的奇怪状况。</li>
<li><code>objc_msgSendSuper</code>：如果要给超类发消息，例如 <code>[super message: parameter]</code>，那么就交由此函数处理。也有另外两个与 <code>objc_msgSend_stret</code> 和 <code>objc_msgSend_fpret</code> 等效的函数，用于处理发给 <code>super</code> 的相应消息。</li>
</ul>
<p>刚才曾提到，<code>objc_msgSend</code> 等函数一旦找到应该调用的方法实现之后，就会跳转过去。之所以能这样做，是因为 Objective-C 对象的每个方法都可以视为简单的 C 函数，其原型如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;retum_type&gt; Class_selector(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, ...)</span><br></pre></td></tr></table></figure>

<p>真正的函数名和上面写的可能不太一样，笔者用类和选择器来命名是想解释其工作原理。每个类里都有一张表格，其中的指针都会指向这种函数，而选择器的名称则是査表时所用的“键”。<code>objc_msgSend</code> 等函数正是通过这张表格来寻找应该执行的方法并跳至其实现的。请注意，原型的样子和 <code>objc_msgSend</code> 函数很像。这不是巧合，而是为了利用尾调用优化（尾递归优化）技术。令<strong>跳至方法实现</strong>这一操作变得更简单些。</p>
<p>如果某函数的最后一项操作是调用另外一个函数，那么就可以运用尾调用优化技术。编译器会生成调转至另一函数所需的指令码，而且不会向调用堆栈中推人新的“栈帧”（frame stack）。只有当某函数的最后一个操作仅仅是调用其他函数而不会将其返回值另作他用时，才能执行尾调用优化。这项优化对 <code>objc_msgSend</code> 非常关健，如果不这么做的话，那么每次调用 Objective-C 方法之前，都需要为调用 <code>objc_msgSend</code> 函数准备栈帧。，大家在“栈踪迹”（stack trace）中可以看到这种“栈帧”。此外，若是不优化，还会过早地发生“栈溢出”现象。</p>
<p><strong>要点：</strong></p>
<ul>
<li>消息接收者、选择器及参数构成。给某对象发送消息也就相当于在该对象上调用方法。</li>
<li>发给某对象的全部消息都要由动态消息派发系统来处理，该系统会查出对应的方法，并执行其代码。</li>
</ul>
<h3 id="理解消息转发机制"><a href="#理解消息转发机制" class="headerlink" title="理解消息转发机制"></a>理解消息转发机制</h3><hr>
<p>若想令类能理解某条消息，我们必须用代码实现出对应的方法才行。但是，在编译期向类发送了其无法解读的消息并不会报错，因为在运行期可以继续向类中添加方法，所以编译器在编译时还无法确知类中到底会不会有某个方法实现。当对象接收到无法解读的消息<br>后，就会启动消息转发机制，程序员可经由此过程告诉对象应该如何处理未知消息。</p>
<p><strong>消息转发分为两大阶段：</strong></p>
<ul>
<li>第一阶段先征询接收者，所属的类，看其是否能动态添加方法，以处理当前这个未知的选择器，这叫做<strong>动态方法解析</strong>。</li>
<li>第二阶段涉及<strong>完整的消息转发机制</strong>。如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法再以动态新增方法的手段来响应包含该选择器的消息了。此时，运行期系统会请求接收者以其他手段来处理与消息相关的方法调用。这又细分为两小步。<ul>
<li>首先，请接收者看看有没有其他对象能处理这条消息。若有，则运行期系统会把消息转给那个对象，于是消息转发过程结束，一切如常。</li>
<li>若没有备援的接收者，则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装到 <code>NSInvocation</code> 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。</li>
</ul>
</li>
</ul>
<h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><hr>
<p>对象在收到无法解读的消息后，首先将调用其所属类的下列类方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br></pre></td></tr></table></figure>

<p>该方法的参数就手那个未知的选择器，其返回值为 <code>Boolean</code> 类型。表示这个类是否能新增一个实例方法用以外理此选择器。在继续往下执行转发机制之前，本类有机会新增一个处理此选择器的方法。假如尚未实现的方法不是实例方法而是类方法，那么运行期系统就会调用另外一个方法，该方法与 <code>resolveInstanceMethod:</code> 类似，叫做 <code>resolveClassMethod:</code>。</p>
<p>使用这种办法的前提是：相关方法的实现代码已经写好，只等着运行的时候动态插入到类里面就可以了。此方案常用来实现 <code>@dynamic</code> 属性，比如说，要访问 <code>CoreData</code>框架中 <code>NSManagedObjects</code> 对象的属性时就可以这么做，因为实现这些属性所需的存取方法在编译期就能确定。</p>
<p>下列代码演示了如何用 <code>resolveInstanceMethod</code> 来实现 <code>@dynamic</code> 属性：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> dynmaicGetMethod(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd);</span><br><span class="line"><span class="keyword">void</span> dynmaicSetMethod(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> value);</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">    <span class="keyword">if</span> ([selectorString hasPrefix:<span class="string">@&quot;set&quot;</span>]) &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)dynmaicSetMethod, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)dynmaicGetMethod, <span class="string">&quot;@@:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="备援接收者"><a href="#备援接收者" class="headerlink" title="备援接收者"></a>备援接收者</h4><p>当前接收者还有第二次机会能处理未知的选择器，在这一步中，运行期系统会问它：能不能把这条消息转给其他接收者来处理。与该步骤对应的处理方法如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>

<p>方法参数代表未知的选择器，若当前接收者能找到备援对象，则将其返回，若找不到，就返回 <code>nil</code>。通过此方案，我们可以用“组合”(composition)来模拟出多重继承的某些特性。在一个对象内部，可能还有一系列其他对象，该对象可经由此方法将能够处理某选择器的相关内部对象返回，这样的话，在外界看来，好像是该对象亲自处理了这些消息似的。</p>
<p>请注意，<strong>我们无法操作经由这一步所转发的消息</strong>。若是想在发送给备援接收者之前先修改消息内容，那就得通过完整的消息转发机制来做了。</p>
<h4 id="完整的消息转发"><a href="#完整的消息转发" class="headerlink" title="完整的消息转发"></a>完整的消息转发</h4><p>如果转发算法巳经来到这一步的话，那么唯一能做的就是启用完整的消息转发机制了。首先创建 <code>NSInvocalion</code> 对象，把与尚未处理的那条消息有关的全部细节都封于其中，此对象包含选择器、目标（target）及参数。在触发 <code>NSInvocation</code> 对象时，消息派发系统将亲自出马，把消息指派给目标对象。</p>
<p>此步骤会调用下列方法来转发消息：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br></pre></td></tr></table></figure>

<p>这个方法可以实现得很简单：只需改变调用目标，使消息在新目标上得以调用即可。然而这样实现出来的方法与备援接收者方案所实现的方法等效，所以很少有人采用这么简单的实现方式。比较有用的实现方式为：在触发消息前，先以某种方式改变消息内容，比如追加另外一个参数，或是改换选择器，等等。</p>
<p>实现此方法时，若发现某调用操作不应由本类处理，则需调用超类的同名方法。这样的话，继承体系中的每个类都有机会处理此调用请求，直至 <code>NSObject</code>。如果最后调用了 <code>NSObject</code> 类的方法，那么该方法还会继而调用 <code>doesNotRecognizeSelector:</code> 以抛出异常，此异常表名选择器最终未能得到处理。</p>
<p>![](/my_pictures/Objective-C 基础温习【二】之 对象、消息、运行期-2.png)</p>
<h4 id="一个完整的例子"><a href="#一个完整的例子" class="headerlink" title="一个完整的例子"></a>一个完整的例子</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DemoHelper</span>: <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)myPrint:(<span class="built_in">NSString</span> *)message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DemoHelper</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)myPrint:(<span class="built_in">NSString</span> *)message &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;DemoHelper: %@&quot;</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Demo</span> ()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> helper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *propertyDictionary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Demo</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@dynamic</span> name, sex;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        helper = [[DemoHelper alloc] init];</span><br><span class="line">        _propertyDictionary = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> dynmaicGetMethod(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    Demo *typedSelf = (Demo *)<span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">return</span> [typedSelf.propertyDictionary objectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> dynmaicSetMethod(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    <span class="built_in">NSMutableString</span> *key = [selectorName mutableCopy];</span><br><span class="line">    [key deleteCharactersInRange:<span class="built_in">NSMakeRange</span>(key.length - <span class="number">1</span>, <span class="number">1</span>)];</span><br><span class="line">    [key deleteCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">3</span>)];</span><br><span class="line">    <span class="built_in">NSString</span> *firstCharacter = [[key substringToIndex:<span class="number">1</span>] lowercaseString];</span><br><span class="line">    [key replaceCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>) withString:firstCharacter];</span><br><span class="line">    <span class="comment">//处理字符串，比如吧setName:处理为name</span></span><br><span class="line">    Demo *typedSelf = (Demo *)<span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        typedSelf.propertyDictionary[key] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        [typedSelf.propertyDictionary removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(setName:) || sel == <span class="keyword">@selector</span>(setSex:)) &#123;</span><br><span class="line">        <span class="comment">//是Set方法</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)dynmaicSetMethod, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(name) || sel == <span class="keyword">@selector</span>(sex)) &#123;</span><br><span class="line">        <span class="comment">//是get方法</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)dynmaicGetMethod, <span class="string">&quot;@:@&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里注销 helper 返回值是为了消息继续向下传递，调用 forwardInvocation: 方法</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line"><span class="comment">//    if (aSelector == @selector(myPrint:)) &#123;</span></span><br><span class="line"><span class="comment">//        return helper;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 forwardInvocation: 方法前需要先调用此方法生成方法签名</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">        <span class="comment">//生成方法签名</span></span><br><span class="line">        signature = [helper methodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="keyword">if</span> (!helper) &#123;</span><br><span class="line">        [<span class="keyword">self</span> doesNotRecognizeSelector: [anInvocation selector]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改参数</span></span><br><span class="line">    <span class="built_in">NSString</span> *message = <span class="string">@&quot;This is a message&quot;</span>;</span><br><span class="line">    [anInvocation setArgument:&amp;message atIndex:<span class="number">2</span>];</span><br><span class="line">    [anInvocation invokeWithTarget:helper];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>① 中所说的第四个参数是 <code>types</code>：描述方法参数类型的字符数组。有关可能的值，请参阅<a href="https://developer.apple.com/library/etc/redirect/xcode/content/1189/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048">Objective-C Runtime Programming Guide</a> &gt; <a href="https://developer.apple.com/library/etc/redirect/xcode/content/1189/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100">Type Encodings</a>。由于函数至少需要两个参数 <code>self</code> 和 <code>_cmd</code>，所以第二个和第三个字符必须是“@：”（第一个字符是返回类型）。</p>
<p>举个例子：</p>
<p>“v@:”</p>
<ul>
<li>v：返回值为 <code>void</code></li>
<li>@：参数 <code>self</code></li>
<li>“:”：选择器 <code>SEL(_cmd)</code> </li>
<li>无参数</li>
</ul>
<p>“i@:@”</p>
<ul>
<li>i：返回值类型为 <code>int</code></li>
<li>@：同上</li>
<li>“:”：同上</li>
<li>@：参数（id）</li>
</ul>
<p>我们运行代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Demo *demo = [[Demo alloc] init];</span><br><span class="line">demo.name = <span class="string">@&quot;Tom&quot;</span>;</span><br><span class="line">demo.sex = <span class="string">@&quot;Male&quot;</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;name: %@, sex: %@&quot;</span>, demo.name, demo.sex);</span><br><span class="line"></span><br><span class="line">[demo myPrint:<span class="string">@&quot;demo print&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">dynmaicSetMethod</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">dynmaicSetMethod</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">dynmaicGetMethod</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">dynmaicGetMethod</span><br><span class="line">name: Tom, sex: Male</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">-[Demo forwardingTargetForSelector:]</span><br><span class="line">-[Demo methodSignatureForSelector:]</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">+[Demo resolveInstanceMethod:]</span><br><span class="line">-[Demo forwardInvocation:]</span><br><span class="line">DemoHelper: This is a message</span><br></pre></td></tr></table></figure>

<p><strong>要点：</strong></p>
<ul>
<li>若对象无法响应某个选择器，则进入消息转发流程。</li>
<li>通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。</li>
<li>对象可以把其无法解读的某些选择器转交给其他对象来处理。</li>
<li>经过上述两步之后，如果还是没办法处理选择器，那就启动完整的消息转发机制。</li>
</ul>
<h3 id="用方法调配（method-swizzling）技术调试“黑盒方法”"><a href="#用方法调配（method-swizzling）技术调试“黑盒方法”" class="headerlink" title="用方法调配（method swizzling）技术调试“黑盒方法”"></a>用方法调配（method swizzling）技术调试“黑盒方法”</h3><hr>
<p>与给定的选择器名称相对应的方法也是可以在运行期改变的。我们既不需要源代码，也不需要通过继承子类型来覆写方法就能改变这个类本身的功能。这样一来，新功能将在本类的所有实例中生效，而不是仅限于覆写了相关方法的那些子类实例。此方案经常称为“方法调配”（method swizzling）。</p>
<p>类方法列表会把选择器的名称映射到相关的方法之上，使得“动态消息派发系统”能够据此找到应该调用的方法。这些方法均以函数指针的形式来表示，这种指针叫做 IMP，其原型如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...)</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<p><code>Demo</code> 中有一个 <code>lowercase</code> 方法，现在我们在 <code>Demo</code> 的类别 <code>SubDemo</code> 中交换两个方法的实现。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Demo</span> (<span class="title">SubDemo</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        </span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(lowercase);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(uppercase);</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  我们在这里使用 class_addMethod() 函数对 originalMethod 做了一层验证，如果 self 没有实现被交换的方法，会导致失败。</span></span><br><span class="line"><span class="comment">         *  而且 self 没有交换的方法实现，但是父类有这个方法，这样就会调用父类的方法，结果就不是我们想要的结果了。</span></span><br><span class="line"><span class="comment">         *  所以我们在这里通过 class_addMethod() 的验证，如果 self 实现了这个方法，class_addMethod() 函数将会返回 NO，我们就可以对其进行交换了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Boolean didAddMethod = class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">                                               originalSelector,</span><br><span class="line">                                               method_getImplementation(swizzledMethod),</span><br><span class="line">                                               method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">            class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">                            swizzledSelector,</span><br><span class="line">                            method_getImplementation(originalMethod),</span><br><span class="line">                            method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)uppercase &#123;</span><br><span class="line">    <span class="comment">// 这时候调用的其实是 Demo 类的 lowercase 方法</span></span><br><span class="line">    [<span class="keyword">self</span> uppercase];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;SubDemo uppercase&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Demo lowercase</span><br><span class="line">SubDemo uppercase</span><br></pre></td></tr></table></figure>

<p><strong>要点：</strong></p>
<ul>
<li>在运行期，可以向类中新增或替换选择器所对应的方法实现。</li>
<li>使用另一份实现来替换原有的方法实现，这道工序叫做“方法调配”，开发者常用此技术向原有的实现中添加新功能。</li>
<li>一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。</li>
</ul>
<h3 id="理解“类对象”的用意"><a href="#理解“类对象”的用意" class="headerlink" title="理解“类对象”的用意"></a>理解“类对象”的用意</h3><hr>
<p>描述 Objective-C 对象所用的数据结构定义在运行期程序库的头文件里，<code>id</code> 类型本身也定义在这里：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125; *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>

<p>由此可见，每个对象结构体的首个成员是 <code>Class</code> 类的变量。该变量定义了对象所属的类，通常称为“is a”指针。例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@&quot;Some string&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>这里的对象“是一个”（is a）<code>NSString</code>，所以其“is a”指针就指向 <code>NSString</code>。</strong><code>Class</code> 对象也定义在运行期程序库的头文件中：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class super_class;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">long</span> version;</span><br><span class="line">    <span class="keyword">long</span> info;</span><br><span class="line">    <span class="keyword">long</span> instance_size;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此结构体存放类的“元数据”（metadata），例如类的实力实现了几个方法，具备多少个实例变量等信息。此结构体的首个变量也是 <code>isa</code> 指针，这说明 <code>Class</code> 本身亦为 Objective-C 对象。结构体里还有个变量叫做 <code>super_class</code>，它定义了本类的超类。类对象所属的类型（也就是 <code>isa</code> 指针所指向的类型）是另外一个类，叫做“元类”（metaclass），用来表述类对象本身所具备的元数据。<strong>“类方法”就定义与此处</strong>，因为这些方法可以理解成类对象的实例方法。每个类仅有一个“类对象”，而每个“类对象”仅有一个与之相关的“元类”。</p>
<p>假设有个名为 <code>SomeClass</code> 的子类从 <code>NSObject</code> 中继承而来，则其继承体系如图所示：</p>
<p>![](/my_pictures/Objective-C 基础温习【二】之 对象、消息、运行期-3.png)</p>
<p><strong><code>super_class</code> 指针确立了继承关系，而 <code>isa</code> 指针描述了实例所属的类。</strong>通过这张布局关系图即可执行“类型信息查询”。我们可以查出对象是否能相应某个选择器，是否遵从某项协议，并且能看出此对象位于“类继承体系”的哪一部分。</p>
<h4 id="在类继承体系中查询类型信息"><a href="#在类继承体系中查询类型信息" class="headerlink" title="在类继承体系中查询类型信息"></a>在类继承体系中查询类型信息</h4><p><strong>可以用类型信息查询方法类检视类继承体系。<code>isMemberOfClass:</code>能够判断出对象是否为某个特定类的实例，而<code>isKindOfClass:</code>则能够判断出对象是否为其类或派生类的实例。</strong>例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Demo *demo = [[Demo alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [demo isMemberOfClass:[Demo <span class="keyword">class</span>]]); <span class="comment">// YES</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [demo isMemberOfClass:[SubForDemo <span class="keyword">class</span>]]); <span class="comment">// NO</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [demo isKindOfClass:[Demo <span class="keyword">class</span>]]); <span class="comment">// YES</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, [demo isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]); <span class="comment">// NO</span></span><br></pre></td></tr></table></figure>

<p><strong>要点：</strong></p>
<ul>
<li>每个实例都有一个指向 <code>Class</code> 对象的指针，用以表明其类型，而这些 <code>Class</code> 对象则构成了类的继承体系。</li>
<li>如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。</li>
<li>尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。</li>
</ul>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 并发，锁，线程同步【二】Operation</title>
    <url>/2018/04/30/2018-04-30-iOS%20%E5%B9%B6%E5%8F%91%EF%BC%8C%E9%94%81%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E3%80%90%E4%BA%8C%E3%80%91Operation/</url>
    <content><![CDATA[<p>在之前的一篇文章中【<a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/2018/04/16/iOS-%E5%B9%B6%E5%8F%91-%E9%94%81-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E4%B8%80-GCD/">iOS 并发，锁，线程同步【一】GCD</a>】，我们讨论了一下 <code>GCD</code> 的并发，锁和线程同步的问题，今天，我们来讨论一下 <code>Operation</code> 的并发与线程同步。</p>
<p>在 <code>Operation</code> 中，我们一般是将所有的 <code>Operation</code> 添加到 <code>OperationQueue</code> 中进行执行，这里需要注意一点，**<code>Operation</code> 添加到队列当中，默认就是执行的并发操作。<strong>我们可以设置队列的最大并发数 <code>maxConcurrentOperationCount</code>。如果我们在 <code>OperationQueue</code> 中想要执行串行任务的话，很简单，将 <code>maxConcurrentOperationCount</code> 设置成为1即可。 <code>maxConcurrentOperationCount</code> 的默认值为-1，那么默认情况下的并发数是多少呢？</strong>这个是由系统内存和 CPU 决定的，可能内存多久开多一点，内存少就开少一点。**最大并发数建议 2~3，如果并发数太多会导致 UI 卡顿。</p>
<p>不添加到队列当中的 <code>Operation</code>，我们可以调用 <code>start()</code> 方法开始一个操作，也可以调用 <code>cancel()</code> 取消等待中的操作，注意：<strong>已经开始执行的操作是没法取消的。</strong>代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> opt = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Operation&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">opt.start() <span class="comment">// 开始执行任务</span></span><br><span class="line">opt.cancel() <span class="comment">// 取消等待中的任务</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>如果我们需要进行线程同步该怎么做？GCD 中我们可以用 <code>DispatchGroup</code>，在 <code>Operation</code> 中我们可以用一个 <code>addDependency()</code> 的方法。这个方法意味着，某个任务的执行，依赖着其他任务执行完成后才回去执行。代码我们可以这么写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">OperationQueue</span>()</span><br><span class="line">queue.maxConcurrentOperationCount = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">c</span>.addDependency(a)</span><br><span class="line"><span class="built_in">c</span>.addDependency(b)</span><br><span class="line"></span><br><span class="line">queue.addOperation(<span class="built_in">c</span>)</span><br><span class="line">queue.addOperation(a)</span><br><span class="line">queue.addOperation(b)</span><br></pre></td></tr></table></figure>

<p>这里的 <code>c</code> 操作，需要等到 <code>a</code>, <code>b</code> 完成之后才会执行。运行结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">b</span><br><span class="line">a</span><br><span class="line"><span class="built_in">c</span></span><br></pre></td></tr></table></figure>

<p>OK，接下来我们来一点在并发中进行数据写入的操作，代码作如下修改：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">OperationQueue</span>()</span><br><span class="line">queue.maxConcurrentOperationCount = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> ary: [<span class="type">Int</span>] = []</span><br><span class="line"><span class="keyword">let</span> a = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">        ary.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> <span class="number">5</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">        ary.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(ary.sorted())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">c</span>.addDependency(a)</span><br><span class="line"><span class="built_in">c</span>.addDependency(b)</span><br><span class="line"></span><br><span class="line">queue.addOperation(<span class="built_in">c</span>)</span><br><span class="line">queue.addOperation(a)</span><br><span class="line">queue.addOperation(b)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>很明显，运行结果是错的。并发当中对同一个数据源进行写的操作时，一定要注意加锁。具体可以看我的上一遍文章：<a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/2018/04/16/iOS-%E5%B9%B6%E5%8F%91-%E9%94%81-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E4%B8%80-GCD/">iOS 并发，锁，线程同步【一】GCD</a>，这里我就不在啰嗦。</p>
<p>接下来，我们做一点代码优化，如果我想要实现 n 个任务，每个任务都是向数组中添加数字，每个任务的循环范围按照 0<del>5，5</del>10，10~15 这样的规律，最后我们输出 <code>ary</code> 中的值。</p>
<p>很明显，向上面的写法太过笨拙。那么我们进行一个函数的抽象，我们先来写一个产生 task 的函数。</p>
<p>首先我们先来定义一个 task：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> task = () -&gt; ()</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要将产生的 task 添加到数组中，这里需要充分利用函数式编程的优点，方法看起来是这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeTask</span><span class="params">(taskCount: Int, opt: @escaping <span class="params">(<span class="keyword">_</span> currentIdx: Int)</span></span></span> -&gt; task) -&gt; [task] &#123;</span><br><span class="line">    <span class="comment">// 如果任务数为0，就返回空数组</span></span><br><span class="line">    <span class="keyword">guard</span> taskCount &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tasks: [task] = []</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="number">0</span>..&lt;taskCount &#123;</span><br><span class="line">        tasks.append(opt(idx))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tasks</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个参数 taskCount 是最大任务数，第二个参数 opt 是执行的任务，是一个闭包，<strong>因为任务会存到一个数组中，供后面的方法使用，所以这个闭包是可逃逸的。</strong>我们在执行闭包的时候，需要传入一个参数，这个参数表示了当前生成的是第几个 task，返回值也是个闭包，也就是我们最终要执行的 task。OK，经过函数化，我们就可以产生<strong>任意数量、任意操作</strong>的 task 了。</p>
<p>接下来我们来处理一下并发的方法，它看起来是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concurrent</span><span class="params">(tasks: [task], complationHandle: @escaping <span class="params">()</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    <span class="keyword">let</span> sema = <span class="type">DispatchSemaphore</span>(value: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> queue = <span class="type">OperationQueue</span>()</span><br><span class="line">    queue.maxConcurrentOperationCount = <span class="number">3</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">        complationHandle()</span><br><span class="line">    &#125;</span><br><span class="line">    tasks.forEach &#123; t <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> o = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">            sema.wait()</span><br><span class="line">            t()</span><br><span class="line">            sema.signal()</span><br><span class="line">        &#125;</span><br><span class="line">        result.addDependency(o)</span><br><span class="line">        queue.addOperation(o)</span><br><span class="line">    &#125;</span><br><span class="line">    queue.addOperation(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理也很简单，我们在一个 <code>forEach</code> 当中设置好 <code>Operation</code> 的 task 与依赖关系。这里用了信号量锁，来保证数据的正确性。最后我们在 <code>complationHandle</code> 这个闭包中处理同步后的数据。</p>
<p>我们来使用一下，感受一下函数式的灵活、强大之处：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ary: [<span class="type">Int</span>] = []</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> tasks = makeTask(taskCount: <span class="number">20</span>) &#123; idx <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;task idx: \(idx)&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> (idx * <span class="number">5</span>)..&lt;(idx * <span class="number">5</span> + <span class="number">5</span>) &#123;</span><br><span class="line">            ary.append(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">concurrent(tasks: tasks) &#123;</span><br><span class="line">    <span class="built_in">print</span>(ary.sorted())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">task idx: <span class="number">0</span></span><br><span class="line">task idx: <span class="number">1</span></span><br><span class="line">task idx: <span class="number">2</span></span><br><span class="line">task idx: <span class="number">3</span></span><br><span class="line">task idx: <span class="number">5</span></span><br><span class="line">task idx: <span class="number">6</span></span><br><span class="line">task idx: <span class="number">4</span></span><br><span class="line">task idx: <span class="number">7</span></span><br><span class="line">task idx: <span class="number">9</span></span><br><span class="line">task idx: <span class="number">10</span></span><br><span class="line">task idx: <span class="number">11</span></span><br><span class="line">task idx: <span class="number">8</span></span><br><span class="line">task idx: <span class="number">13</span></span><br><span class="line">task idx: <span class="number">12</span></span><br><span class="line">task idx: <span class="number">14</span></span><br><span class="line">task idx: <span class="number">15</span></span><br><span class="line">task idx: <span class="number">18</span></span><br><span class="line">task idx: <span class="number">16</span></span><br><span class="line">task idx: <span class="number">17</span></span><br><span class="line">task idx: <span class="number">19</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">84</span>, <span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>]</span><br></pre></td></tr></table></figure>

<p>调用还是有点麻烦？没关系我们可以将两个方法合成一个，我们把 <code>makeTask</code> 与 <code>concurrent</code> 方法设置成为私有（private），接下来写一个开放接口方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">tasksToConcurrent</span><span class="params">(taskCount: Int, opt: @escaping <span class="params">(<span class="keyword">_</span> currentIdx: Int)</span></span></span> -&gt; task, complationHandle: @escaping () -&gt; ()) &#123;</span><br><span class="line">    <span class="keyword">let</span> tasks = makeTask(taskCount: <span class="number">20</span>) &#123; idx <span class="keyword">in</span> <span class="keyword">return</span> opt(idx) &#125;</span><br><span class="line">    concurrent(tasks: tasks, complationHandle: complationHandle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们就可以这样来调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tasksToConcurrent(taskCount: <span class="number">20</span>, opt: &#123; idx <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;task idx: \(idx)&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> (idx * <span class="number">5</span>)..&lt;(idx * <span class="number">5</span> + <span class="number">5</span>) &#123;</span><br><span class="line">            ary.append(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(ary.sorted())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>感觉比刚开始的写法简洁了不少！！！</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C 回顾【三】之 内存管理</title>
    <url>/2018/05/11/2018-05-11-Objective-C%20%E5%9B%9E%E9%A1%BE%E3%80%90%E4%B8%89%E3%80%91%E4%B9%8B%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="理解引用计数"><a href="#理解引用计数" class="headerlink" title="理解引用计数"></a>理解引用计数</h2><hr>
<p>Objective-C 语言使用引用计数来管理内存，也就是说，每个对象都有个可以递增或递减的计数器。如果想使某个对象继续存活，那就递增其引用计数；用完了之后，就递减其计数。计数变为 O，就表示没人关注此对象了，于是，就可以把它销毁。</p>
<h3 id="引用计数工作原理"><a href="#引用计数工作原理" class="headerlink" title="引用计数工作原理"></a>引用计数工作原理</h3><p>Objective-C 中，调用 <code>alloc</code> 方法所返回的对象由调用者所拥有。也就是说，调用者已通过 <code>alloc</code> 方法表达了想令该对象继续存活下去的意愿。不过请注意，这并不是说对象此时的保留计数必定是 1。在 <code>alloc</code> 或。<code>initWithInt:</code> 方法的实现代码中，也许还有其他对象也保留了此对象，所以，其保留计数可能会大于 1。能够肯定的是：保留计数至少为 1。保留计数这个概念就应该这样来理解才对。绝不应该说保留计数一定是某个值，只能说你所执行的操作是递增了该计数还是递减了该计数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"><span class="built_in">NSNumber</span> *number = [[<span class="built_in">NSNumber</span> alloc] initWithInt:<span class="number">1337</span>];</span><br><span class="line"></span><br><span class="line">[array addObject:number];</span><br><span class="line">[number release];</span><br><span class="line"></span><br><span class="line"><span class="comment">// do something with &#x27;array&#x27;</span></span><br><span class="line"></span><br><span class="line">[array release];</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>如上面的代码，创建完数组后，把 <code>number</code> 对象加人其中。调用数组的 <code>addobject:</code> 方法时，数组也会在 <code>number</code> 上调用 <code>retain</code> 方法，以期继续保留此对象。这时，保留计数至少为 2。接下来，代码不再需要 <code>number</code> 对象了，于是将其释放。现在的保留计数至少为 1。这样就不能照常使用 <code>number</code> 变量了。调用 <code>release</code> 之后，已经无法保证所指的对象仍然存活。当然，根据本例中的代码，我们显然知道 <code>number</code> 对象在调用了 <code>release</code> 之后仍然存活。因为数组还在引用着它。然而绝不应假设此对象一定存活，也就是说，不要像下面这样编写代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *number = [[<span class="built_in">NSNumber</span> alloc] initWithInt:<span class="number">1337</span>];</span><br><span class="line">[array addObject:number];</span><br><span class="line">[number release];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@&quot;number = %@&quot;</span>, number);</span><br></pre></td></tr></table></figure>

<p>即便上述代码在本例中可以正常执行，也仍然不是个好办法。如果调用 <code>release</code> 之后，基于某些原因，其保留计数降至 O，那么 <code>number</code> 对象所占内存也许会回收，这样的话，再调用 <code>NSLog</code> 可能就将使程序崩溃了。笔者在这里只说“可能”，而没说“一定”，因为对象所占的内存在“解除分配”（deallocated）之后，只是放回“可用内存池”（avaiable pool）。如果执行 <code>NSLog</code> 时尚未覆写对象内存，那么该对象仍然有效，这时程序不会崩溃。由此可见：因过早释放对象而导致的 bug 很难调试。</p>
<p>为避免在不经意间使用了无效对象，一般调用完 <code>release</code> 之后都会清空指针。这就能保证不会出现可能指向无效对象的指针，这种指针通常称为“悬垂指针”。比方说，可以这样编写代码来防止此情况发生：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *number = [[<span class="built_in">NSNumber</span> alloc] initWithInt:<span class="number">1337</span>];</span><br><span class="line">[array addObject:number];</span><br><span class="line">[number release];</span><br><span class="line"></span><br><span class="line">number = <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure>

<h3 id="属性存取方法中的内存管理"><a href="#属性存取方法中的内存管理" class="headerlink" title="属性存取方法中的内存管理"></a>属性存取方法中的内存管理</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setFoo:(<span class="keyword">id</span>)foo &#123;</span><br><span class="line">    [foo <span class="keyword">retain</span>];</span><br><span class="line">    [_foo release];</span><br><span class="line">    _foo = foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法将保留新值并释放旧值，然后更新实例变量，令其指向新值。顺序很重要。假如还未保留新值就先把旧值释放了，而且两个值又指向同一个对象，那么，先执行的 <code>release</code> 操作就可能导致系统将此对象永久回收。而后续的 <code>retain</code> 操作则无法令这个已经彻底回收的对象“复生”，于是实例变量就成了悬垂指针（nil）。</p>
<h3 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h3><p><code>autorelease</code> 此方法会在稍后递减计数，通常是在下一次“事件循环”时递减，不过也可能执行得更早些。</p>
<p>此特性很有用，尤其是在方法中返回对象时更应该用它。比如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)stringValue &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] </span><br><span class="line">                        initWithFormat:<span class="string">@&quot;I am this: %@&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里不能在方法内释放 <code>str</code> 否则还没等方法返回，系统就把该对象回收了。这里应该调用 <code>autorelease</code>，它会在稍后释放对象，从而给调用者留下了足够长的时间，使其可以在需要时先保留返回值。换句话说，此方法可以保证对象在跨越“方法调用边界”后一定存活。实际上，释放操作会在清空最外层的自动释放池时执行，除非你有自己的自动释放池，否则这个时机指的就是当前线程的下一次事件循环。改写 <code>stringValue</code> 方法，使用 <code>autorelease</code> 来释放对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)stringValue &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] </span><br><span class="line">                        initWithFormat:<span class="string">@&quot;I am this: %@&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">return</span> [str autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改之后，<code>stringValue</code> 方法把 <code>NSString</code> 对象返回给调用者时，此对象必然存活。所以我们能够像下面这样使用它：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = [<span class="keyword">self</span> stringValue];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;The string is: %@&quot;</span>, str);</span><br></pre></td></tr></table></figure>

<p>因为自动释放池中的释放操作要等到下一次事件循环时才会执行，所以 <code>NSLog</code> 语句在使用 <code>str</code> 对象前不需要手工执行保留操作。但是，假如要持有此对象的话（比如将其设置给实例变量），那就需要保留，并于稍后释放：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_instanceVariable = [[<span class="keyword">self</span> stringValue] <span class="keyword">retain</span>];</span><br><span class="line">[_instanceVariable release];</span><br></pre></td></tr></table></figure>

<p>由此可见，<code>autorelease</code> 能延长对象生命期，使其在跨越方法调用边界后依然可以存活一段时间。</p>
<p><strong>要点：</strong></p>
<ul>
<li>引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为 1。若保留计数为正，则对象继续存活。当保留计数降为 0 时，对象就被销毁了。</li>
<li>在对象生命周期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增递减保留计数。</li>
</ul>
<h2 id="以-ARC-简化引用计数"><a href="#以-ARC-简化引用计数" class="headerlink" title="以 ARC 简化引用计数"></a>以 ARC 简化引用计数</h2><hr>
<h3 id="变量的内存管理语义"><a href="#变量的内存管理语义" class="headerlink" title="变量的内存管理语义"></a>变量的内存管理语义</h3><ul>
<li>__strong：默认语义，保留此值。</li>
<li>__unsafe_unretained：不保留此值，这么做可能不安全，因为等到再次使用变量时，其对象可能已经回收了。</li>
<li>__weak：不保留此值，但是变量可以安全使用，因为如果系统把这个对象回收了，那么变量也会自动清空。</li>
<li>__autoreleasing：把对象“按引用传递”给方法时，使用这个特殊的修饰符。此值在方法返回时自动释放。</li>
</ul>
<p>我们经常会给局部变量加上修饰符，用以打破由“块”所引入的“引用循环”。块会自动保留其所捕获的全部对象，而如果这其中有某个对象又保留了块本身，那么就可能导致“引用循环”。可以用 <code>__weak</code> 局部变量来打破这种“引用循环”。</p>
<p><strong>要点：</strong></p>
<ul>
<li>有 ARC 之后，程序员就无须担心内存管理问题了。使用 ARC 来编程，可以省去类中的许多“样板代码”。</li>
<li>ARC 管理对象生命期的办法基本上就是：在合适的地方插入“保留”及“释放”操作。在 ARC 环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行“保留”及“释放”操作。</li>
<li>由方法所返回的对象，其内存管理语义总是通过方法名来体现。ARC 将此确定为开发者必须遵守的规则。</li>
<li>ARC 只负责管理 Objective-C 对象的内存。尤其要注意：CoreFoundation 对象不归 ARC 管理，开发者必须适时调用 CFRetain/CFRelease。</li>
</ul>
<h2 id="在-dealloc-方法中只释放引用并解除监听"><a href="#在-dealloc-方法中只释放引用并解除监听" class="headerlink" title="在 dealloc 方法中只释放引用并解除监听"></a>在 dealloc 方法中只释放引用并解除监听</h2><hr>
<p><strong>要点：</strong></p>
<ul>
<li>在 <code>dealloc</code> 方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的“键值观测”（KVO）或 <code>NSNotificationCenter</code> 等通知，不要做其他事情。</li>
<li>如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用 <code>close</code> 方法。</li>
<li>执行异步任务的方法不应在 <code>dealloc</code> 里调用；只能在正常状态下执行的那些方法也不应在 <code>dealloc</code> 里调用，因为此时对象已处于正在回收的状态了。</li>
</ul>
<p>未完持续…</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>在 macOS 中用命令格式化 APFS 格式 U 盘</title>
    <url>/2018/05/21/2018-05-21-%E5%9C%A8%20macOS%20%E4%B8%AD%E7%94%A8%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F%E5%8C%96%20APFS%20%E6%A0%BC%E5%BC%8F%20U%20%E7%9B%98/</url>
    <content><![CDATA[<p>今天需要去打印店打印东西，但是 U 盘被我格式化成了 <code>APFS</code> 格式，用磁盘管理工具无法格式化成其他的格式，选项中只有 <code>APFS</code> 的选项。我用如下的命令格式化 U 盘：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo diskutil eraseDisk JHFS+ san &#x2F;dev&#x2F;disk3</span><br></pre></td></tr></table></figure>

<p>但是执行命令会报错，错误信息大致是，无法格式化 <code>APFS</code> 容器。</p>
<p><code>/dev/disk3</code> 是我 U 盘的目录，在执行之前请先确认自己的目录，用如下的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">diskutil list </span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><code>APFS</code> 格式是无法直接进行格式化的，我们需要首先删除 <code>APFS</code> 容器。执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo diskutil apfs deleteContainer &#x2F;dev&#x2F;disk3</span><br></pre></td></tr></table></figure>

<p>然后你就会发现，你的 U 盘格式自动变成了 Mac OS 扩展(日志式)，之后就可以格式化成 exFAT 格式了。但是打印店识别不了，最后还是要在 windows 下格式化成 FAT32。</p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 4.2 中有什么新功能？【译】</title>
    <url>/2018/06/13/2018-06-13-Swift%204.2%20%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B0%E5%8A%9F%E8%83%BD%E3%80%90%E8%AF%91%E3%80%91/</url>
    <content><![CDATA[<p>好消息：Swift 4.2 现已在 Xcode 10 beta 中提供！此版本更新重要的 Swift 4.1 功能，并改进语言以准备 ABI 稳定性。 </p>
<p>本教程介绍了 Swift 4.2 中最重要的变化。它需要 Xcode 10，因此请确保你在开始之前下载并安装 Xcode 的最新测试版。</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>Swift 4.2 与 Swift 4.1 的源代码兼容，但与任何其他版本不兼容。 Apple 设计的 Swift 4.2 是在 Swift 5 中实现 ABI 稳定性的中间步骤，它应该能够在不同 Swift 版本编译的应用和库中保持二进制兼容。在集成到最终的 <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a> 之前，ABI 功能会有大量的时间来获得来自社区的反馈。</p>
<p>本教程的部分包含 <a href="https://apple.github.io/swift-evolution/">Swift Evolution</a> 提案编号，如 <code>[SE-0001]</code> 。你可以通过点击每个提案的链接标签来浏览每个更改的详细信息。</p>
<a id="more"></a>

<p>如果你尝试了 <code>playground </code> 上的更改，你将从本教程中获得最大收益。启动 Xcode 10 并转到 <strong>File ▸ New ▸ Playgruond</strong>。选择 <code>iOS</code> 平台和 <code>Blank</code> 模版。把它命名为任何你喜欢的东西，然后把它保存在你想要的任何地方。你现在准备好开始了！</p>
<blockquote>
<p>Note: 需要重温 Swift 4.1 亮点？查看我们的 Swift 4.1 教程：<a href="https://www.raywenderlich.com/187826/whats-new-in-swift-4-1">Swift 4.1 有哪些新特性？</a></p>
</blockquote>
<h3 id="语言的改进"><a href="#语言的改进" class="headerlink" title="语言的改进"></a>语言的改进</h3><hr>
<p>这个版本中有很多语言功能的改进，例如随机数生成器，动态成员查询等等。</p>
<h4 id="生成随机数字"><a href="#生成随机数字" class="headerlink" title="生成随机数字"></a>生成随机数字</h4><p>Swift 4.1 导入 C API 来生成随机数字，如下面的代码片段所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> digit = <span class="type">Int</span>(arc4random_uniform(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<p><code>arc4random_uniform(_:)</code> 返回 0 到 9 之间的随机数字。它需要你导入 <code>Foundation</code> 框架，并且不能工作在 Linux 上。<br>另一方面，所有基于 Linux 的方法都引入了<strong>模偏差（modulo bias）</strong>，这意味着某些数字比其他数字更频繁地产生。</p>
<p>Swift 4.2 通过向标准库 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0202-random-unification.md">[SE-0202]</a> 添加随机API来解决这些问题：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1  </span></span><br><span class="line"><span class="keyword">let</span> digit = <span class="type">Int</span>.random(<span class="keyword">in</span>: <span class="number">0</span>..&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> anotherDigit = (<span class="number">0</span>..&lt;<span class="number">10</span>).randomElement() &#123;</span><br><span class="line">  <span class="built_in">print</span>(anotherDigit)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Empty range.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> double = <span class="type">Double</span>.random(<span class="keyword">in</span>: <span class="number">0</span>..&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> float = <span class="type">Float</span>.random(<span class="keyword">in</span>: <span class="number">0</span>..&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> cgFloat = <span class="type">CGFloat</span>.random(<span class="keyword">in</span>: <span class="number">0</span>..&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> bool = <span class="type">Bool</span>.random()</span><br></pre></td></tr></table></figure>

<p>这是做什么的：</p>
<ol>
<li>使用 <code>random(in:)</code> 从指定的范围生成随机数字。</li>
<li>如果范围是空的，<code>randomElement()</code> 返回 nil，所以需要用 <code>if let</code> 来处理 <code>Int?</code>。</li>
<li>可以使用 <code>random(in:)</code> 来产生一个随机的 <code>Double</code>，<code>Float</code> 或者 <code>CGFloat</code> 和 <code>random()</code> 来返回一个随机的 <code>Bool</code>。</li>
</ol>
<p><img src="/my_pictures/Swift4.2%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B0%E5%8A%9F%E8%83%BD-1.png" alt="Generating random numbers like a pro in Swift 4.2!"></p>
<p>Swift 4.1 还使用 C 函数从数组中生成随机值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> playlist = [<span class="string">&quot;Nothing Else Matters&quot;</span>, <span class="string">&quot;Stairway to Heaven&quot;</span>, <span class="string">&quot;I Want to Break Free&quot;</span>, <span class="string">&quot;Yesterday&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> index = <span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(playlist.<span class="built_in">count</span>)))</span><br><span class="line"><span class="keyword">let</span> song = playlist[index]</span><br></pre></td></tr></table></figure>

<p>Swift 4.1 使用 <code>arc4random_uniform(_:)</code> 从 <code>playlist</code> 生成一个有效的索引（index）并返回相应的 <code>song</code>。<br>这个解决方案需要在 <code>Int</code> 和 <code>UInt32</code> 之间转换，并且还有所有前面提到的问题。</p>
<p>Swift 4.2 采用更直接的方式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> song = playlist.randomElement() &#123;</span><br><span class="line">  <span class="built_in">print</span>(song)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Empty playlist.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>playlist</code> 为空 <code>randomElement()</code> 将返回 <code>nil</code>，所以需要处理返回的 <code>String?</code>。</p>
<p>Swift 4.1 没有包含任何集合混洗算法（collection shuffling algorithms），所以必须使用迂回的方式来达到预期的结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> shuffledPlaylist = playlist.sorted&#123; <span class="keyword">_</span>, <span class="keyword">_</span> <span class="keyword">in</span> arc4random_uniform(<span class="number">2</span>) == <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">&quot;Cosmin&quot;</span>, <span class="string">&quot;Oana&quot;</span>, <span class="string">&quot;Sclip&quot;</span>, <span class="string">&quot;Nori&quot;</span>]</span><br><span class="line">names.<span class="built_in">sort</span> &#123; <span class="keyword">_</span>, <span class="keyword">_</span> <span class="keyword">in</span> arc4random_uniform(<span class="number">2</span>) == <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这是在这段代码中所做的：</p>
<ol>
<li>可以使用 <code>arc4random_uniform(_:)</code> 来确定 <code>playlist</code> 的混排顺序，并用 <code>sorted(_:_:)</code> 函数返回 <code>shuffledPlaylist</code> 。</li>
<li>然后使用先前的技术将混乱的名称用 <code>sort(_:_:)</code> 函数排序。</li>
</ol>
<p>Swift 4.2 提供了更高效，可以说更优雅的<a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">混洗算法</a>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shuffledPlaylist = playlist.shuffled()</span><br><span class="line">names.shuffle()</span><br></pre></td></tr></table></figure>

<p>在 4.2 中，只需使用 <code>shuffled()</code> 创建混洗播放列表（playlist）并在 <code>shuffled()</code> 上随机播放名称。<br>Boom！</p>
<p><img src="/my_pictures/Swift4.2%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B0%E5%8A%9F%E8%83%BD-2.png" alt="Shuffling playlists has never been easier thanks to Swift 4.2!"></p>
<h4 id="动态成员查询"><a href="#动态成员查询" class="headerlink" title="动态成员查询"></a>动态成员查询</h4><p>Swift 4.1 对自定义下标调用使用以下方括号语法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> age: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> details: [<span class="type">String</span>: <span class="type">String</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>, details: [<span class="type">String</span>: <span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">    <span class="keyword">self</span>.details = details</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">subscript</span>(key: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> key &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;info&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\(name) is \(age) years old.&quot;</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> details[key] ?? <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> details = [<span class="string">&quot;title&quot;</span>: <span class="string">&quot;Author&quot;</span>, <span class="string">&quot;instrument&quot;</span>: <span class="string">&quot;Guitar&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> me = <span class="type">Person</span>(name: <span class="string">&quot;Cosmin&quot;</span>, age: <span class="number">32</span>, details: details)</span><br><span class="line">me[<span class="string">&quot;info&quot;</span>]   <span class="comment">// &quot;Cosmin is 32 years old.&quot;</span></span><br><span class="line">me[<span class="string">&quot;title&quot;</span>]  <span class="comment">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，下标将根据个人的姓名和年龄从私人数据存储或自定义消息中返回内容。</p>
<p>Swift 4.2 使用动态成员查找（dynamic member lookup）为下标提供点语法，而不是 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md">[SE-0195]</a>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="meta">@dynamicMemberLookup</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> age: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> details: [<span class="type">String</span>: <span class="type">String</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>, details: [<span class="type">String</span>: <span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">    <span class="keyword">self</span>.details = details</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">subscript</span>(dynamicMember key: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> key &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;info&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\(name) is \(age) years old.&quot;</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> details[key] ?? <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">me.info   <span class="comment">// &quot;Cosmin is 32 years old.&quot; </span></span><br><span class="line">me.title  <span class="comment">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>将 <code>Person</code> 标记为 <code>@dynamicMemberLookup</code> 以启用其自定义下标的点语法。</li>
<li>通过为类实现 <code>subscript(dynamicMember:)</code>，去掉用 <code>@dynamicMemberLookup</code>。</li>
<li>可以使用点语法调用先前自定义的下标。</li>
</ol>
<p>编译器会在运行时动态评估下标调用，这样可以写类型安全的代码，就像在 Python 或 Ruby 等脚本语言中编写类型安全的代码一样。 </p>
<p>动态成员查找不会混淆类属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">me.name <span class="comment">// &quot;Cosmin&quot;</span></span><br><span class="line">me.age <span class="comment">// 32</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，使用点语法来调用 <code>名称</code> 和 <code>age</code>，而不是下标。 </p>
<p>此外，派生类继承了动态成员查找的基础：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dynamicMemberLookup</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> brand: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> year: <span class="type">Int</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(brand: <span class="type">String</span>, year: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.brand = brand</span><br><span class="line">    <span class="keyword">self</span>.year = year</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">subscript</span>(dynamicMember key: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;\(brand) made in \(year).&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>: <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="type">Car</span>(brand: <span class="string">&quot;BMW&quot;</span>, year: <span class="number">2018</span>)</span><br><span class="line">car.info  <span class="comment">// &quot;BMW made in 2018.&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以使用点语法来调用汽车的下标，因为任何 <code>Car</code> 都是 <code>Vehicle</code>，并且 <code>Vehicle</code> 实现了 <code>@dynamicMemberLookup</code> 。</p>
<p>可以使用 <code>protocol extensions</code> 将动态成员查找添加到现有类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="meta">@dynamicMemberLookup</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Random</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Random</span> </span>&#123;</span><br><span class="line">  <span class="keyword">subscript</span>(dynamicMember key: <span class="type">String</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>.random(<span class="keyword">in</span>: <span class="number">0</span>..&lt;<span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">Random</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> number = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> randomDigit = <span class="type">String</span>(number.digit)</span><br><span class="line"><span class="keyword">let</span> noRandomDigit = <span class="type">String</span>(number).<span class="built_in">filter</span> &#123; <span class="type">String</span>($<span class="number">0</span>) != randomDigit &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 <code>@dynamicMemberLookup</code> 注释 <code>Random</code> 以启用其下标的点语法。 </li>
<li>可以通过实现 <code>subscript(dynamicMember:)</code> 来扩展协议并使其符合 <code>@dynamicMemberLookup</code>。下标使用 <code>random(in:)</code> 来返回 0 到 9 之间的随机数字。 </li>
<li>扩展 <code>Int</code> 并使其符合 <code>Random</code>。 </li>
<li>使用点语法来生成一个随机数字并从 <code>number</code> 中过滤出来。</li>
</ol>
<h4 id="枚举案例集合"><a href="#枚举案例集合" class="headerlink" title="枚举案例集合"></a>枚举案例集合</h4><hr>
<p>Swift 4.1 默认情况下不提供对枚举案例的访问。这样就留下了一些相当不雅的解决方案，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Seasons</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> spring = <span class="string">&quot;Spring&quot;</span>, summer = <span class="string">&quot;Summer&quot;</span>, autumn = <span class="string">&quot;Autumn&quot;</span>, winter = <span class="string">&quot;Winter&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SeasonType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> equinox</span><br><span class="line">  <span class="keyword">case</span> solstice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> seasons = [<span class="type">Seasons</span>.spring, .summer, .autumn, .winter]</span><br><span class="line"><span class="keyword">for</span> (index, season) <span class="keyword">in</span> seasons.enumerated() &#123;</span><br><span class="line">  <span class="keyword">let</span> seasonType = index % <span class="number">2</span> == <span class="number">0</span> ? <span class="type">SeasonType</span>.equinox : .solstice</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;\(season.rawValue) \(seasonType).&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，将 <code>Seasons</code> 添加到 <code>seasons</code>，并循环访问数组以获取每个季节的名称和类型。</p>
<p>但 Swift 4.2 可以做的更好！</p>
<p>Swift 4.2 将枚举案例数组添加到枚举中 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0194-derived-collection-of-enum-cases.md">[SE-0194]</a>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Seasons</span>: <span class="title">String</span>, <span class="title">CaseIterable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> spring = <span class="string">&quot;Spring&quot;</span>, summer = <span class="string">&quot;Summer&quot;</span>, autumn = <span class="string">&quot;Autumn&quot;</span>, winter = <span class="string">&quot;Winter&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SeasonType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> equinox</span><br><span class="line">  <span class="keyword">case</span> solstice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">for</span> (index, season) <span class="keyword">in</span> <span class="type">Seasons</span>.allCases.enumerated() &#123;</span><br><span class="line">  <span class="keyword">let</span> seasonType = index % <span class="number">2</span> == <span class="number">0</span> ? <span class="type">SeasonType</span>.equinox : .solstice</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;\(season.rawValue) \(seasonType).&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是如何在 Swift 4.2 中完成同样的事情：</p>
<ol>
<li>使 <code>Seasons</code> 继承 <code>CaseIterable</code> 以创建枚举案例。</li>
<li>循环浏览所有 <code>case</code> 并打印每个季节的名称和类型。</li>
</ol>
<p>可以选择仅将某些情况添加到枚举案例数组中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Months</span>: <span class="title">CaseIterable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> january, february, march, april, may, june, july, august, september, october, november, december          </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> allCases: [<span class="type">Months</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> [.june, .july, .august]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里只添加夏季月份，因为它们是一年中最阳光的季节！</p>
<p><img src="/my_pictures/Swift4.2%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B0%E5%8A%9F%E8%83%BD-3.png" alt="Summer is all over the place in Swift 4.2 enumerations!"></p>
<p>如果枚举包含 <code>unavailable</code> 的元素，则应手动将所有 <code>available</code> 添加到数组中:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Days</span>: <span class="title">CaseIterable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> monday, tuesday, wednesday, thursday, friday</span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(*, unavailable)</span><br><span class="line">  <span class="keyword">case</span> saturday, sunday</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> allCases: [<span class="type">Days</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> [.monday, .tuesday, .wednesday, .thursday, .friday]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只能将 <code>工作日</code> 添加到 <code>allCases</code>, 因为这里将 <code>.saturday</code> 和 <code>.sunday</code> 标记为了 <code>unavailable</code>，所以在任何版本和平台都是 <code>unavailable</code>。</p>
<p>还可以将具有关联值的 <code>case</code> 添加到枚举 <code>case</code> 数组中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BlogPost</span>: <span class="title">CaseIterable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> article</span><br><span class="line">  <span class="keyword">case</span> tutorial(updated: <span class="type">Bool</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> allCases: [<span class="type">BlogPost</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> [.article, .tutorial(updated: <span class="literal">true</span>), .tutorial(updated: <span class="literal">false</span>)]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本例中，将网站上的所有博客类型添加到 <code>allCases:</code>，文章，新教程和更新。</p>
<h4 id="新的序列方法（Squence-Methods）"><a href="#新的序列方法（Squence-Methods）" class="headerlink" title="新的序列方法（Squence Methods）"></a>新的序列方法（Squence Methods）</h4><p>Swift 4.1 定义了用于确定某个元素的第一个索引或者满足特定条件的第一个元素的序列方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ages = [<span class="string">&quot;ten&quot;</span>, <span class="string">&quot;twelve&quot;</span>, <span class="string">&quot;thirteen&quot;</span>, <span class="string">&quot;nineteen&quot;</span>, <span class="string">&quot;eighteen&quot;</span>, <span class="string">&quot;seventeen&quot;</span>, <span class="string">&quot;fourteen&quot;</span>,  <span class="string">&quot;eighteen&quot;</span>, </span><br><span class="line">            <span class="string">&quot;fifteen&quot;</span>, <span class="string">&quot;sixteen&quot;</span>, <span class="string">&quot;eleven&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstTeen = ages.first(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.hasSuffix(<span class="string">&quot;teen&quot;</span>) &#125;), </span><br><span class="line">   <span class="keyword">let</span> firstIndex = ages.index(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.hasSuffix(<span class="string">&quot;teen&quot;</span>) &#125;), </span><br><span class="line">   <span class="keyword">let</span> firstMajorIndex = ages.index(of: <span class="string">&quot;eighteen&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Teenager number \(firstIndex + 1) is \(firstTeen) years old.&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Teenager number \(firstMajorIndex + 1) isn&#x27;t a minor anymore.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;No teenagers around here.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swift 4.1 的做法是使用 <code>first(where:)</code> 来查找第一个青少年的年龄（ages），<code>index(where:)</code> 为第一个青少年的索引，<code>index(of:)</code> 为第一个18岁的青少年的索引<br>。</p>
<p>Swift 4.2重新命名了这些方法中的一部分以实现一致性<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0204-add-last-methods.md">[SE-0204]</a>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstTeen = ages.first(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.hasSuffix(<span class="string">&quot;teen&quot;</span>) &#125;), </span><br><span class="line">   <span class="keyword">let</span> firstIndex = ages.firstIndex(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.hasSuffix(<span class="string">&quot;teen&quot;</span>) &#125;), </span><br><span class="line">   <span class="keyword">let</span> firstMajorIndex = ages.firstIndex(of:  <span class="string">&quot;eighteen&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Teenager number \(firstIndex + 1) is \(firstTeen) years old.&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Teenager number \(firstMajorIndex + 1) isn&#x27;t a minor anymore.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;No teenagers around here.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>index(where:)</code> 变成了 <code>firstIndex(where:)</code>，而 <code>index(of:)</code> 变成了 <code>firstIndex(of:)</code> 与 <code>first(where:)</code> 保持一致。</p>
<p>Swift 4.1 也没有定义任何 <code>Collection</code> 方法来查找某个元素的最后一个索引或匹配给定谓词的最后一个元素。以下是 4.1 中的处理方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> reversedAges = ages.reversed()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> lastTeen = reversedAges.first(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.hasSuffix(<span class="string">&quot;teen&quot;</span>) &#125;), </span><br><span class="line">   <span class="keyword">let</span> lastIndex = reversedAges.index(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.hasSuffix(<span class="string">&quot;teen&quot;</span>) &#125;)?.base, </span><br><span class="line">   <span class="keyword">let</span> lastMajorIndex = reversedAges.index(of: <span class="string">&quot;eighteen&quot;</span>)?.base &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Teenager number \(lastIndex) is \(lastTeen) years old.&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Teenager number \(lastMajorIndex) isn&#x27;t a minor anymore.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;No teenagers around here.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看这部分：</p>
<ol>
<li>我们使用 <code>reversed()</code> 方法，创建了一个 <code>ages</code> 的翻转版本。</li>
<li>我们使用 <code>first(where:)</code> 来确定 <code>reversedAges</code> 中最后一名青少年的年龄，<code>index(where:)</code> 是最后一名青少年的索引，<code>index(of:)</code> 是最后一名18岁青少年的索引。</li>
</ol>
<p>Swift 4.2 添加了相应的 <code>Sequence</code> 方法，将上面的方法折叠为如下形式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> lastTeen = ages.last(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.hasSuffix(<span class="string">&quot;teen&quot;</span>) &#125;), </span><br><span class="line">   <span class="keyword">let</span> lastIndex = ages.lastIndex(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.hasSuffix(<span class="string">&quot;teen&quot;</span>) &#125;), </span><br><span class="line">   <span class="keyword">let</span> lastMajorIndex = ages.lastIndex(of: <span class="string">&quot;eighteen&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Teenager number \(lastIndex + 1) is \(lastTeen) years old.&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Teenager number \(lastMajorIndex + 1) isn&#x27;t a minor anymore.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;No teenagers around here.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以简单的使用 <code>last(where:)</code>，<code>lastIndex(where:)</code> 和 <code>lastIndex(of:)</code> 去找到之前的元素和年龄的具体指数。</p>
<h4 id="测试序列元素"><a href="#测试序列元素" class="headerlink" title="测试序列元素"></a>测试序列元素</h4><p>Swift 4.1 中缺少一个相当简单的例程来检查序列中的所有元素是否满足特定条件。尽管如此，您仍然可以制定自己的方法，例如你必须确定所有元素是否是偶数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">10</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">20</span>]</span><br><span class="line"><span class="keyword">let</span> allEven = !values.<span class="built_in">contains</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>看起来并不是很优雅，不是吗？Swift 4.2 为序列添加了这一个缺失的方法<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0207-containsOnly.md">[SE-0207]</a>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> allEven = values.allSatisfy &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>

<p>看起来好多了，这简化了代码，并且具有更好的可读性。</p>
<h4 id="条件一致性更新"><a href="#条件一致性更新" class="headerlink" title="条件一致性更新"></a>条件一致性更新</h4><p>Swift 4.2 在标准库的扩展中增加了一些条件一致性的改进<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0143-conditional-conformances.md">[SE-0143]</a>。</p>
<h5 id="扩展中的条件一致性"><a href="#扩展中的条件一致性" class="headerlink" title="扩展中的条件一致性"></a>扩展中的条件一致性</h5><p>Swift 4.1 无法将扩展中的 <code>Equatable</code> 的条件一致性综合起来。以下面的 Swift 4.1 代码片段为例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tutorial</span> : <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> author: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Screencast</span>&lt;<span class="title">Tutorial</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> author: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> tutorial: <span class="type">Tutorial</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Screencast</span>: <span class="title">Equatable</span> <span class="title">where</span> <span class="title">Tutorial</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: Screencast, rhs: Screencast)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.author == rhs.author &amp;&amp; lhs.tutorial == rhs.tutorial</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> swift41Tutorial = <span class="type">Tutorial</span>(title: <span class="string">&quot;What&#x27;s New in Swift 4.1?&quot;</span>, author: <span class="string">&quot;Cosmin Pupăză&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> swift42Tutorial = <span class="type">Tutorial</span>(title: <span class="string">&quot;What&#x27;s New In Swift 4.2?&quot;</span>, author: <span class="string">&quot;Cosmin Pupăză&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> swift41Screencast = <span class="type">Screencast</span>(author: <span class="string">&quot;Jessy Catterwaul&quot;</span>, tutorial: swift41Tutorial)</span><br><span class="line"><span class="keyword">let</span> swift42Screencast = <span class="type">Screencast</span>(author: <span class="string">&quot;Jessy Catterwaul&quot;</span>, tutorial: swift42Tutorial)</span><br><span class="line"><span class="keyword">let</span> sameScreencast = swift41Screencast == swift42Screencast</span><br></pre></td></tr></table></figure>

<ol>
<li>这里让 <code>Tutorial</code> 继承自 <code>Equatable</code>。</li>
<li>让 <code>Screencast</code> 成为通用的，因为网站作者将他们的截屏作为发布教程的基础。</li>
<li>对于截屏你可以实现 <code>==(lhs:rhs:)</code> ，因为只要 <code>Tutorial</code> 符合 <code>Equatable</code> 那么 <code>Screencast</code> 也会符合 <code>Equatable</code>。</li>
</ol>
<p>在 Swift 4.2 中为一个扩展添加 <code>Equatable</code> 的默认实现如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Screencast</span>: <span class="title">Equatable</span> <span class="title">where</span> <span class="title">Tutorial</span>: <span class="title">Equatable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>此功能也适用于扩展中的 <code>Hashable</code> 和 <code>Codable</code> 一致性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tutorial</span>: <span class="title">Hashable</span>, <span class="title">Codable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> author: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Screencast</span>&lt;<span class="title">Tutorial</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> author: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> tutorial: <span class="type">Tutorial</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Screencast</span>: <span class="title">Hashable</span> <span class="title">where</span> <span class="title">Tutorial</span>: <span class="title">Hashable</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Screencast</span>: <span class="title">Codable</span> <span class="title">where</span> <span class="title">Tutorial</span>: <span class="title">Codable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> screencastsSet: <span class="type">Set</span> = [swift41Screencast, swift42Screencast]</span><br><span class="line"><span class="keyword">let</span> screencastsDictionary = [swift41Screencast: <span class="string">&quot;Swift 4.1&quot;</span>, swift42Screencast: <span class="string">&quot;Swift 4.2&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> screencasts = [swift41Screencast, swift42Screencast]</span><br><span class="line"><span class="keyword">let</span> encoder = <span class="type">JSONEncoder</span>()</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> encoder.encode(screencasts)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;\(error)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个代码块中：</p>
<ol>
<li>让 <code>Tutorial</code> 继承自 <code>Hashable</code> 和 <code>Codable</code>。</li>
<li>如果教程这么做的话，那么也将会让 <code>Screencast</code> 继承自 <code>Hashable</code> 和 <code>Codable</code>。</li>
<li>你可以将截图添加到集合字典中并对他们进行编码。</li>
</ol>
<h5 id="条件一致性运行时查询"><a href="#条件一致性运行时查询" class="headerlink" title="条件一致性运行时查询"></a>条件一致性运行时查询</h5><p>Swift 4.2 实现了条件一致性的<strong>动态查询</strong>。您可以在以下代码中看到这一点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> brand: <span class="type">String</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(brand: <span class="type">String</span> = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.brand = brand</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Tuneable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tune</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Keyboard</span>: <span class="title">Instrument</span>, <span class="title">Tuneable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tune</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\(brand) keyboard tuning.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Tuneable</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Tuneable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tune</span><span class="params">()</span></span> &#123;</span><br><span class="line">    forEach &#123; $<span class="number">0</span>.tune() &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="keyword">let</span> instrument = <span class="type">Instrument</span>()</span><br><span class="line"><span class="keyword">let</span> keyboard = <span class="type">Keyboard</span>(brand: <span class="string">&quot;Roland&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> instruments = [instrument, keyboard]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> keyboards = instruments <span class="keyword">as</span>? <span class="type">Tuneable</span> &#123;</span><br><span class="line">  keyboards.tune()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t tune instrument.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是上述的内容：</p>
<ol>
<li>定义了一个 <code>Instrument</code> 类，并且他有一个成员变量 <code>brand</code>。</li>
<li>为所有可调的乐器声明了一个接口 <code>Tuneable</code>。</li>
<li>我们在 <code>Keyboard</code> 类中重写了 <code>tune()</code> 方法，并且返回键盘的标准调整。</li>
<li>我们使用 <code>where</code> 关键词来约束 <code>Array</code> 的元素满足 <code>Tuneable</code>。</li>
<li>我们将 <code>Instrument</code> 和 <code>Keyboard</code> 添加到 <code>instruments</code> 中。</li>
<li>如果 <code>if</code> 条件满足，这里会检查 <code>instruments</code> 是否能实现了 <code>Tuneable</code>，然后调用 <code>tune()</code>方法。在这里例子中，数组不能转化为 <code>Tuneable</code>，因为 <code>Instrument</code> 类型不满足 <code>Tuneable</code>。如果你创建有两个 <code>Keyboard</code> 元素的数组，则 <code>if</code> 条件会满足，并且会调用 <code>tune()</code> 方法。</li>
</ol>
<h5 id="标准库中哈希一致性改进"><a href="#标准库中哈希一致性改进" class="headerlink" title="标准库中哈希一致性改进"></a>标准库中哈希一致性改进</h5><p>可选项，数组，字典和范围（range）在 Swift 4.2 中是 <code>Hashable</code>，当它们的元素是 <code>Hashable</code> 时：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chord</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> description: <span class="type">String?</span></span><br><span class="line">  <span class="keyword">let</span> notes: [<span class="type">String</span>]</span><br><span class="line">  <span class="keyword">let</span> signature: [<span class="type">String</span>: [<span class="type">String</span>]?]</span><br><span class="line">  <span class="keyword">let</span> frequency: <span class="type">CountableClosedRange</span>&lt;<span class="type">Int</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cMajor = <span class="type">Chord</span>(name: <span class="string">&quot;C&quot;</span>, description: <span class="string">&quot;C major&quot;</span>, notes: [<span class="string">&quot;C&quot;</span>, <span class="string">&quot;E&quot;</span>,  <span class="string">&quot;G&quot;</span>], </span><br><span class="line">                   signature: [<span class="string">&quot;sharp&quot;</span>: <span class="literal">nil</span>,  <span class="string">&quot;flat&quot;</span>: <span class="literal">nil</span>], frequency: <span class="number">432</span>...<span class="number">446</span>)</span><br><span class="line"><span class="keyword">let</span> aMinor = <span class="type">Chord</span>(name: <span class="string">&quot;Am&quot;</span>, description: <span class="string">&quot;A minor&quot;</span>, notes: [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;E&quot;</span>], </span><br><span class="line">                   signature: [<span class="string">&quot;sharp&quot;</span>: <span class="literal">nil</span>, <span class="string">&quot;flat&quot;</span>: <span class="literal">nil</span>], frequency: <span class="number">440</span>...<span class="number">446</span>)</span><br><span class="line"><span class="keyword">let</span> chords: <span class="type">Set</span> = [cMajor, aMinor]</span><br><span class="line"><span class="keyword">let</span> versions = [cMajor: <span class="string">&quot;major&quot;</span>, aMinor: <span class="string">&quot;minor&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>这里将 <code>cMajor</code> 和 <code>aMinor</code> 放在 <code>chords</code> 和 <code>versions</code> 中。这在 Swift 4.2 之前是不可能的，因为 <code>String?</code>, <code>[String]</code>, <code>[String: [String]?]</code> 和 <code>CountableClosedRange&lt;Int&gt;</code> 他们不满足 <code>Hashable</code></p>
<h4 id="哈希改进"><a href="#哈希改进" class="headerlink" title="哈希改进"></a>哈希改进</h4><p>在 Swift 4.1 中为下面的例子实现一个类的自定义<a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">散列函数</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Country: Hashable &#123;</span><br><span class="line">  let name: String</span><br><span class="line">  let capital: String</span><br><span class="line">  </span><br><span class="line">  init(name: String, capital: String) &#123;</span><br><span class="line">    self.name &#x3D; name</span><br><span class="line">    self.capital &#x3D; capital</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  static func &#x3D;&#x3D;(lhs: Country, rhs: Country) -&gt; Bool &#123;</span><br><span class="line">    return lhs.name &#x3D;&#x3D; rhs.name &amp;&amp; lhs.capital &#x3D;&#x3D; rhs.capital</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  var hashValue: Int &#123;</span><br><span class="line">    return name.hashValue ^ capital.hashValue &amp;* 16777619</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let france &#x3D; Country(name: &quot;France&quot;, capital: &quot;Paris&quot;)</span><br><span class="line">let germany &#x3D; Country(name: &quot;Germany&quot;, capital: &quot;Berlin&quot;)</span><br><span class="line">let countries: Set &#x3D; [france, germany]</span><br><span class="line">let countryGreetings &#x3D; [france: &quot;Bonjour&quot;, germany: &quot;Guten Tag&quot;]</span><br></pre></td></tr></table></figure>

<p>由于它们是继承自 <code>Hashable</code>，因此您可以在这里将国家添加到集合（sets）和词典中。但是 <code>hashValue</code> 实现很难理解，并且对于不可信的源值不够有效。</p>
<p>Swift 4.2 通过定义通用哈希函数修复了这个问题<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0206-hashable-enhancements.md">[SE-0206]</a>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> capital: <span class="type">String</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, capital: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.capital = capital</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: Country, rhs: Country)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.name == rhs.name &amp;&amp; lhs.capital == rhs.capital</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">hash</span><span class="params">(into hasher: <span class="keyword">inout</span> Hasher)</span></span> &#123;</span><br><span class="line">    hasher.combine(name)</span><br><span class="line">    hasher.combine(capital)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，用 <code>hash(into:)</code> 函数替换了 <code>Country</code> 中原来的 <code>hashValue</code>。该函数使用 <code>combine()</code> 将类属性提供给 <code>hasher</code>。这很容易实现，它提高了以前所有版本的性能。</p>
<p><img src="/my_pictures/Swift4.2%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B0%E5%8A%9F%E8%83%BD-4.png" alt="Hashing sets and dictionaries like a pro in Swift 4.2!"></p>
<h4 id="从集合中删除元素"><a href="#从集合中删除元素" class="headerlink" title="从集合中删除元素"></a>从集合中删除元素</h4><p>我们通常会想要从集合中删除所有出现的特定元素。在 Swift 4.1 中我们可以使用 <code>filter(_:)</code> 来实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greetings = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;Goodbye&quot;</span>, <span class="string">&quot;Bye&quot;</span>]</span><br><span class="line">greetings = greetings.<span class="built_in">filter</span> &#123; $<span class="number">0</span>.<span class="built_in">count</span> &lt;= <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这里过滤 <code>greetings</code> 中的元素，只返回元素字符数小于或等于 3 的元素。这并不影响原始数组。所以你不得不把它再赋值给 <code>greetings</code>。</p>
<p>Swift 4.2 添加了 <code>removeAll(_:)</code> 方法<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0197-remove-where.md">[SE-0197]</a>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">greetings.removeAll &#123; $<span class="number">0</span>.<span class="built_in">count</span> &gt; <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这里将执行移除操作。再一次，我们又简化了代码并且增加了可读性。</p>
<h4 id="切换布尔值状态"><a href="#切换布尔值状态" class="headerlink" title="切换布尔值状态"></a>切换布尔值状态</h4><p>切换布尔值状态！谁在 Swift 4.1 中没有这样用过：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">toggle</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span> = !<span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isOn = <span class="literal">true</span></span><br><span class="line">isOn.toggle()</span><br></pre></td></tr></table></figure>

<p>Swift 4.2 为 <code>Bool</code> 添加了 <code>toggle()</code> 函数 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0199-bool-toggle.md">[SE-0199]</a>：</p>
<h4 id="新的编译指令"><a href="#新的编译指令" class="headerlink" title="新的编译指令"></a>新的编译指令</h4><p>Swift 4.2 定义了一些编译器指令，用于在代码中标识出问题<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0196-diagnostic-directives.md">[SE-0196]</a>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">#warning(<span class="string">&quot;There are shorter implementations out there.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">  sum += number</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sum)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">#error(<span class="string">&quot;Please fill in your credentials.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> username = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> password = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">switch</span> (username.<span class="built_in">filter</span> &#123; $<span class="number">0</span> != <span class="string">&quot; &quot;</span> &#125;, password.<span class="built_in">filter</span> &#123; $<span class="number">0</span> != <span class="string">&quot; &quot;</span> &#125;) &#123;</span><br><span class="line">  <span class="keyword">case</span> (<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Invalid username and password.&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> (<span class="string">&quot;&quot;</span>, <span class="keyword">_</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Invalid username.&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> (<span class="keyword">_</span>, <span class="string">&quot;&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Invalid password.&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> (<span class="keyword">_</span>, <span class="keyword">_</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Logged in succesfully.&quot;</span>)</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<p>这里是如何工作的：</p>
<ol>
<li>这里用 <code>#warning</code> 来进行一个提醒，在 <code>numbers</code> 中添加元素的功能方法比命令式方法短。</li>
<li>用 <code>#error</code> 来让其他开发者在登陆之前输入用户名和密码。</li>
</ol>
<h4 id="新的指针功能"><a href="#新的指针功能" class="headerlink" title="新的指针功能"></a>新的指针功能</h4><p><code>withUnsafeBytes(of:_:)</code> 和 <code>withUnsafePointer(to:_:)</code> 只适用于 Swift 4.1 中的可变变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> copy = value</span><br><span class="line">withUnsafeBytes(of: &amp;copy) &#123; pointer <span class="keyword">in</span> <span class="built_in">print</span>(pointer.<span class="built_in">count</span>) &#125;</span><br><span class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;copy) &#123; pointer <span class="keyword">in</span> <span class="built_in">print</span>(pointer.hashValue) &#125;</span><br></pre></td></tr></table></figure>

<p>所以我们必须创建一个值的副本（copy of value）才能使这两个函数正常工作。 Swift 4.2 为常量重载这些函数，所以你不再需要保存它们的值<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0205-withUnsafePointer-for-lets.md">[SE-0205]</a>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">withUnsafeBytes(of: value) &#123; pointer <span class="keyword">in</span> <span class="built_in">print</span>(pointer.<span class="built_in">count</span>) &#125;</span><br><span class="line"><span class="built_in">withUnsafePointer</span>(to: value) &#123; pointer <span class="keyword">in</span> <span class="built_in">print</span>(pointer.hashValue) &#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存布局更新"><a href="#内存布局更新" class="headerlink" title="内存布局更新"></a>内存布局更新</h4><p>Swift 4.2 使用键路径查询存储属性的内存布局<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0210-key-path-offset.md">[SE-0210]</a>。以下是它的工作原理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x, y: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> center: <span class="type">Point</span></span><br><span class="line">  <span class="keyword">var</span> radius: <span class="type">Double</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> circumference: <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * .pi * radius</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> area: <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> .pi * radius * radius</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> xOffset = <span class="type">MemoryLayout</span>.offset(of: \<span class="type">Circle</span>.center.x), </span><br><span class="line">   <span class="keyword">let</span> yOffset = <span class="type">MemoryLayout</span>.offset(of: \<span class="type">Circle</span>.center.y), </span><br><span class="line">   <span class="keyword">let</span> radiusOffset = <span class="type">MemoryLayout</span>.offset(of: \<span class="type">Circle</span>.radius) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;\(xOffset) \(yOffset) \(radiusOffset)&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Nil offset values.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> circumferenceOffset = <span class="type">MemoryLayout</span>.offset(of: \<span class="type">Circle</span>.circumference), </span><br><span class="line">   <span class="keyword">let</span> areaOffset = <span class="type">MemoryLayout</span>.offset(of: \<span class="type">Circle</span>.area) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;\(circumferenceOffset) \(areaOffset)&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Nil offset values.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来一步一步的解析：</p>
<ol>
<li>我们定义了该点的水平和垂直坐标。</li>
<li>我们声明了一个圆的中心，圆周，面积和半径。</li>
<li>我们使用键路径来获取圆的存储属性的偏移量。</li>
<li>由于它们不是以内联方式存储的，因此我们将返回nil作为圆的计算属性的偏移量。</li>
</ol>
<h4 id="模块中的内联函数"><a href="#模块中的内联函数" class="headerlink" title="模块中的内联函数"></a>模块中的内联函数</h4><p>在 Swift 4.1 中我们不能在我们的模型中声明内联函数。点击 <strong>View ▸ Navigators ▸ Show Project Navigator</strong>，右键点击 <strong>Source</strong> 并且选择 <strong>新建文件</strong>。重命名为 <code>FactorialKit.swift</code> 然后用下面的代码来替换它的内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFactorial</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> customDecrement: <span class="type">Bool</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> customDecrement: <span class="type">Bool</span> = <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.customDecrement = customDecrement</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> randomDecrement: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arc4random_uniform(<span class="number">2</span>) == <span class="number">0</span> ? <span class="number">2</span> : <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(<span class="keyword">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> n &gt; <span class="number">1</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> decrement = customDecrement ? randomDecrement : <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - decrement)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们已经创建了阶乘实现的自定义版本。切换回 <code>playground</code> 并在底部添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> standard = <span class="type">CustomFactorial</span>()</span><br><span class="line">standard.factorial(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> custom = <span class="type">CustomFactorial</span>(<span class="literal">true</span>)</span><br><span class="line">custom.factorial(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>这里，生成默认的阶乘和随机的阶乘。跨模块函数在 Swift 4.2<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0193-cross-module-inlining-and-specialization.md">[SE-0193]</a>中内嵌时更有效率，因此将 <code>FactorialKit.swift</code> 中的代码用以下方法替换 <code>CustomFactorial</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFactorial</span> </span>&#123;</span><br><span class="line">  @usableFromInline <span class="keyword">let</span> customDecrement: <span class="type">Bool</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> customDecrement: <span class="type">Bool</span> = <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.customDecrement = customDecrement</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @usableFromInline <span class="keyword">var</span> randomDecrement: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Bool</span>.random() ? <span class="number">2</span> : <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @inlinable <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(<span class="keyword">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> n &gt; <span class="number">1</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> decrement = customDecrement ? randomDecrement : <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - decrement)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们做了这些：</p>
<ol>
<li>将 <code>customDecrement</code> 和 <code>randomDecrement</code> 都设置为 <code>internal</code>，并将它们标记为 <code>@usableFromInline</code>，因为我们在内联因子实现中使用它们。</li>
<li>我们用 <code>@inlinable</code> 注释 <code>factorial(_:)</code> 以使其成为内联。这是可以的，因为我们声明这个函数是 <code>public</code>。</li>
</ol>
<h3 id="其他的变化"><a href="#其他的变化" class="headerlink" title="其他的变化"></a>其他的变化</h3><hr>
<p>这里还有一些你应该知道的 Swift 4.2 的一些其他变化。</p>
<h4 id="Swift-的包管理器更新"><a href="#Swift-的包管理器更新" class="headerlink" title="Swift 的包管理器更新"></a>Swift 的包管理器更新</h4><p>Swift 4.2 为包管理加入了一些改进。</p>
<h5 id="定义包的-Swift-语言版本"><a href="#定义包的-Swift-语言版本" class="headerlink" title="定义包的 Swift 语言版本"></a>定义包的 Swift 语言版本</h5><p>Swift 4.1 在 <code>Package.swift</code> 文件中，定义了一个 <code>[Int]</code> 类型的 <code>swiftLanguageVersions</code> 变量。所以你可以只声明你的包的主要版本：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> package = <span class="type">Package</span>(name: <span class="string">&quot;Package&quot;</span>, swiftLanguageVersions: [<span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<p>Swift 4.2 可以通过 <code>SwiftVersion</code>枚举定义小版本<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0209-package-manager-swift-lang-version-update.md">[SE-0209]</a>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> package = <span class="type">Package</span>(name: <span class="string">&quot;Package&quot;</span>, swiftLanguageVersions: [.v4_2])</span><br></pre></td></tr></table></figure>

<p>我们还可以使用 <code>.version(_:)</code> 声明未来版本：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> package = <span class="type">Package</span>(name: <span class="string">&quot;Package&quot;</span>, swiftLanguageVersions: [.version(<span class="string">&quot;5&quot;</span>)])</span><br></pre></td></tr></table></figure>

<h5 id="声明包的本地依赖关系"><a href="#声明包的本地依赖关系" class="headerlink" title="声明包的本地依赖关系"></a>声明包的本地依赖关系</h5><p>在 Swift 4.1 中，使用存储库链接声明了包的依赖关系。如果有互连的包这将增加开销，所以 Swift 4.2 在这种情况下使用本地路径代替<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0201-package-manager-local-dependencies.md">[SE-0201]</a>。</p>
<h5 id="将系统库目标（system-library-targets）添加到包中"><a href="#将系统库目标（system-library-targets）添加到包中" class="headerlink" title="将系统库目标（system library targets）添加到包中"></a>将系统库目标（system library targets）添加到包中</h5><p><code>System-module packages</code> 在 Swift 4.1 中需要单独的存储库。这使得包管理器难以使用，因此 Swift 4.2 将它们替换为 <code>system library targets</code><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0208-package-manager-system-library-targets.md">[SE-0208]</a>。</p>
<h4 id="删除隐式解包的选项"><a href="#删除隐式解包的选项" class="headerlink" title="删除隐式解包的选项"></a>删除隐式解包的选项</h4><p>在 Swift 4.1 中，可以在嵌套类型中使用隐式解包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> favoriteNumbers: [<span class="type">Int!</span>] = [<span class="number">10</span>, <span class="literal">nil</span>, <span class="number">7</span>, <span class="literal">nil</span>]</span><br><span class="line"><span class="keyword">let</span> favoriteSongs: [<span class="type">String</span>: [<span class="type">String</span>]!] = [<span class="string">&quot;Cosmin&quot;</span>: [<span class="string">&quot;Nothing Else Matters&quot;</span>, <span class="string">&quot;Stairway to Heaven&quot;</span>], </span><br><span class="line">                                          <span class="string">&quot;Oana&quot;</span>: <span class="literal">nil</span>] </span><br><span class="line"><span class="keyword">let</span> credentials: (usermame: <span class="type">String!</span>, password: <span class="type">String!</span>) = (<span class="string">&quot;Cosmin&quot;</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>Swift 4.2 将它们从数组，字典和元组中删除<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md">[SE-0054]</a>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> favoriteNumbers: [<span class="type">Int?</span>] = [<span class="number">10</span>, <span class="literal">nil</span>, <span class="number">7</span>, <span class="literal">nil</span>]</span><br><span class="line"><span class="keyword">let</span> favoriteSongs: [<span class="type">String</span>: [<span class="type">String</span>]?] = [<span class="string">&quot;Cosmin&quot;</span>: [<span class="string">&quot;Nothing Else Matters&quot;</span>, <span class="string">&quot;Stairway to Heaven&quot;</span>], </span><br><span class="line">                                          <span class="string">&quot;Oana&quot;</span>: <span class="literal">nil</span>] </span><br><span class="line"><span class="keyword">let</span> credentials: (usermame: <span class="type">String?</span>, password: <span class="type">String?</span>) = (<span class="string">&quot;Cosmin&quot;</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><hr>
<ul>
<li><a href="https://www.raywenderlich.com/194066/whats-new-in-swift-4-2">What’s New in Swift 4.2?</a></li>
</ul>
]]></content>
      <categories>
        <category>文章翻译</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>在正确的线程上使用Observable【译】</title>
    <url>/2018/06/17/2018-06-17-%E5%9C%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%BD%BF%E7%94%A8Observable%E3%80%90%E8%AF%91%E3%80%91/</url>
    <content><![CDATA[<p>尽管很多人了解 RxJava 的基本逻辑，但是在 Observable 链和操作符究竟运行在哪个线程，仍然会有许多困惑。</p>
<p>首先，让我们梳理清晰，在 RxJava 中 <code>.subsribeOn()</code> 和 <code>.observeOn()</code> 区别：</p>
<ol>
<li><code>.subsribeOn()</code> 操作符可以改变 Observable 应该在哪个调度器上执行任务。</li>
<li><code>.observeOn()</code> 操作符可以改变 Observable 将在哪个调度器上发送通知。</li>
<li>另外，你需要知道，默认情况下，链上的操作符将会在调用 <code>.subsribeOn()</code> 的那个线程上执行任务。</li>
</ol>
<a id="more"></a>

<h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><hr>
<h4 id="主线程或者-subscribe-所在线程"><a href="#主线程或者-subscribe-所在线程" class="headerlink" title="主线程或者 .subscribe() 所在线程"></a>主线程或者 .subscribe() 所在线程</h4><p>如果在 Android 的 <code>Activity下onCreate()</code> 方法中，也就是主线程中使用如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    .subscribe( );</span><br></pre></td></tr></table></figure>

<p>表现会像这样：</p>
<p><img src="/my_pictures/%E5%9C%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%BD%BF%E7%94%A8Observable-1.png"></p>
<h4 id="调用-subscribeOn"><a href="#调用-subscribeOn" class="headerlink" title="调用 .subscribeOn()"></a>调用 .subscribeOn()</h4><p>尽管代码片段在主线程中，但是整个代码块将运行在 <code>.subscribeOn()</code> 定义的线程上：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    .subscribeOn(<span class="type">Schedulers</span>.newThread())</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure>

<p>表现会像这样：</p>
<p><img src="/my_pictures/%E5%9C%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%BD%BF%E7%94%A8Observable-2.png"></p>
<h4 id="调用-observeOn"><a href="#调用-observeOn" class="headerlink" title="调用 .observeOn()"></a>调用 .observeOn()</h4><p>如果你的代码片段在主线程中，默认情况下Observable的创建是在 <code>.subscribeOn()</code> 定义的线程上，但是，调用 <code>.observeOn()</code> 之后，余下的代码将会执行在 <code>.observeOn()</code> 所定义的线程上：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    .observeOn(<span class="type">Schedulers</span>.newThread())</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure>

<p><img src="/my_pictures/%E5%9C%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%BD%BF%E7%94%A8Observable-3.png"></p>
<h4 id="合并逻辑"><a href="#合并逻辑" class="headerlink" title="合并逻辑"></a>合并逻辑</h4><p>照理合并操作符，放在一起就像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    .subscribeOn(<span class="type">Schedulers</span>.newThread())</span><br><span class="line">    .observeOn(<span class="type">Schedulers</span>.newThread())</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure>

<p><img src="/my_pictures/%E5%9C%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%BD%BF%E7%94%A8Observable-4.png"></p>
<h3 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h3><hr>
<h4 id="UI-线程运行异常"><a href="#UI-线程运行异常" class="headerlink" title="UI 线程运行异常"></a>UI 线程运行异常</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    .subscribeOn(<span class="type">Schedulers</span>.newThread())</span><br><span class="line">    .subscribe(<span class="comment">/** 与UI线程相关的逻辑 **/</span>/);</span><br></pre></td></tr></table></figure>

<p>很明显，这是错的。</p>
<h4 id="保证逻辑运行在工作线程中"><a href="#保证逻辑运行在工作线程中" class="headerlink" title="保证逻辑运行在工作线程中"></a>保证逻辑运行在工作线程中</h4><p>如果存在以下代码片段：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    .subscribeOn(<span class="type">Schedulers</span>.newThread())</span><br><span class="line">    .observeOn(<span class="type">AndroidSchedulers</span>.mainThread())</span><br><span class="line"> </span><br><span class="line">    .flatMap(<span class="comment">/** 与UI线程无关的逻辑**/</span>/)</span><br><span class="line"> </span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure>

<p>请用以下代码替代：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    .subscribeOn(<span class="type">Schedulers</span>.newThread())</span><br><span class="line"> </span><br><span class="line">    .flatMap(<span class="comment">/** 与UI线程无关的逻辑**/</span>/)</span><br><span class="line"> </span><br><span class="line">    .observeOn(<span class="type">AndroidSchedulers</span>.mainThread())</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure>

<p>通过用第二段代码代替第一段，<code>.flatMap()</code> 操作符（或者在这一点的其他逻辑操作符）将运行在后台线程。这样做就不会阻塞 UI 线程，同时可以防患 ANR 或其他类似问题的发生。看起来有点像 <code>AsyncTask</code> 模式，尽可能的把逻辑放在的 <code>.doInBackground()</code> 中，而不是 <code>.onPostExecute()</code> 。</p>
<h4 id="取决于更早的-subscribeOn"><a href="#取决于更早的-subscribeOn" class="headerlink" title="取决于更早的 .subscribeOn()"></a>取决于更早的 .subscribeOn()</h4><p>以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    .subscribeOn(thread1)</span><br><span class="line">    .subscribeOn(thread2)</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure>

<p>因为 <code>thread1</code> 的逻辑将会覆盖 <code>thread2</code>，所以 <code>Observable</code> 的创建和 <code>.subscribe()</code> 的逻辑处理都将运行在 <code>thread1</code> 中。因此，根本没有必要写多个 <code>.subscribeOn()</code> 操作符。</p>
<h4 id="原文链接："><a href="#原文链接：" class="headerlink" title="原文链接："></a>原文链接：</h4><p><a href="https://lorentzos.com/observe-in-the-correct-thread-1939bb9bb9d2">Observe on the correct thread</a></p>
]]></content>
      <categories>
        <category>文章翻译</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
        <tag>iOS</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>Charles 如何对 HTTPS 进行抓包？</title>
    <url>/2018/06/21/2018-06-21-Charles%20%E5%A6%82%E4%BD%95%E5%AF%B9%20HTTPS%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<p>对 http 的抓包非常的简单，但是对 https 的抓包就有点麻烦了，主要麻烦在证书的安装与设置上。昨天由于有需要去抓https 的包，但是装好证书后，手机一直连不上，特此记录一下。</p>
<p>想要抓取 https 包，首先我们需要在电脑上安装一个 Charles Proxy 的证书</p>
<h3 id="安装-Charles-Root-Certificate"><a href="#安装-Charles-Root-Certificate" class="headerlink" title="安装 Charles Root Certificate"></a>安装 Charles Root Certificate</h3><hr>
<p>1、依次点击：Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate</p>
<p><img src="/my_pictures/Charles%E5%A6%82%E4%BD%95%E5%AF%B9HTTPS%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85-1.png"></p>
<a id="more"></a>

<p>2、打开我们系统的 <code>钥匙串</code> 应用，找到如下的证书（老版本的证书名字可能有所不同）：</p>
<p><img src="/my_pictures/Charles%E5%A6%82%E4%BD%95%E5%AF%B9HTTPS%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85-2.png"></p>
<p>3、右键证书 -&gt; 显示简介 -&gt; 将信任设置成【始终信任】，如下所示：</p>
<p><img src="/my_pictures/Charles%E5%A6%82%E4%BD%95%E5%AF%B9HTTPS%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85-3.png"></p>
<p>至此，macOS 系统的证书安装完毕。</p>
<h3 id="在-iOS-上安装证书"><a href="#在-iOS-上安装证书" class="headerlink" title="在 iOS 上安装证书"></a>在 iOS 上安装证书</h3><hr>
<p>1、将手机 WiFi 的配置代理一项设置成手动，服务器一栏输入自己电脑的 IP 地址，端口一栏输入 8888，保存返回。</p>
<p>2、打开手机的浏览器，输入 <code>chls.pro/ssl</code> 打开这个网址，提示框选择允许，如下：</p>
<p><img src="/my_pictures/Charles%E5%A6%82%E4%BD%95%E5%AF%B9HTTPS%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85-4.PNG"></p>
<p>3、安装证书</p>
<p><img src="/my_pictures/Charles%E5%A6%82%E4%BD%95%E5%AF%B9HTTPS%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85-5.PNG"></p>
<p>4、信任证书【此步容易忘，注意】，设置 -&gt; 通用 -&gt; 关于本机 -&gt; 证书信任设置</p>
<p><img src="/my_pictures/Charles%E5%A6%82%E4%BD%95%E5%AF%B9HTTPS%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85-6.PNG"></p>
<h3 id="SSL-Proxying-Settings"><a href="#SSL-Proxying-Settings" class="headerlink" title="SSL Proxying Settings"></a>SSL Proxying Settings</h3><hr>
<p>1、Proxy -&gt; SSL Proxying Settings 点击 add 按钮，按如下方式添加：</p>
<p><img src="/my_pictures/Charles%E5%A6%82%E4%BD%95%E5%AF%B9HTTPS%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85-7.png"></p>
<p>2、如果连接还是加密状态的话，右键选择连接，点击 <code>Enable SSL Proxying</code>：</p>
<p><img src="/my_pictures/Charles%E5%A6%82%E4%BD%95%E5%AF%B9HTTPS%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85-8.png"></p>
<p>现在就可以对任何的 https 连接进行抓包了。</p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 iOS 导航栏隐藏和显示</title>
    <url>/2018/06/22/2018-06-22-%E8%A7%A3%E5%86%B3%20iOS%20%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%9A%90%E8%97%8F%E5%92%8C%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>今天在项目中遇到了隐藏 <code>navigationbar</code> 功能的问题，例如：从 A push到 B 页面，A 页面的 <code>navigationbar</code> 是隐藏的，但是 B 页面的 <code>navigationbar</code> 是需要显示的。</p>
<p>一开始我在 A 页面调用 <code>setNavigationBarHidden(true, animated: true)</code> 方法，在 B 页面调用 <code>setNavigationBarHidden(false, animated: true)</code> 方法，虽然能够达到想要的效果，但是对于项目来说是灾难性的。因为如果有多个地方出现这种情况的话，你的代码将会变得十分的杂乱臃肿。</p>
<p>一种好的解决方式是调用 <code>navigationcontroller</code> 的代理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">navigationController(<span class="keyword">_</span>:willShow:animated:)</span><br></pre></td></tr></table></figure>

<p>将这个代理放在项目控制器的基类中，在这里我是放在我的基类 <code>BaseViewController</code> 中。为什么这么做？因为这样可以很好的去掉冗余的代码，不用写的到处都是，我的所有控制器都是继承自 <code>BaseViewController</code> 的，<code>BaseViewController</code> 继承自 <code>UIViewController</code>。</p>
<p>下面到了 Show Code 的时候了</p>
<a id="more"></a>

<h3 id="基类实现代理方法"><a href="#基类实现代理方法" class="headerlink" title="基类实现代理方法"></a>基类实现代理方法</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BaseViewController</span>: <span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(<span class="keyword">_</span> navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 这里判断是否是当前代理控制器，如果是当前代理控制器的话，则是需要隐藏 navigationbar 的</span></span><br><span class="line">        <span class="keyword">if</span> viewController == <span class="keyword">self</span> &#123;</span><br><span class="line">            navigationController.setNavigationBarHidden(<span class="literal">true</span>, animated: <span class="literal">true</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/// 系统相册不能隐藏，所有就直接 return</span></span><br><span class="line">            <span class="keyword">if</span> navigationController.isKind(of: <span class="type">UIImagePickerController</span>.<span class="keyword">self</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/// 不是当前代理控制器的话，显示真正的 navbar</span></span><br><span class="line">            navigationController.setNavigationBarHidden(<span class="literal">false</span>, animated: <span class="literal">true</span>)</span><br><span class="line">            <span class="comment">/// 当不显示本页时，要么就 push 到下一页，要么就被 pop 了，那么就将 delegate 设置为 nil，防止出现 BAD ACCESS</span></span><br><span class="line">            <span class="comment">/// 之前将这段代码放在 viewDidDisappear 和 dealloc 中，这两种情况可能已经被 pop 了，self.navigationController 为 nil，这里采用手动持有 navigationController 的引用来解决</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> delegate = navigationController.delegate, delegate === <span class="keyword">self</span> &#123;</span><br><span class="line">                <span class="comment">/// 如果 delegate 是自己才设置为 nil，因为 viewWillAppear 调用的比此方法较早，</span></span><br><span class="line">                <span class="comment">/// 其他 controller 如果设置了 delegate 就可能会被误伤</span></span><br><span class="line">                navigationController.delegate = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在需要隐藏-navigationbar-的地方，添加如下代码"><a href="#在需要隐藏-navigationbar-的地方，添加如下代码" class="headerlink" title="在需要隐藏 navigationbar 的地方，添加如下代码"></a>在需要隐藏 navigationbar 的地方，添加如下代码</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.navigationController?.delegate = <span class="keyword">self</span></span><br></pre></td></tr></table></figure>

<p>这样就能解决显示/隐藏的问题了。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://www.jianshu.com/p/3af15e7d02c7">iOS 开发 完美解决navigationBar隐藏/显示</a></li>
</ul>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>iOS工作日志</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包实现addTarget方法-面向协议编程</title>
    <url>/2018/06/25/2018-06-25-%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0addTarget%E6%96%B9%E6%B3%95-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>Swift 是一门面向协议的编程语言，为什么这么说，请看 WWDC 视频 <a href="https://developer.apple.com/videos/play/wwdc2015/408/">Protocol-Oriented Programming in Swift</a>。</p>
<p>通过闭包的方式为 <code>UIControl</code> 添加 <code>action</code> 的实现方式有很多种，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(<span class="keyword">_</span> action: @escaping <span class="params">()</span></span></span> -&gt; (), <span class="keyword">for</span> controlEvents: <span class="type">UIControlEvents</span>) -&gt; <span class="type">AnyObject</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> sleeve = <span class="type">ClosureSleeve</span>(attachTo: <span class="keyword">self</span>, closure: action, controlEvents: controlEvents)</span><br><span class="line">        addTarget(sleeve, action: <span class="keyword">#selector</span>(<span class="type">ClosureSleeve</span>.invoke), <span class="keyword">for</span>: controlEvents)</span><br><span class="line">        <span class="keyword">return</span> sleeve</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">listenOnce</span><span class="params">(<span class="keyword">_</span> action: @escaping <span class="params">()</span></span></span> -&gt; (), <span class="keyword">for</span> controlEvents: <span class="type">UIControlEvents</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> sleeve = <span class="type">ClosureSleeve</span>(attachTo: <span class="keyword">self</span>, closure: action, controlEvents: controlEvents)</span><br><span class="line">        addTarget(sleeve, action: <span class="keyword">#selector</span>(<span class="type">ClosureSleeve</span>.invokeOnce), <span class="keyword">for</span>: controlEvents)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">unlisten</span><span class="params">(sleeve: AnyObject)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> sleeve = sleeve <span class="keyword">as</span>? <span class="type">ClosureSleeve</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.removeTarget(sleeve, action: <span class="keyword">#selector</span>(<span class="type">ClosureSleeve</span>.invoke), <span class="keyword">for</span>: sleeve.controlEvents)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosureSleeve</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> closure: () -&gt; ()</span><br><span class="line">    <span class="keyword">let</span> controlEvents:<span class="type">UIControlEvents</span></span><br><span class="line">    <span class="keyword">let</span> attachedTo: <span class="type">AnyObject</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(attachTo: <span class="type">AnyObject</span>, closure: @escaping () -&gt; (), controlEvents:<span class="type">UIControlEvents</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.attachedTo = attachTo</span><br><span class="line">        <span class="keyword">self</span>.closure = closure</span><br><span class="line">        <span class="keyword">self</span>.controlEvents = controlEvents</span><br><span class="line">        objc_setAssociatedObject(attachTo, <span class="string">&quot;[\(arc4random())]&quot;</span>, <span class="keyword">self</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">()</span></span> &#123;</span><br><span class="line">        closure()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">invokeOnce</span><span class="params">()</span></span> &#123;</span><br><span class="line">        closure()</span><br><span class="line">        attachedTo.unlisten(sleeve: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>这种实现方式看起来似乎没有问题，用法如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Register listener, keep the reference to unregister the listener</span></span><br><span class="line"><span class="keyword">let</span> listener = button.listenOnce(&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I will say this every time you tap the button&quot;</span>)</span><br><span class="line">&#125;, <span class="keyword">for</span>: [.touchUpInside])</span><br><span class="line"></span><br><span class="line"><span class="comment">// … later …</span></span><br><span class="line">button.unlisten(listener)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen once for the control events, automatically unlisten when the block is performed</span></span><br><span class="line">button.listenOnce(&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I will only say this once&quot;</span>)</span><br><span class="line">&#125;, <span class="keyword">for</span>: [.touchUpInside, .touchDragExit])</span><br></pre></td></tr></table></figure>

<p>使用起来也是简洁可读性好，但是如果我们这样用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">attachedTo.unlisten(sleeve: <span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>

<p>会导致崩溃，因为 <code>attachedTo</code> 是一个 <code>AnyObject</code> 类型，如果我们在其他对象上调用的话会出现崩溃的现象。我们也可以用 <code>respondsToSelector</code> 来判断。或者将 <code>attachedTo</code> 变量改为 <code>UIControl</code>，但是如果你想在其他的控件上使用 <code>ClosureSleeve</code> 的话，它将不起作用。这时我们可以使用协议来解决。</p>
<p>在此之前，我们应将闭包包装成一个 <code>class</code>，让闭包能作为关联对象存储。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Container class for closures, so that closure can be stored as an associated object</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosureContainer</span>&lt;<span class="title">T</span>: <span class="title">Closurable</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> closure: (<span class="type">T</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    <span class="keyword">var</span> sender: <span class="type">T?</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(closure: @escaping (<span class="type">T</span>) -&gt; <span class="type">Void</span>, sender: <span class="type">T?</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.closure = closure</span><br><span class="line">        <span class="keyword">self</span>.sender = sender</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// method for the target action, visible to UIKit classes via @objc</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">processHandler</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> sender = sender &#123;</span><br><span class="line">            closure(sender)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// target action</span></span><br><span class="line">    <span class="keyword">var</span> action: <span class="type">Selector</span> &#123; <span class="keyword">return</span> <span class="keyword">#selector</span>(processHandler) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们来实现我们的协议</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ************** Protocol ***************</span></span><br><span class="line"><span class="comment">/// Closurable protocol</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Closurable</span>: <span class="title">class</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// restrict protocol to only classes =&gt; can refer to the class instance in the protocol extension</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Closurable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create container for closure, store it and return it</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getContainer</span><span class="params">(<span class="keyword">for</span> closure: @escaping <span class="params">(<span class="keyword">Self</span>)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">ClosureContainer</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">weak</span> <span class="keyword">var</span> weakSelf = <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">let</span> container = <span class="type">ClosureContainer</span>(closure: closure, sender: weakSelf)</span><br><span class="line">        <span class="comment">// store the container so that it can be called later, we do not need to explicitly retrieve it.</span></span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, <span class="type">Unmanaged</span>.passUnretained(<span class="keyword">self</span>).toOpaque(), container, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        <span class="keyword">return</span> container</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我想让 <code>UIButton</code> 能够使用闭包进行 <code>addTarget</code> 操作，我们只需要让 <code>UIButton</code> 满足 <code>Closurable</code> 协议即可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIButton</span>: <span class="title">Closurable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addTarget</span><span class="params">(forControlEvents: UIControlEvents = .touchUpInside, closure: @escaping <span class="params">(UIButton)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> container = getContainer(<span class="keyword">for</span>: closure)</span><br><span class="line">        addTarget(container, action: container.action, <span class="keyword">for</span>: forControlEvents)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="type">UIButton</span>()</span><br><span class="line">btn.addTarget &#123; (sender) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;click button&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">btn.addTarget(forControlEvents: .touchUpInside) &#123; (sender) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;click button&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就避免了如上的错误可能，可扩展性也不错。并且我们不仅可以用于 <code>UIControl</code> 类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// extension for UIBarButtonItem - actions with closure</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIBarButtonItem</span>: <span class="title">Closurable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(image: <span class="type">UIImage?</span>, style: <span class="type">UIBarButtonItemStyle</span> = .plain, closure: @escaping (<span class="type">UIBarButtonItem</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(image: image, style: style, target: <span class="literal">nil</span>, action: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">let</span> container = getContainer(<span class="keyword">for</span>: closure)</span><br><span class="line">        target = container</span><br><span class="line">        action = container.action</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(title: <span class="type">String?</span>, style: <span class="type">UIBarButtonItemStyle</span> = .plain, closure: @escaping (<span class="type">UIBarButtonItem</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(title: title, style: style, target: <span class="literal">nil</span>, action: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">let</span> container = getContainer(<span class="keyword">for</span>: closure)</span><br><span class="line">        target = container</span><br><span class="line">        action = container.action</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://gist.github.com/PEZ/e4a790870855a0bb3a45da2da8f71aa3">UIControl+ListenBlock.swift</a></li>
<li><a href="https://gist.github.com/Moximillian/5f6d60e2cd1222e557547a42558669ae">ClosureProtocolExtensions.swift</a></li>
</ul>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 配置测试用推送通知证书</title>
    <url>/2018/06/29/2018-06-29-iOS%20%E9%85%8D%E7%BD%AE%E6%B5%8B%E8%AF%95%E7%94%A8%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<p>最近做通知的时候需要对通知进行测试，之前没有做证书的经验，这次尝试了一下，写这篇文章备忘。</p>
<p>测试用的工具叫做 Pusher，下载地址：<a href="https://github.com/noodlewerk/NWPusher">NWPusher</a>。非常的好用。</p>
<h3 id="创建测试用-Push-证书"><a href="#创建测试用-Push-证书" class="headerlink" title="创建测试用 Push 证书"></a>创建测试用 Push 证书</h3><hr>
<p>1、打开苹果开发者页面：<a href="https://developer.apple.com/">Developer</a>，登录账户。</p>
<p>2、在账户的 <code>Certificates, Identifiers &amp; Profiles</code> 页面找到 <code>Identifiters</code>，选择 <code>App IDs</code>。</p>
<p>3、找到自己 App，点击打开，能看到如下所示。</p>
<p><img src="/my_pictures/iOS%E9%85%8D%E7%BD%AE%E6%B5%8B%E8%AF%95%E7%94%A8%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E8%AF%81%E4%B9%A6-1.png"></p>
<p>如果你没有配置 <code>Push Notifications</code>，那么它的 <code>Development</code> 和 <code>Distribution</code> 都是 <code>Configurable</code> 状态。点击 <code>Edit</code> 按钮。</p>
<p>我们要创建测试用的证书就点击 <code>Development SSL Certificate</code> 下面的 <code>Create Certificate</code>。</p>
<a id="more"></a>

<p><img src="/my_pictures/iOS%E9%85%8D%E7%BD%AE%E6%B5%8B%E8%AF%95%E7%94%A8%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E8%AF%81%E4%B9%A6-2.png"></p>
<p>直接 <code>Continue</code>，接下来的页面需要我们上传 <code>.certSigningRequest</code> 的文件，这个文件需要在我们自己的电脑上制作。</p>
<h3 id="制作-certSigningRequest-文件"><a href="#制作-certSigningRequest-文件" class="headerlink" title="制作 certSigningRequest 文件"></a>制作 certSigningRequest 文件</h3><hr>
<p>1、打开电脑上的钥匙串应用。</p>
<p>2、点击钥匙串访问 -&gt; 证书助理 -&gt; 从证书颁发机构请求证书…</p>
<p><img src="/my_pictures/iOS%E9%85%8D%E7%BD%AE%E6%B5%8B%E8%AF%95%E7%94%A8%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E8%AF%81%E4%B9%A6-3.png"></p>
<p>3、填写相关信息，生成 <code>.certSigningRequest</code> 文件。</p>
<p><img src="/my_pictures/iOS%E9%85%8D%E7%BD%AE%E6%B5%8B%E8%AF%95%E7%94%A8%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E8%AF%81%E4%B9%A6-4.png"></p>
<h3 id="完成证书制作"><a href="#完成证书制作" class="headerlink" title="完成证书制作"></a>完成证书制作</h3><hr>
<p>1、刚才制作证书那里，上传我们生成的 <code>.certSigningRequest</code> 文件。</p>
<p>2、证书制作完成，下载证书，双击安装到我们的钥匙串中。</p>
<p><img src="/my_pictures/iOS%E9%85%8D%E7%BD%AE%E6%B5%8B%E8%AF%95%E7%94%A8%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E8%AF%81%E4%B9%A6-5.png"></p>
<p>3、因为我们需要的是一个 <code>.p12</code> 的文件，所以我们右键钥匙串刚安装的 <code>Apple Development IOS Push Services</code> 证书，选择导出。</p>
<p><img src="/my_pictures/iOS%E9%85%8D%E7%BD%AE%E6%B5%8B%E8%AF%95%E7%94%A8%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E8%AF%81%E4%B9%A6-6.png"></p>
<p>这样，我们的 Push 证书就做好了。</p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Swift 4 中 NavigationBar 不同颜色时的转场</title>
    <url>/2018/07/06/2018-07-06-NavigationBar%20%E4%B8%8D%E5%90%8C%E9%A2%9C%E8%89%B2%E6%97%B6%E7%9A%84%E8%BD%AC%E5%9C%BA/</url>
    <content><![CDATA[<p>我们在项目中，往往会遇到两个 Navigation Bar 样式不同的问题，如果直接用苹果官方的控件，会出现各种各样的 bug，因为苹果官方的 Navigation Bar 是共用的，所以在两个不同样式的 Navigation Bar 中做转场操作的时候就会出现各种问题。</p>
<p>今天我们就用 Method Swizzling 的方式来修改一下系统的 Navigation Bar 转场时的样式，最终效果如下图所示：</p>
<p><img src="/my_pictures/NavigationBar%E4%B8%8D%E5%90%8C%E9%A2%9C%E8%89%B2%E6%97%B6%E7%9A%84%E8%BD%AC%E5%9C%BA-1.gif"></p>
<h3 id="设置导航栏的背景颜色"><a href="#设置导航栏的背景颜色" class="headerlink" title="设置导航栏的背景颜色"></a>设置导航栏的背景颜色</h3><hr>
<p>我们来为 <code>UIViewController</code> 添加一个扩展，用于存储与设置 <code>Navigation Bar</code> 各种属性。首先，我们来为我们的 <code>UIViewController</code> 添加一个 <code>navBarBgColor</code> 的计算属性。<br>这里运用了 <code>runtime</code> 的关联方法 <code>objc_getAssociatedObject:</code> 和 <code>objc_setAssociatedObject:</code> 来存取所设置的背景颜色。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 设置导航栏的背景颜色</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">var</span> navBarBgColor: <span class="type">UIColor</span> &#123;</span><br><span class="line">		<span class="keyword">get</span> &#123;</span><br><span class="line">		    <span class="keyword">if</span> <span class="keyword">let</span> color = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">DefaultValue</span>.navBarBgColor) <span class="keyword">as</span>? <span class="type">UIColor</span> &#123;</span><br><span class="line">		        <span class="keyword">return</span> color</span><br><span class="line">		    &#125;</span><br><span class="line">		    <span class="keyword">return</span> <span class="type">DefaultValue</span>.navBarBgColor</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">set</span> &#123;</span><br><span class="line">		    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">DefaultValue</span>.navBarBgColor, newValue, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">		    navigationController?.navBarBackgroundColor(newValue)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>这时我们就可以存储与设置导航栏的背景色了。</p>
<p>然后我们再为 <code>NavigationController</code> 添加一个扩展，用来调用 <code>Navigationbar</code> 的具体设置方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UINavigationController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 设置背景色</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">navBarBackgroundColor</span><span class="params">(<span class="keyword">_</span> color: UIColor)</span></span> &#123;</span><br><span class="line">        navigationBar.backgroundColor(color)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后我们在扩展 <code>Navigationbar</code>，添加具体的设置逻辑。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UINavigationBar</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 导航栏背景视图</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> backgroundView: <span class="type">UIView?</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> bgView = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">DefaultValue</span>.backgroundView) <span class="keyword">as</span>? <span class="type">UIView</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> bgView</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">DefaultValue</span>.backgroundView, newValue, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 设置导航栏背景色</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">backgroundColor</span><span class="params">(<span class="keyword">_</span> color: UIColor)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> backgroundView == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 添加一个透明背景的 image 到 _UIBarBackground</span></span><br><span class="line">            setBackgroundImage(<span class="type">UIImage</span>(), <span class="keyword">for</span>: .<span class="keyword">default</span>)</span><br><span class="line">            <span class="keyword">let</span> height = <span class="type">DeviceInfo</span>.deviceName == .iPhoneX ? <span class="number">64</span> : <span class="number">88</span></span><br><span class="line">            backgroundView = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">Int</span>(bounds.width), height: height))</span><br><span class="line">            backgroundView?.autoresizingMask = .flexibleWidth</span><br><span class="line">            <span class="comment">// _UIBarBackground 是 navigationBar 的第一个子视图</span></span><br><span class="line">            subviews.first?.insertSubview(backgroundView ?? <span class="type">UIView</span>(), at: <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        backgroundView?.backgroundColor = color</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们是直接插入一个 <code>View</code> 到 <code>NavigationBar</code> 的 <code>_UIBarBackground </code> 中，我们直接在这个 <code>View</code> 上面修改颜色即可。至此，设置 <code>NavigationBar</code> 的背景色告一段落，下来我们来看看转场如何做到颜色的均匀过度。</p>
<h3 id="颜色过度-runtime"><a href="#颜色过度-runtime" class="headerlink" title="颜色过度 - runtime"></a>颜色过度 - runtime</h3><hr>
<p>要想做到在右滑进行 <code>pop</code> 操作的时候导航栏颜色均匀的过度需要替换一个系统方法 <code>_updateInteractiveTransition:</code>，这个方法是用来监听手势的返回进度的，我们可以在这个方法中计算每一个进度时候导航栏颜色的变化。</p>
<p>大家都知道，在 <code>Objective-C</code> 中进行 <code>Method Swizzling</code> 的时候都需要将替换逻辑放在 <code>dispatch_once</code> 中去执行，保证其执行一次。在 Swift 中，现在已经去掉了 <code>dispatch_once</code> 方法，那么我们应该如何做呢？</p>
<p>苹果文档说道，声明为 <code>static let</code> 和 <code>lazy</code> 的变量具有 <code>dispatch_once</code> 的效果。所以我们就可以用更加 Swift 的方式去实现自己的逻辑，不需要去再造一个 <code>dispatch_once</code> 出来。代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Swift 中 static let 具备 dispatch once 特性，所以可以用这种方式声明，</span></span><br><span class="line"><span class="comment"> * 闭包的形式声明一个代码块，默认是懒加载</span></span><br><span class="line"><span class="comment"> * 类似于 Objective-c 中的 dispatch once</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> swizzle: () = &#123;</span><br><span class="line">    <span class="keyword">let</span> needSwizzleSelectorAry = [</span><br><span class="line">        <span class="type">NSSelectorFromString</span>(<span class="string">&quot;_updateInteractiveTransition:&quot;</span>),</span><br><span class="line">        <span class="keyword">#selector</span>(popToViewController(<span class="keyword">_</span>:animated:)),</span><br><span class="line">        <span class="keyword">#selector</span>(popToRootViewController(animated:))</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">let</span> swizzleSelectorAry = [</span><br><span class="line">        <span class="keyword">#selector</span>(em_updateInteractiveTransition(<span class="keyword">_</span>:)),</span><br><span class="line">        <span class="keyword">#selector</span>(em_popToViewController(<span class="keyword">_</span>:animated:)),</span><br><span class="line">        <span class="keyword">#selector</span>(em_popToRootViewControllerAnimated(<span class="keyword">_</span>:))</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> sel <span class="keyword">in</span> needSwizzleSelectorAry &#123;</span><br><span class="line">        <span class="keyword">let</span> str = (<span class="string">&quot;em_&quot;</span> + sel.description).replacingOccurrences(of: <span class="string">&quot;__&quot;</span>, with: <span class="string">&quot;_&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> originMethod = class_getInstanceMethod(<span class="type">UINavigationController</span>.<span class="keyword">self</span>, sel),</span><br><span class="line">            <span class="keyword">let</span> swizzleMethod = class_getInstanceMethod(<span class="type">UINavigationController</span>.<span class="keyword">self</span>, <span class="type">Selector</span>(str)) &#123;</span><br><span class="line">            </span><br><span class="line">            method_exchangeImplementations(originMethod, swizzleMethod)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>这样就可以实现 <code>dispatch_once</code> 的效果。</p>
<p>接下来又是一个棘手的问题，Swift 中已经没有了 <code>+load</code> 方法怎么办，甚至 Swift 3.1 之后 <code>+initialize</code> 方法都已经不能用了。这可如何是好。经过 Google，发现了一个替代的方案，用 Swift 的协议来进行实现：<a href="http://jordansmith.io/handling-the-deprecation-of-initialize/">Handling the Deprecation of initialize()</a></p>
<p>JORDAN SMITH 想法其实很简单，是通过 <code>runtime</code> 获取到所有类的列表，然后向所有遵循 <code>SelfAware</code> 协议的类发送消息，并且他把这些操作放到了 <code>UIApplication</code> 的 <code>next</code> 属性的调用中，同时发现了 <code>next</code> 属性会在 <code>applicationDidFinishLaunching</code> 之前被调用。 </p>
<p>代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">protocol</span> <span class="title">SelfAware</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">awake</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NothingToSeeHere</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">harmlessFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> typeCount = <span class="type">Int</span>(objc_getClassList(<span class="literal">nil</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">let</span> types = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">AnyClass?</span>&gt;.allocate(capacity: typeCount)</span><br><span class="line">        <span class="keyword">let</span> autoreleasingTypes = <span class="type">AutoreleasingUnsafeMutablePointer</span>&lt;<span class="type">AnyClass</span>&gt;(types)</span><br><span class="line">        objc_getClassList(autoreleasingTypes, <span class="type">Int32</span>(typeCount))</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;typeCount &#123; (types[index] <span class="keyword">as</span>? <span class="type">SelfAware</span>.<span class="type">Type</span>)?.awake() &#125;</span><br><span class="line">        types.deallocate()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIApplication</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 启动只执行一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> runOnce: <span class="type">Void</span> = &#123;</span><br><span class="line">        <span class="type">NothingToSeeHere</span>.harmlessFunction()</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">open</span> <span class="keyword">var</span> next: <span class="type">UIResponder?</span> &#123;</span><br><span class="line">        <span class="comment">/// Called before applicationDidFinishLaunching</span></span><br><span class="line">        <span class="type">UIApplication</span>.runOnce</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在别人的帮助下，我们也算是优雅的实现了需要的功能，我们将 <code>swizzle</code> 方法放在 <code>awake()</code> 中去执行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UINavigationController</span>: <span class="title">SelfAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">awake</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">/// 判断是否是其子类</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">self</span> !== <span class="type">UINavigationController</span>.<span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.swizzle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计算颜色的过度"><a href="#计算颜色的过度" class="headerlink" title="计算颜色的过度"></a>计算颜色的过度</h3><hr>
<p>接下来我们需要一个方法来计算颜色的过度：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算颜色的过度</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">averageColor</span><span class="params">(fromColor: UIColor, toColor: UIColor, percent: CGFloat)</span></span> -&gt; <span class="type">UIColor</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fromRed: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> fromGreen: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> fromBlue: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> fromAlpha: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    fromColor.getRed(&amp;fromRed, green: &amp;fromGreen, blue: &amp;fromBlue, alpha: &amp;fromAlpha)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> toRed: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> toGreen: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> toBlue: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> toAlpha: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    toColor.getRed(&amp;toRed, green: &amp;toGreen, blue: &amp;toBlue, alpha: &amp;toAlpha)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> nowRed = fromRed + (toRed - fromRed) * percent</span><br><span class="line">    <span class="keyword">let</span> nowGreen = fromGreen + (toGreen - fromGreen) * percent</span><br><span class="line">    <span class="keyword">let</span> nowBlue = fromBlue + (toBlue - fromBlue) * percent</span><br><span class="line">    <span class="keyword">let</span> nowAlpha = fromAlpha + (toAlpha - fromAlpha) * percent</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIColor</span>(red: nowRed, green: nowGreen, blue: nowBlue, alpha: nowAlpha)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现我们自己的 <code>_updateInteractiveTransition:</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 用于替换系统的 _updateInteractiveTransition: 方法，监听返回手势进度</span></span><br><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">em_updateInteractiveTransition</span><span class="params">(<span class="keyword">_</span> percentComplete: CGFloat)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">self</span>.isKind(of: <span class="type">EMNavigationController</span>.<span class="keyword">self</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> topVC = <span class="keyword">self</span>.topViewController</span><br><span class="line">    <span class="comment">/// transitionCoordinator 带有两个 VC 的转场上下文</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> coor = topVC?.transitionCoordinator,</span><br><span class="line">        <span class="keyword">let</span> fromVC = coor.viewController(forKey: .from) <span class="keyword">as</span>? <span class="type">EMViewController</span>,</span><br><span class="line">        <span class="keyword">let</span> toVC = coor.viewController(forKey: .to) <span class="keyword">as</span>? <span class="type">EMViewController</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> fromAlpha = fromVC.navBarBgAlpha</span><br><span class="line">        <span class="keyword">let</span> toAlpha = toVC.navBarBgAlpha</span><br><span class="line">        <span class="keyword">let</span> nowAlpha = fromAlpha + (toAlpha - fromAlpha) * percentComplete</span><br><span class="line">        <span class="keyword">self</span>.navBarBackgroundAlpha(nowAlpha)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> fromTintColor = fromVC.navBarTintColor</span><br><span class="line">        <span class="keyword">let</span> toTintColor = toVC.navBarTintColor</span><br><span class="line">        <span class="keyword">let</span> nowTintColor = averageColor(fromColor: fromTintColor, toColor: toTintColor, percent: percentComplete)</span><br><span class="line">        <span class="keyword">self</span>.navBarTintColor(nowTintColor)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> fromColor = fromVC.navBarBgColor</span><br><span class="line">        <span class="keyword">let</span> toColor = toVC.navBarBgColor</span><br><span class="line">        <span class="keyword">let</span> nowColor = averageColor(fromColor: fromColor, toColor: toColor, percent: percentComplete)</span><br><span class="line">        <span class="keyword">self</span>.navBarBackgroundColor(nowColor)</span><br><span class="line">    &#125;</span><br><span class="line">    em_updateInteractiveTransition(percentComplete)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们的过度效果算是搞定一半，还有另外一半就是处理手势取消了。我们需要在 <code>navigationBar:shouldPopItem:</code> 方法中来处理我们的手势取消操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UINavigationController</span>: <span class="title">UINavigationBarDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// pop</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">navigationBar</span><span class="params">(<span class="keyword">_</span> navigationBar: UINavigationBar,</span></span></span><br><span class="line"><span class="function"><span class="params">                              shouldPop item: UINavigationItem)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> topVC = topViewController,</span><br><span class="line">            <span class="keyword">let</span> coor = topVC.transitionCoordinator,</span><br><span class="line">            coor.initiallyInteractive &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">#available</span>(iOS <span class="number">10.0</span>, *) &#123;</span><br><span class="line">                coor.notifyWhenInteractionChanges(&#123; (context) <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">self</span>.dealInteractionChanges(context)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                coor.notifyWhenInteractionEnds(&#123; (context) <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">self</span>.dealInteractionChanges(context)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> itemCount = navigationBar.items?.<span class="built_in">count</span> ?? <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> n = viewControllers.<span class="built_in">count</span> &gt;= itemCount ? <span class="number">2</span> : <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> popToVC = viewControllers[viewControllers.<span class="built_in">count</span> - n]</span><br><span class="line">        </span><br><span class="line">        popToViewController(popToVC, animated: <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 处理返回手势中断的情况</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">dealInteractionChanges</span><span class="params">(<span class="keyword">_</span> context: UIViewControllerTransitionCoordinatorContext)</span></span> &#123;</span><br><span class="line">        <span class="comment">/// 设置动画</span></span><br><span class="line">        <span class="keyword">let</span> animations: (<span class="type">UITransitionContextViewControllerKey</span>) -&gt; () = &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> vc = context.viewController(forKey: $<span class="number">0</span>) <span class="keyword">as</span>? <span class="type">EMViewController</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>?.updateAllStyle(vc)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> context.isCancelled &#123;</span><br><span class="line">            <span class="comment">/// 手势取消</span></span><br><span class="line">            <span class="keyword">let</span> cancelDuration: <span class="type">TimeInterval</span> = context.transitionDuration * <span class="type">Double</span>(context.percentComplete)</span><br><span class="line">            <span class="type">UIView</span>.animate(withDuration: cancelDuration) &#123;</span><br><span class="line">                animations(.from)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/// 手势完成</span></span><br><span class="line">            <span class="keyword">let</span> finishDuration: <span class="type">TimeInterval</span> = context.transitionDuration * <span class="type">Double</span>(<span class="number">1</span> - context.percentComplete)</span><br><span class="line">            <span class="type">UIView</span>.animate(withDuration: finishDuration) &#123;</span><br><span class="line">                animations(.to)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们的导航栏过度效果基本完成，还有一些其他的细节处理，请看我的 <a href="https://github.com/TomatosX/EMNavigationBarTransition">GitHub</a> 源码吧。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="http://blog.leanote.com/post/yaoli/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%9C%A8Swift4%E4%B8%AD%E5%AE%9E%E7%8E%B0Method-Swizzling">如何优雅地在Swift4中实现Method Swizzling</a></li>
<li><a href="http://jordansmith.io/handling-the-deprecation-of-initialize/">Handling the Deprecation of initialize()</a></li>
<li><a href="https://stackoverflow.com/questions/42824541/swift-3-1-deprecates-initialize-how-can-i-achieve-the-same-thing#comment73341029_42824542">Swift 3.1 deprecates initialize(). How can I achieve the same thing?</a></li>
<li><a href="https://stackoverflow.com/questions/37801407/whither-dispatch-once-in-swift-3">Whither dispatch_once in Swift 3?</a></li>
<li><a href="https://www.jianshu.com/p/454b06590cf1">导航栏的平滑显示和隐藏 - 个人页的自我修养（1）</a></li>
<li><a href="https://www.jianshu.com/p/540a7e6f7b40">超简单！！！ iOS设置状态栏、导航栏按钮、标题、颜色、透明度，偏移等</a></li>
</ul>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 11 中 UIRefreshControll 消失【译】</title>
    <url>/2018/07/07/2018-07-07-iOS11%E4%B8%ADUIRefreshControll%E6%B6%88%E5%A4%B1%E3%80%90%E8%AF%91%E3%80%91/</url>
    <content><![CDATA[<h3 id="问"><a href="#问" class="headerlink" title="问"></a>问</h3><hr>
<p>我有一个带有 <code>largeTitle</code> 和 <code>searchcontroller</code> 的 <code>navigationBar</code> ，我的 <code>tableView</code> 有一个 <code>refreshcontrol</code> 。 </p>
<p>当我拉动刷新时，<code>refreshcontrol</code> 的 <code>activityIndicator</code> 消失了，但是刷新过程仍然在继续，即使进程完成并且我调用 <code>UIRefreshControll</code> 的 <code>endRefreshing()</code> 方法，导航栏也不会恢复到正常大小。</p>
<p><img src="/my_pictures/iOS11%E4%B8%ADUIRefreshControll%E6%B6%88%E5%A4%B1%E3%80%90%E8%AF%91%E3%80%91-1.gif"></p>
<p>有人遇到过同样的问题吗？</p>
<a id="more"></a>

<h3 id="答"><a href="#答" class="headerlink" title="答"></a>答</h3><hr>
<p>我已经找了几个星期，今天我终于找到了解决方案，终于成功了。解决的方式非常简单，我不敢相信我竟然没有早点找到。</p>
<p>我正在使用带有 <code>UITableView</code> 的普通 <code>UIViewController</code>。我将约束设置成上与下都是 0，如图所示：</p>
<p><img src="/my_pictures/iOS11%E4%B8%ADUIRefreshControll%E6%B6%88%E5%A4%B1%E3%80%90%E8%AF%91%E3%80%91-2.png"></p>
<p>一次，我改变了约束，将 <code>UITableView</code> 约束相对于 <code>Superview</code> 的所有边缘，值均为0，然后它竟然开始工作了：</p>
<p><img src="/my_pictures/iOS11%E4%B8%ADUIRefreshControll%E6%B6%88%E5%A4%B1%E3%80%90%E8%AF%91%E3%80%91-3.png"></p>
<p>我甚至没有设置任何其他东西。我非常希望这能为你解决这个问题，因为它太烦人了……</p>
<p>原文：<a href="https://stackoverflow.com/questions/46793716/ios-11-uirefreshcontrol-with-navigationbar-largetitle-and-searchcontroller-disap">iOS 11 UIRefreshControl with NavigationBar LargeTitle and SearchController disappearing
</a></p>
]]></content>
      <categories>
        <category>文章翻译</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>处理 initialize() 的弃用【译】</title>
    <url>/2018/07/08/2018-07-08-%E5%A4%84%E7%90%86%20initialize()%20%E7%9A%84%E5%BC%83%E7%94%A8%E3%80%90%E8%AF%91%E3%80%91/</url>
    <content><![CDATA[<p>在将项目迁移到 Swift 3.1 后，我受到了几个警告的欢迎。它们似乎都没有特别难以修复，只是除了这个之外：</p>
<blockquote>
<p>Method ‘initialize()’ defines Objective-C class method ‘initialize’, which is not guaranteed to be invoked by Swift and will be disallowed in future versions.</p>
</blockquote>
<p>Ouch。一些类重写了 <code>NSObject</code> 的 <code>initialize()</code> 函数，警告清楚地表明这已不在合适（或者至少，但它应该不会很快发生）。一个非常类似的方法 - <code>load()</code>，它自 Swift 1.2 以来一直没有，所以看起来初始化将很快跟进。它扮演着一个独特的角色，如 <code>NSObject</code> <a href="https://developer.apple.com/documentation/objectivec/nsobject/1418639-initialize">文档</a>所述：</p>
<blockquote>
<p>The runtime sends <code>initialize()</code> to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program.</p>
</blockquote>
<a id="more"></a>

<h3 id="为什么用-initialize-？"><a href="#为什么用-initialize-？" class="headerlink" title="为什么用 initialize()？"></a>为什么用 <code>initialize()</code>？</h3><hr>
<p>如果你处于相同的情况，首先要问的问题可能是“我真的需要这个吗？”。如果你不需要的话，将逻辑移到其他地方，省去麻烦，并调用它。您通常是不需要它提供的行为的，但是自从 Swift 1.2 以后就不再支持 <code>load()</code>了，也没有任何明显的其他选择。在我的例子中，<code>initialize()</code> 被用作 <a href="http://nshipster.com/swift-objc-runtime/"><code>method swizzling</code></a> 的入口点（可能是 <code>initialize()</code> 的最常用的用例了）。Swizzling 允许我修补 iOS 中导致多次崩溃的错误。如果你从未听说过 <code>method swizzling</code>，请不要强迫自己…我只建议在特殊情况下使用它。</p>
<h3 id="一个简单的解决方式"><a href="#一个简单的解决方式" class="headerlink" title="一个简单的解决方式"></a>一个简单的解决方式</h3><hr>
<p>在考虑到这一点之前，<code>load()</code>和 <code>initialize()</code> 的一个简单替代方法是从应用程序执行你的逻辑<code>application(_:didFinishLaunchingWithOptions:)</code>。我建议保留相关类中包含的逻辑，并从 <code>application delegate</code> 中获取。从功能上讲，这个解决方案比 <code>initialize()</code> 更类似于 <code>load()</code>，但在大多数情况下，这是完全足够的。</p>
<p>这是相当直接的一种解决方式，在大多数情况下，为了简单起见，我建议这么做。但是，有一两个小警告。您可能有很多类要执行此操作，因此从应用程序委托中执行此操作会有点笨拙。也许您无权访问应用程序委托，或者您可能希望解决方案看起来比当前建议更具结构性。</p>
<h3 id="一个不那么简单的解决方案"><a href="#一个不那么简单的解决方案" class="headerlink" title="一个不那么简单的解决方案"></a>一个不那么简单的解决方案</h3><hr>
<p>以下功能也比 <code>initialize()</code> 更接近 <code>load()</code>。目标是为类定义一种简单的方法来采用一个函数，并在使用该类之前调用​​该函数。虽然内部不那么简单，但它可以很好地扩展，并且是完全自包含的 - 否定了向应用程序委托添加代码的任何要求。</p>
<p>首先，定义以下 Swift 代码。目的是为任何您想要类似初始化行为的类提供一个简单的入口点 - 现在可以通过符合 <code>SelfAware</code> 协议来完成。它还提供单个函数来为每个符合要求的类启动此行为。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SelfAware</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">awake</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NothingToSeeHere</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">harmlessFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> typeCount = <span class="type">Int</span>(objc_getClassList(<span class="literal">nil</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">let</span> types = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">AnyClass?</span>&gt;.allocate(capacity: typeCount)</span><br><span class="line">        <span class="keyword">let</span> safeTypes = <span class="type">AutoreleasingUnsafeMutablePointer</span>&lt;<span class="type">AnyClass?</span>&gt;(types)</span><br><span class="line">        objc_getClassList(safeTypes, <span class="type">Int32</span>(typeCount))</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span> ..&lt; typeCount &#123; (types[index] <span class="keyword">as</span>? <span class="type">SelfAware</span>.<span class="type">Type</span>)?.awake() &#125;</span><br><span class="line">        types.deallocate(capacity: typeCount)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们仍然需要一种方法来运行我们定义的函数，即 <code>NothingToSeeHere.harmlessFunction()</code>，在应用程序启动时。您可以从应用程序委托调用此方法，但如果您希望确保解决方案是自包含的，则以下提供了一种为 iOS 执行此操作的方法。对于没有 <code>UIApplication</code> 的 macOS 或其他平台，将需要以下变体。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> runOnce: <span class="type">Void</span> = &#123;</span><br><span class="line">        <span class="type">NothingToSeeHere</span>.harmlessFunction()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">open</span> <span class="keyword">var</span> next: <span class="type">UIResponder?</span> &#123;</span><br><span class="line">        <span class="comment">// Called before applicationDidFinishLaunching</span></span><br><span class="line">        <span class="type">UIApplication</span>.runOnce</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用此代码，符合协议 <code>SelfAware</code> 将授予任何类所需的行为。这样做相当容易和结构化，所以虽然这个解决方案的内部工作“不那么简单”，但我们现在有一个非常简洁的方法来向任何类添加类似初始化的行为。</p>
<h3 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h3><hr>
<p><a href="http://jordansmith.io/handling-the-deprecation-of-initialize/">Handling the Deprecation of initialize()</a></p>
]]></content>
      <categories>
        <category>文章翻译</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>WKWebView 中注入 cookie</title>
    <url>/2018/07/14/2018-07-14-WKWebView%E4%B8%AD%E6%B3%A8%E5%85%A5cookie/</url>
    <content><![CDATA[<p>在项目中，往往有这样的要求，用 API 进行登录之后在某个 <code>WKWebView</code> 的页面需要用 <code>cookie</code> 去验证身份（虽然我更喜欢用 <code>accesstoken</code> 去验证🙃）。<code>WKWebView</code> 是苹果官方建议的控件来替代老旧的 <code>UIWebView</code>。但是 <code>WKWebView</code> 的 <code>cookie</code> 无法共享 <code>NSHTTPCookieStorage</code>，所以这时候就需要我们自己去管理 <code>cookie</code>。（iOS 11 上新增了 <code>WKHTTPCookieStore</code> 来管理）</p>
<p>首先我们先解析获取到的 <code>cookie</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 解析 cookie</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">analysisCookie</span><span class="params">(response: HTTPURLResponse)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> fields = response.allHeaderFields <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">String</span>],</span><br><span class="line">        <span class="keyword">let</span> url = response.url</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> cookies = <span class="type">HTTPCookie</span>.cookies(withResponseHeaderFields: fields,</span><br><span class="line">                                         <span class="keyword">for</span>: url)</span><br><span class="line">        <span class="keyword">let</span> storage = <span class="type">HTTPCookieStorage</span>.shared</span><br><span class="line">        <span class="keyword">for</span> cookie <span class="keyword">in</span> cookies &#123;</span><br><span class="line">            <span class="comment">/// 将 cookie 存入本地</span></span><br><span class="line">            storage.setCookie(cookie)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>在 <code>WKWebView</code> 中注入 <code>cookie</code> 有两种方式，第一种，通过请求带过去</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> reqURL = <span class="type">URLRequest</span>(url: url)</span><br><span class="line">    <span class="keyword">let</span> cookie = (<span class="type">HTTPCookieStorage</span>.shared.cookies ?? []).strCookie</span><br><span class="line">    reqURL.addValue(cookie, forHTTPHeaderField: <span class="string">&quot;cookie&quot;</span>)</span><br><span class="line">    webView.load(reqURL)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式，<code>js</code> 注入</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">createWeb</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> config = <span class="type">WKWebViewConfiguration</span>()</span><br><span class="line">    <span class="keyword">let</span> cookie = (<span class="type">HTTPCookieStorage</span>.shared.cookies ?? []).userScript</span><br><span class="line">    <span class="keyword">let</span> user = <span class="type">WKUserContentController</span>()</span><br><span class="line">    <span class="keyword">let</span> cookieScript = <span class="type">WKUserScript</span>(source: cookie,</span><br><span class="line">                                    injectionTime: .atDocumentStart,</span><br><span class="line">                                    forMainFrameOnly: <span class="literal">false</span>)</span><br><span class="line">    user.addUserScript(cookieScript)</span><br><span class="line">    config.userContentController = user</span><br><span class="line">    webView = <span class="type">WKWebView</span>(frame: <span class="keyword">self</span>.view.bounds, configuration: config)</span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(webView)</span><br><span class="line">    webView.load(requestURL)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>moya 的用法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> headers: [<span class="type">String</span> : <span class="type">String</span>]? &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .login, .checkUpdate, .idCodeImg:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">HTTPCookieStorage</span>.shared.cookies ?? []).moya</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们需要将 <code>HTTPCookie</code> 类型转换一下，我们给 <code>Array</code> 添加几个扩展</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">HTTPCookie</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 返回 moya 使用格式 cookie</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> moya: [<span class="type">String</span>: <span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> cookie: [<span class="type">String</span>: <span class="type">String</span>] = [:]</span><br><span class="line">        cookie[<span class="string">&quot;Cookie&quot;</span>] = <span class="keyword">self</span>.<span class="built_in">map</span> &#123; <span class="string">&quot;\($0.name)=\($0.value)&quot;</span> &#125;.joined(separator: <span class="string">&quot;;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> cookie</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 返回 js 注入的字符串格式 cookie</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> userScript: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.<span class="built_in">map</span> &#123; <span class="string">&quot;document.cookie=&#x27;\($0.name)=\($0.value)&#x27;&quot;</span> &#125;.joined(separator: <span class="string">&quot;;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 返回字符串类型 cookie</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> strCookie: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.<span class="built_in">map</span> &#123; <span class="string">&quot;\($0.name)=\($0.value)&quot;</span> &#125;.joined(separator: <span class="string">&quot;;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我的项目中通过第二种方式实现了验证成功。</p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 面向协议 - 为类提供基于 Storyboard 的初始化方法</title>
    <url>/2018/07/27/2018-07-27-Swift%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE-%E4%B8%BA%E7%B1%BB%E6%8F%90%E4%BE%9B%E5%9F%BA%E4%BA%8EStoryboard%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>之前我们说过了运用面向协议的思想为控件添加 <code>action</code> 今天我们再来写一个基于 <code>Storyboard</code> 的初始化方法。在我的项目中，我没有将所有的 <code>controller</code> 都放在一个 <code>Storyboard</code> 文件中，原因有两个：</p>
<ul>
<li>当 <code>Controller</code> 很多的时候不方便查找对应的 <code>Storyboard</code>。</li>
<li>打开 <code>Storyboard</code> 会非常卡。</li>
</ul>
<p>所以我将 <code>Controller</code> 拆分成一个个的 <code>Storyboard</code> 文件。在对应的类中，我需要在每个类都写上一个初始化方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">instantiate</span><span class="params">()</span></span> -&gt; <span class="type">HomeViewController</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIStoryboard</span>(name: .home)</span><br><span class="line">        .instantiateViewControllerWithClass(type: <span class="type">HomeViewController</span>.<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>当你的 App 页面非常多的时候你会发现到处都是 <code>instantiate()</code> 方法，所以我们需要用 Swift 中强大的 <code>Protocol</code> 思想进行一次优化了。</p>
<p>首先我们需要声明一个协议 <code>StoryboardLoadable</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">StoryboardLoadable</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在协议中我们可以什么都不用写。接下来我们扩展这个协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">StoryboardLoadable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">instantiate</span><span class="params">()</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="comment">/// 移除类的 viewcontroller 后缀，创建 storyboard 名</span></span><br><span class="line">        <span class="keyword">let</span> sbName = <span class="string">&quot;\(self)&quot;</span>.removingSuffix(<span class="string">&quot;ViewController&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIStoryboard</span>(name: sbName).instantiateViewControllerWithClass(type: <span class="type">Self</span>.<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子，我的登录页面的控制器名称为 <code>LoginViewController</code>，对应的 <code>Storyboard</code> 名称为 <code>Login</code>，所以我需要执行 <code>let sbName = &quot;\(self)&quot;.removingSuffix(&quot;ViewController&quot;)</code> 来生成 <code>Storyboard</code> 名称。</p>
<p>然后我们在我们的类中遵循这个协议即可。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginViewController</span>: <span class="title">StoryboardLoadable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以后就可以在其他地方这样初始化你的类了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> loginVC = <span class="type">LoginViewController</span>.instantiate()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 下使用 SQLite 教程：入门【译】</title>
    <url>/2018/08/02/2018-08-02-Swift%E4%B8%8B%E4%BD%BF%E7%94%A8SQLite%E6%95%99%E7%A8%8B%EF%BC%9A%E5%85%A5%E9%97%A8%E3%80%90%E8%AF%91%E3%80%91/</url>
    <content><![CDATA[<blockquote>
<p>更新说明：本教程已由 Nikolas Burk 更新为 Xcode 9，iOS 11 和 Swift 4。最初的教程由 Chris Wagner 编写。</p>
</blockquote>
<p>这篇教程向你展示了如何在 Swift 平台上使用流行的数据库 SQLite。在软件开发的领域，你需要很长时间才能保存应用数据。在很多情况下，这是以数据结构形式出现的。但是，如何有效的存储它 – 什么是有效的存储？</p>
<p>幸运的是，一些伟大的思想家已经开发出用于在数据库中存储结构化数据和编写语言功能以访问数据的解决方案。SQLite 默认在 iOS 中是可用的。实际上，如果你以前使用过 Core Data，那么你实际上已经使用过 SQLite，因为 Core Data 只是 SQLite 上的一个层封装，它提供了更方便的API。</p>
<p>通过这篇教程，你将学习到如何执行以下数据库的操作：</p>
<ul>
<li>创建和连接一个数据库</li>
<li>创建一个表</li>
<li>插入一行</li>
<li>更新一行</li>
<li>删除一行</li>
<li>查询数据库</li>
<li>处理 SQLite 错误</li>
</ul>
<p>在学习如何执行这些基本操作之后，你将看到如何以类似 Swift 的方式将它们包装起来。这将允许你为应用程序编写抽象 API，以便你（大多数）可以避免去直接使用 SQLite 的 C API 的痛苦！:]</p>
<p>最后，我将简要介绍一下流行的开源 Swift 包装器 SQLite.swift，以便你能大致的了解一下底层框架是如何工作的。</p>
<blockquote>
<p>注意：数据库，甚至只是 SQLite 本身，都是一个非常大的主题，因此它们大多超出了本教程的范围。本教程假设你对关系数据库意识形态有基本的了解，并且你主要在这里学习如何在 Swift 下使用 SQLite。</p>
</blockquote>
<a id="more"></a>

<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><hr>
<p>下载工程：<a href="https://koenig-media.raywenderlich.com/uploads/2017/09/sqlite-starter-1.zip">starter project for this SQLite with Swift tutorial</a> 并打开 <code>SQLiteTutorial.xcworkspace</code>。<br>从 <code>Project Navigator</code> 打开教程的 <code>playground</code> 文件。</p>
<blockquote>
<p>注意：项目打包在 Xcode 工作区中，因为它使用 SQLite3 依赖项作为嵌入式二进制文件。此二进制文件包含你将在本教程中编写的 SQLite 代码的所有功能。 </p>
</blockquote>
<p>请注意，请将你的 <code>Playground</code> 配置为手动而不是自动运行：</p>
<p><img src="/my_pictures/Swift%E4%B8%8B%E4%BD%BF%E7%94%A8SQLite%E6%95%99%E7%A8%8B%EF%BC%9A%E5%85%A5%E9%97%A8-1.png"></p>
<p>这意味着它只会在你通过点击“运行”按钮的时候执行。</p>
<p>你可能还会看到在页面的顶部我们调用了 <code>destroyPart1Database()</code>；你可以放心的忽略这一点，因为 Playground 每次运行的时候都会销毁这个文件。这可以确保在 Swift 教程浏览此 SQLite 时，所有的语句都能成功的执行。</p>
<p>你的 Playground 需要在你的文件系统上编写 SQLite 数据库文件，在终端中运行以下命令以创建游乐场数据库目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/Documents/Shared\ Playground\ Data/SQLiteTutorial</span><br></pre></td></tr></table></figure>

<h2 id="为什么选择-SQLite？"><a href="#为什么选择-SQLite？" class="headerlink" title="为什么选择 SQLite？"></a>为什么选择 SQLite？</h2><hr>
<p>没错，SQLite 不是在 iOS 上保留数据的唯一方法。除了 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/index.html">Core Data</a>，还有许多其他数据持久性替代方案，包括 <a href="https://realm.io/">Realm</a>，<a href="http://developer.couchbase.com/mobile/#couchbase-lite">Couchbase Lite</a>，<a href="https://firebase.google.com/docs/">Firebase</a> 和 <a href="http://nshipster.com/nscoding/">NSCoding</a>。</p>
<p>每个都有自己的优点和缺点 - 包括 SQLite 本身，数据持久性没有灵丹妙药，作为开发人员，你可以根据应用程序的要求确定哪个选项超过其他选项。</p>
<p>SQLite 确实有一些优点：</p>
<ul>
<li>随 iOS 一起提供，因此它不会为你的应用程序包增加任何开销。</li>
<li>试过并经过测试; 1.0 版于 2000 年 8 月发布。</li>
<li>开源。</li>
<li>适用于数据库开发人员和管理员的熟悉查询语言。</li>
<li>跨平台</li>
</ul>
<p>SQLite 的缺点可能是非常主观和自以为是，所以我们将把研究留给你了！:]</p>
<h2 id="C-的-API"><a href="#C-的-API" class="headerlink" title="C 的 API"></a>C 的 API</h2><hr>
<p>这部分 SQLite with Swift 教程将引导你完成最常见和最基本的 SQLite API。你很快就会意识到在 Swift 方法中包装 C API 将是理想的选择，但要紧紧抓住并首先完成 C 代码； 你将在本教程的第二部分做一些包装。</p>
<h2 id="打开连接"><a href="#打开连接" class="headerlink" title="打开连接"></a>打开连接</h2><hr>
<p>在做任何事情之前，你首先需要创建一个数据库连接。<br>在 <code>Playground</code> 的“Getting Started”部分下添加以下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openDatabase</span><span class="params">()</span></span> -&gt; <span class="type">OpaquePointer?</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> db: <span class="type">OpaquePointer?</span> = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_open(part1DbPath, &amp;db) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Successfully opened connection to database at \(part1DbPath)&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to open database. Verify that you created the directory described &quot;</span> +</span><br><span class="line">      <span class="string">&quot;in the Getting Started section.&quot;</span>)</span><br><span class="line">    <span class="type">PlaygroundPage</span>.current.finishExecution()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法调用 <code>sqlite3_open()</code>。这将打开或创建一个新的数据库文件，如果打开成功，它将会返回一个 <code>OpaquePointer</code>；这是一个用于 C 指针的 Swift 类型，无法直接在 Swift 中表示，当你调用这个方法时，你必须捕获返回的指针才能与数据库进行交互。</p>
<p>许多 SQLite 函数返回 <code>Int32</code> 结果代码。这些代码中的大多数都被定义为 SQLite 库中的常量。例如，<code>SQLITE_OK</code> 表示结果代码 0。在这里你能找到不同的结果代码的列表：<a href="https://www.sqlite.org/rescode.html">on the main SQLite site</a>。</p>
<p>要打开数据库，请将下面的代码添加到 <code>Playground</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> db = openDatabase()</span><br></pre></td></tr></table></figure>

<p>点击 <code>Play</code> 按钮运行 <code>Playground</code>并在控制台查看输出，如果控制台没有打开，请点击 <code>Play</code> 左侧的按钮：</p>
<p><img src="/my_pictures/Swift%E4%B8%8B%E4%BD%BF%E7%94%A8SQLite%E6%95%99%E7%A8%8B%EF%BC%9A%E5%85%A5%E9%97%A8-2.png"></p>
<p>如果 <code>openDatabase()</code> 运行成功，你将看到如下的输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Successfully</span> opened connection to database at /<span class="type">Users</span>/username/<span class="type">Documents</span>/<span class="type">Shared</span> <span class="type">Playground</span> <span class="type">Data</span>/<span class="type">SQLiteTutorial</span>/<span class="type">Part1</span>.sqlite</span><br></pre></td></tr></table></figure>

<p>这里的 <code>username</code> 是你的 <code>Home</code> 目录。</p>
<h2 id="创建一个表"><a href="#创建一个表" class="headerlink" title="创建一个表"></a>创建一个表</h2><hr>
<p>现在你已经连接到数据库文件，你可以创建一个表。你将使用一个非常简单的表来存储联系人。</p>
<p>这个表将包含两列；<code>Id</code> 是一个 <code>Int</code> 类型并且是一个主键 <code>PRIMARY KEY</code>；<code>name</code> 是一个 <code>CHAR(255)</code> 类型。</p>
<p><img src="/my_pictures/Swift%E4%B8%8B%E4%BD%BF%E7%94%A8SQLite%E6%95%99%E7%A8%8B%EF%BC%9A%E5%85%A5%E9%97%A8-3.png"></p>
<p>添加以下字符串，其中包含创建表所需的 SQL 语句：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createTableString = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">CREATE TABLE Contact(</span></span><br><span class="line"><span class="string">Id INT PRIMARY KEY NOT NULL,</span></span><br><span class="line"><span class="string">Name CHAR(255));</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>请注意，你正在使用 Swift 4 的便捷多语法来编写此语句！</p>
<p>接下来，添加执行 <code>CREATE TABLE</code> SQL 语句的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createTable</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> createTableStatement: <span class="type">OpaquePointer?</span> = <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_prepare_v2(db, createTableString, -<span class="number">1</span>, &amp;createTableStatement, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> sqlite3_step(createTableStatement) == <span class="type">SQLITE_DONE</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Contact table created.&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Contact table could not be created.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CREATE TABLE statement could not be prepared.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  sqlite3_finalize(createTableStatement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来一步一步的分析：</p>
<ol>
<li>首先，在下一步中创建一个指针。</li>
<li><code>sqlite3_prepare_v2()</code> 将 SQL 语句编译为字节代码并返回状态代码 - 在对数据库执行任意语句之前的重要步骤。如果你有兴趣，可以在<a href="https://www.sqlite.org/c3ref/prepare.html">这里</a>找到更多信息。检查返回的状态代码以确保语句编译成功。如果是，则该过程转到步骤3; 否则，你打印一条消息，指出该语句无法编译。</li>
<li><code>sqlite3_step()</code> 运行已编译的语句。在这种情况下，你只需“步进”一次，因为此语句只有一个结果。稍后在本教程中，你将看到何时需要多次执行单个语句。</li>
<li>你必须始终在编译语句上调用 <code>sqlite3_finalize()</code> 以删除它并避免资源泄漏。一旦声明完成，你就不应该再次使用它。</li>
</ol>
<p>现在，将以下方法调用添加到 <code>Playground</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">createTable()</span><br></pre></td></tr></table></figure>

<p>运行你的 <code>Playground</code>；你应该看到控制台输出中出现以下内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Contact</span> table created.</span><br></pre></td></tr></table></figure>

<p>现在你有了一个表，是时候向它添加一些数据了。你将添加 <code>Id</code> 为 1 且 <code>Name</code> 为“Ray”的单行。</p>
<h2 id="插入一些数据"><a href="#插入一些数据" class="headerlink" title="插入一些数据"></a>插入一些数据</h2><hr>
<p>将以下 SQL 语句添加到 <code>Playground</code> 的底部：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> insertStatementString = <span class="string">&quot;INSERT INTO Contact (Id, Name) VALUES (?, ?);&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果你没有太多的 SQL 经验，这可能看起来有点奇怪。为什么 <code>values</code> 由问号代表？</p>
<p>在使用 <code>sqlite3_prepare_v2()</code> 编译语句时，请记住上面的内容？这个 <code>?</code> 语法告诉编译器在实际执行语句时将提供实际值。</p>
<p>这有性能方面的考虑，并且允许你提前编译语句，这可以提高性能，因为编译是一项代价高昂的操作。然后可以使用不同的值重复使用已编译的语句。</p>
<p>接下来，在你的 <code>Playground</code> 中创建以下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> insertStatement: <span class="type">OpaquePointer?</span> = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_prepare_v2(db, insertStatementString, -<span class="number">1</span>, &amp;insertStatement, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int32</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">NSString</span> = <span class="string">&quot;Ray&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    sqlite3_bind_int(insertStatement, <span class="number">1</span>, id)</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    sqlite3_bind_text(insertStatement, <span class="number">2</span>, name.utf8String, -<span class="number">1</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">if</span> sqlite3_step(insertStatement) == <span class="type">SQLITE_DONE</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Successfully inserted row.&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Could not insert row.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;INSERT statement could not be prepared.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5</span></span><br><span class="line">  sqlite3_finalize(insertStatement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是上述方法的工作原理：</p>
<ol>
<li>首先，编译语句并验证一切正常；</li>
<li>在这里，你为值定义一个 <code>?</code> 占位符。函数的名称 - <code>sqlite3_bind_int()</code> - 意味着你将 <code>Int</code> 值绑定到语句。函数的第一个参数是要绑定的语句，而第二个参数是基于非零的索引 <code>?</code> 的位置。第三个也是最后一个参数是值本身。此绑定调用返回状态代码，但现在你认为它成功；</li>
<li>执行相同的绑定过程，但这次是文本值。此次调用还有两个附加参数；出于本教程的目的，你可以简单地为它们传递 <code>-1</code> 和 <code>nil</code>。如果你愿意，可这里<a href="https://www.sqlite.org/c3ref/bind_blob.html">此处</a>阅读有关绑定参数的更多信息；</li>
<li>使用 <code>sqlite3_step()</code>函数执行语句并验证它是否已完成；</li>
<li>一如既往，最后执行 <code>finalize</code> 语句。如果你要插入多个联系人，则可能会保留该语句并使用不同的值重新使用它。</li>
</ol>
<p>接下来，通过将以下内容添加到 <code>Playground</code> 中来调用你的新方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">insert()</span><br></pre></td></tr></table></figure>

<p>运行你的 <code>Playground</code> 并验证你在控制台输出中看到以下内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Successfully</span> inserted row.</span><br></pre></td></tr></table></figure>

<h2 id="挑战：多个插入"><a href="#挑战：多个插入" class="headerlink" title="挑战：多个插入"></a>挑战：多个插入</h2><hr>
<p>挑战的时间！你的任务是更新 <code>insert()</code> 以插入联系人数组。</p>
<p>作为提示，你需要在再次执行之前调用 <code>sqlite3_reset()</code> 将已编译的语句重置回其初始状态。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> insertStatement: <span class="type">OpaquePointer?</span> = <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> names: [<span class="type">NSString</span>] = [<span class="string">&quot;Ray&quot;</span>, <span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Martha&quot;</span>, <span class="string">&quot;Danielle&quot;</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> sqlite3_prepare_v2(db, insertStatementString, -<span class="number">1</span>, &amp;insertStatement, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (index, name) <span class="keyword">in</span> names.enumerated() &#123;</span><br><span class="line">      <span class="comment">// 3</span></span><br><span class="line">      <span class="keyword">let</span> id = <span class="type">Int32</span>(index + <span class="number">1</span>)</span><br><span class="line">      sqlite3_bind_int(insertStatement, <span class="number">1</span>, id)</span><br><span class="line">      sqlite3_bind_text(insertStatement, <span class="number">2</span>, name.utf8String, -<span class="number">1</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> sqlite3_step(insertStatement) == <span class="type">SQLITE_DONE</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Successfully inserted row.&quot;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Could not insert row.&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 4</span></span><br><span class="line">      sqlite3_reset(insertStatement)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlite3_finalize(insertStatement)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;INSERT statement could not be prepared.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，代码与你已有的代码非常相似，但具有以下显着差异：</p>
<ol>
<li>现在有一系列联系人，而不是一个常数；</li>
<li>对每个联系人列出一次数组；</li>
<li>现在，索引是从枚举的索引生成的，该索引对应于数组中联系人姓名的位置；</li>
<li>SQL 语句在每个枚举结束时重置，以便下一个可以使用它。</li>
</ol>
<h3 id="查询联系人"><a href="#查询联系人" class="headerlink" title="查询联系人"></a>查询联系人</h3><hr>
<p>既然你已经插入了一两行，那么确定它们真的存在就确实很好！:]</p>
<p>将以下内容添加到 <code>Playground</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queryStatementString = <span class="string">&quot;SELECT * FROM Contact;&quot;</span></span><br></pre></td></tr></table></figure>

<p>此查询只是从联系人表中检索所有记录。使用 <code>*</code> 表示将返回所有列。</p>
<p>添加以下方法以执行查询：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> queryStatement: <span class="type">OpaquePointer?</span> = <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_prepare_v2(db, queryStatementString, -<span class="number">1</span>, &amp;queryStatement, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> sqlite3_step(queryStatement) == <span class="type">SQLITE_ROW</span> &#123;</span><br><span class="line">      <span class="comment">// 3</span></span><br><span class="line">      <span class="keyword">let</span> id = sqlite3_column_int(queryStatement, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4</span></span><br><span class="line">      <span class="keyword">let</span> queryResultCol1 = sqlite3_column_text(queryStatement, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">let</span> name = <span class="type">String</span>(cString: queryResultCol1!)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Query Result:&quot;</span>)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;\(id) | \(name)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Query returned no results&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;SELECT statement could not be prepared&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6</span></span><br><span class="line">  sqlite3_finalize(queryStatement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依次记录每个编号的评论：</p>
<ol>
<li>准备声明。</li>
<li>执行该语句。请注意，你现在正在检查状态代码 <code>SQLITE_ROW</code>，这意味着你在逐步执行结果时检索了一行。</li>
<li>是时候从返回的行中读取值了。根据你对表的结构和查询的了解，你可以逐列访问行的值。第一列是 <code>Int</code>，因此你使用 <code>sqlite3_column_int()</code>并传入语句和从零开始的列索引。你将返回的值分配给本地范围的 <code>id</code> 常量。</li>
<li>接下来，从 <code>Name</code> 列中获取文本值。由于 C API，这有点乱。首先，将值捕获为 <code>queryResultCol1</code>，以便在下一行将其转换为正确的 Swift 字符串。</li>
<li>打印出结果。</li>
<li>执行 <code>finalize</code> 语句。</li>
</ol>
<p>现在，通过将以下内容添加到 <code>Playground</code> 的底部来调用你的新方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">query()</span><br></pre></td></tr></table></figure>

<p>运行你的 <code>Playground</code>，你将会在控制台看到如下的输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="type">Result</span>:</span><br><span class="line"><span class="number">1</span> | <span class="type">Ray</span></span><br></pre></td></tr></table></figure>

<p>W00t！看起来你的数据已经录入到数据库中！</p>
<h2 id="挑战：打印每一行"><a href="#挑战：打印每一行" class="headerlink" title="挑战：打印每一行"></a>挑战：打印每一行</h2><hr>
<p>你的任务是更新 <code>query()</code> 以打印出表中的每个联系人。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> queryStatement: <span class="type">OpaquePointer?</span> = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_prepare_v2(db, queryStatementString, -<span class="number">1</span>, &amp;queryStatement, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sqlite3_step(queryStatement) == <span class="type">SQLITE_ROW</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> id = sqlite3_column_int(queryStatement, <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">let</span> queryResultCol1 = sqlite3_column_text(queryStatement, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">let</span> name = <span class="type">String</span>(cString: queryResultCol1!)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Query Result:&quot;</span>)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;\(id) | \(name)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;SELECT statement could not be prepared&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  sqlite3_finalize(queryStatement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，不是像前面那样使用单个步骤来检索第一行，而是这次使用 <code>while</code> 循环来执行步骤，只要返回代码是 <code>SQLITE_ROW</code> 就会发生。当你到达最后一行时，返回代码将通过 <code>SQLITE_DONE</code>，循环将中断。</p>
<h2 id="更新联系人"><a href="#更新联系人" class="headerlink" title="更新联系人"></a>更新联系人</h2><hr>
<p>下一个自然的进展是更新现有行。你应该开始看到一种模式出现了。</p>
<p>首先，创建 <code>UPDATE</code> 语句：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> updateStatementString = <span class="string">&quot;UPDATE Contact SET Name = &#x27;Chris&#x27; WHERE Id = 1;&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这里使用真正的值来代替占位符 <code>？</code>。通常你会使用占位符并执行适当的语句绑定，但为了简洁起见，你可以在这里跳过它。</p>
<p>接下来，将以下方法添加到 <code>Playground</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> updateStatement: <span class="type">OpaquePointer?</span> = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_prepare_v2(db, updateStatementString, -<span class="number">1</span>, &amp;updateStatement, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> sqlite3_step(updateStatement) == <span class="type">SQLITE_DONE</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Successfully updated row.&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Could not update row.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;UPDATE statement could not be prepared&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  sqlite3_finalize(updateStatement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这与你之前看到的类似：<code>prepare</code>，<code>step</code>，<code>finalize</code>！并将以下内容添加到你的 <code>Playground</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">update()</span><br><span class="line">query()</span><br></pre></td></tr></table></figure>

<p>这将执行你的新方法，然后调用你先前定义的 <code>query()</code> 方法，以便你可以看到结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Successfully</span> updated row.</span><br><span class="line"><span class="type">Query</span> <span class="type">Result</span>:</span><br><span class="line"><span class="number">1</span> | <span class="type">Chris</span></span><br></pre></td></tr></table></figure>

<p>恭喜你成功更新一行数据！非常容易的对吧？：]</p>
<h2 id="删除联系人"><a href="#删除联系人" class="headerlink" title="删除联系人"></a>删除联系人</h2><hr>
<p>成为 <code>SQLite</code> 忍者的最后一步是删除你创建的行。再次，你将使用熟悉的 <code>prepare</code>，<code>step</code> 和 <code>finalize</code>。</p>
<p>将以下的内容添加到 <code>Playground</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> deleteStatementStirng = <span class="string">&quot;DELETE FROM Contact WHERE Id = 1;&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在添加以下方法来执行语句：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> deleteStatement: <span class="type">OpaquePointer?</span> = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_prepare_v2(db, deleteStatementStirng, -<span class="number">1</span>, &amp;deleteStatement, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> sqlite3_step(deleteStatement) == <span class="type">SQLITE_DONE</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Successfully deleted row.&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Could not delete row.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DELETE statement could not be prepared&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  sqlite3_finalize(deleteStatement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你现在感觉到了吗？<code>Prepare</code>，<code>step</code> 和 <code>finalize</code>！：]</p>
<p>执行这个新方法，然后调用 <code>query()</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">delete()</span><br><span class="line">query()</span><br></pre></td></tr></table></figure>

<p>现在运行你的 <code>Playground</code>，你应该在你的控制台中看到以下输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Successfully</span> deleted row.</span><br><span class="line"><span class="type">Query</span> returned no results</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果你完成了上面的“多个插入”挑战，由于表中仍存在其他数据，因此输出可能与上面的内容略有不同。</p>
</blockquote>
<h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><hr>
<p>到目前为止，希望你已经设法避免 SQLite 错误。但是，当你调用一个没有意义的函数，或者根本无法编译时，就将会出现错误。在发生这些事情时处理错误消息可以节省大量的开发时间;<br>它还使你有机会向用户显示有意义的错误消息。将以下声明 - 这个错误是故意的 - 添加到你的 Playground：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> malformedQueryString = <span class="string">&quot;SELECT Stuff from Things WHERE Whatever;&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在添加一个方法来执行这个格式错误的语句：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareMalformedQuery</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> malformedStatement: <span class="type">OpaquePointer?</span> = <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_prepare_v2(db, malformedQueryString, -<span class="number">1</span>, &amp;malformedStatement, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This should not have happened.&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> errorMessage = <span class="type">String</span>.<span class="keyword">init</span>(cString: sqlite3_errmsg(db))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Query could not be prepared! \(errorMessage)&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  sqlite3_finalize(malformedStatement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是你将如何强制执行错误：</p>
<ol>
<li><code>Prepare</code> 语句，这将会发生错误而且不应该返回 <code>SQLITE_OK</code>；</li>
<li>使用 <code>sqlite3_errmsg()</code> 从数据库中获取错误消息；此函数返回最近错误的文本描述。然后，你将错误打印到控制台;</li>
<li>一如既往，<code>finalize</code>。</li>
</ol>
<p>调用该方法以查看错误消息：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> prepareMalformedQuery()</span><br></pre></td></tr></table></figure>

<p>运行你的 <code>Playground</code>，你将会在控制台看到如下的输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Query</span> could not be prepared! no such table: <span class="type">Things</span></span><br></pre></td></tr></table></figure>

<p>嗯，这实际上很有帮助 - 你显然无法在不存在的表上运行 <code>SELECT</code> 语句！</p>
<h2 id="关闭数据库连接"><a href="#关闭数据库连接" class="headerlink" title="关闭数据库连接"></a>关闭数据库连接</h2><hr>
<p>完成数据库连接后，你将负责关闭它。但请注意 - 在成功关闭数据库之前，必须执行许多操作，如<a href="https://www.sqlite.org/c3ref/close.html">SQLite文档</a>中所述。</p>
<p>调用 <code>close</code> 函数，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> sqlite3_close(db)</span><br></pre></td></tr></table></figure>

<p>运行你的 Playground；你应该在 Playground 的右侧结果视图中看到状态代码 0；这表示 <code>SQLITE_OK</code>，这意味着数据库关闭成功。</p>
<p>你已经成功创建了一个数据库，添加了一个表，向表中添加了行，查询并更新了这些行，甚至删除了一行 - 所有这些都使用了 Swift 的 SQLite C API。做得好！</p>
<p>在下一节中，你将学习如何在 Swift 中使用 SQLite。</p>
<h2 id="SQLite-与-Swift"><a href="#SQLite-与-Swift" class="headerlink" title="SQLite 与 Swift"></a>SQLite 与 Swift</h2><hr>
<p>作为 Swift 开发人员，你可能会对本教程第一部分中发生的事情感到有些不安。那个 C API 有点痛苦，但好消息是你可以利用 Swift 的力量包装那些 C 例程来让事情变得更容易。</p>
<p><img src="/my_pictures/Swift%E4%B8%8B%E4%BD%BF%E7%94%A8SQLite%E6%95%99%E7%A8%8B%EF%BC%9A%E5%85%A5%E9%97%A8-4.png"></p>
<p>对于本教程的这部分内容，点击 Playground 底部的 <code>Making it Swift</code> 连接打开这部分的 Playground。</p>
<p><img src="/my_pictures/Swift%E4%B8%8B%E4%BD%BF%E7%94%A8SQLite%E6%95%99%E7%A8%8B%EF%BC%9A%E5%85%A5%E9%97%A8-5.png"></p>
<h2 id="包装错误"><a href="#包装错误" class="headerlink" title="包装错误"></a>包装错误</h2><hr>
<p>作为一个 Swift 开发者，从 C API 捕获错误有点尴尬。在这个美丽的新世界中，检查结果码然后调用另一个方法是没有意义的。如果方法能够抛出错误那将会更有意义。</p>
<p>将下面的代码添加到你的 Playground：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SQLiteError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">OpenDatabase</span>(message: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Prepare</span>(message: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Step</span>(message: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Bind</span>(message: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个自定义的错误枚举，涵盖了你正在使用的四个可能失败的主要操作。请注意，每个 <code>case</code> 都有一个关联值 <code>message</code>。</p>
<h2 id="包装数据库连接"><a href="#包装数据库连接" class="headerlink" title="包装数据库连接"></a>包装数据库连接</h2><hr>
<p>另外一个不那么 <code>Swifty</code> 的方面就是使用那些恶心的 <code>OpaquePointer</code> 类型。在自己的类中包装数据库的连接指针，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SQLiteDatabase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">let</span> dbPointer: <span class="type">OpaquePointer?</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">init</span>(dbPointer: <span class="type">OpaquePointer?</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.dbPointer = dbPointer</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">deinit</span> &#123;</span><br><span class="line">    sqlite3_close(dbPointer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样看起来好多了，当你需要一个数据库连接的时候，你能创建一个更有意义的 <code>SQLiteDatabase</code> 的引用，而不是 <code>OpaquePointer</code>。</p>
<p>你会注意到，初始化是 <code>fileprivate</code>；那是因为你不希望你的 Swift 开发者传入那个 <code>OpaquePointer</code>。相反，你让他们用数据库文件的路径实例化这个类。</p>
<p>将以下静态方法添加到 <code>SQLiteDatabase</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(path: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">SQLiteDatabase</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> db: <span class="type">OpaquePointer?</span> = <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">if</span> sqlite3_open(path, &amp;db) == <span class="type">SQLITE_OK</span> &#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">SQLiteDatabase</span>(dbPointer: db)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> db != <span class="literal">nil</span> &#123;</span><br><span class="line">        sqlite3_close(db)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> errorPointer = sqlite3_errmsg(db) &#123;</span><br><span class="line">      <span class="keyword">let</span> message = <span class="type">String</span>.<span class="keyword">init</span>(cString: errorPointer)</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">SQLiteError</span>.<span class="type">OpenDatabase</span>(message: message)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">SQLiteError</span>.<span class="type">OpenDatabase</span>(message: <span class="string">&quot;No error message provided from sqlite.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里发生了这些事情；</p>
<ol>
<li>尝试在提供的路径上打开数据库；</li>
<li>如果成功，则返回 <code>SQLiteDatabase</code> 的新实例；</li>
<li>否则，如果状态代码不是 <code>SQLITE_OK</code>，则推迟关闭数据库并抛出错误。</li>
</ol>
<p>现在，您可以使用更清晰的语法创建和打开数据库连接。</p>
<p>将下面的代码添加到你的 PLayground：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> db: <span class="type">SQLiteDatabase</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  db = <span class="keyword">try</span> <span class="type">SQLiteDatabase</span>.<span class="keyword">open</span>(path: part2DbPath)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Successfully opened connection to database.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">SQLiteError</span>.<span class="type">OpenDatabase</span>(<span class="keyword">let</span> message) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Unable to open database. Verify that you created the directory described in the Getting Started section.&quot;</span>)</span><br><span class="line">  <span class="type">PlaygroundPage</span>.current.finishExecution()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ah，我太喜欢 Swift 了。这里，尝试打开数据库的代码被包装在 <code>do-try-catch</code> 中，并且 SQLite 会将错误的信息传递给 <code>catch</code> 块儿，这要感谢你之前创建的自定义枚举。</p>
<p>运行你的 Playground 并查看控制台的输出；你将会看到如下的内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Successfully</span> opened connection to database.</span><br></pre></td></tr></table></figure>

<p>现在，您可以使用并检查数据库实例作为正确且有意义的类型。</p>
<p>在继续编写执行语句之前，如果 <code>SQLiteDatabase</code> 允许您轻松访问SQLite错误消息，那将是很好的。</p>
<p>将以下计算属性添加到 <code>SQLiteDatabase</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">var</span> errorMessage: <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> errorPointer = sqlite3_errmsg(dbPointer) &#123;</span><br><span class="line">    <span class="keyword">let</span> errorMessage = <span class="type">String</span>(cString: errorPointer)</span><br><span class="line">    <span class="keyword">return</span> errorMessage</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;No error message provided from sqlite.&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，您添加了一个计算属性，它只返回 SQLite 知道的最新错误。如果没有错误，它只会返回一条声明的通用消息。</p>
<h2 id="包装-Prepare-语句的调用"><a href="#包装-Prepare-语句的调用" class="headerlink" title="包装 Prepare 语句的调用"></a>包装 Prepare 语句的调用</h2><hr>
<p>既然你经常这样做，像其他方法一样包装它将会更有意义。在你进行开发并且向 <code>SQLiteDatabase</code> 中添加功能时，你会用到类的扩展。</p>
<p>添加如下的扩展，将来的方法将使用它来调用 SQL 语句上的 <code>sqlite3_prepare_v2()</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SQLiteDatabase</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">prepareStatement</span><span class="params">(sql: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">OpaquePointer?</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> statement: <span class="type">OpaquePointer?</span> = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">guard</span> sqlite3_prepare_v2(dbPointer, sql, -<span class="number">1</span>, &amp;statement, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">SQLiteError</span>.<span class="type">Prepare</span>(message: errorMessage)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> statement</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里你定义的 <code>prepareStatement(_:)</code> 函数能够抛出错误，然后当 <code>sqlite3_prepare_v2()</code> 出错时使用 <code>guard</code> 语句来抛出错误。就像之前一样，你将 SQLite中 的错误消息传递给自定义枚举的相关案例。</p>
<h2 id="创建-Contact-结构体"><a href="#创建-Contact-结构体" class="headerlink" title="创建 Contact 结构体"></a>创建 Contact 结构体</h2><hr>
<p>在这些例子中，你将使用与之前相同的 <code>Contact</code> 表，因此，定义一个适当的结构来表示联系人是有意义的。将以下内容添加到你的 Playground：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Contact</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> id: <span class="type">Int32</span></span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">NSString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="包装表的创建"><a href="#包装表的创建" class="headerlink" title="包装表的创建"></a>包装表的创建</h2><hr>
<p>您将完成与以前相同的数据库任务，但这次您将使用更 Swifter 的方法。</p>
<p>要创建一个表，你需要一个 <code>CREATE TABLE</code> 的 SQL 语句。<code>Contact</code> 定义自己的 <code>CREATE TABLE</code> 语句是有意义的。</p>
<p>为了这个目的，我们我们创建下面的协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SQLTable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> createStatement: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，扩展 <code>Contact</code>，然后遵守这个协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Contact</span>: <span class="title">SQLTable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> createStatement: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    CREATE TABLE Contact(</span></span><br><span class="line"><span class="string">      Id INT PRIMARY KEY NOT NULL,</span></span><br><span class="line"><span class="string">      Name CHAR(255)</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，你可以编写以下方法来接受一个符合 <code>SQLTable</code> 的类型来创建表：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SQLiteDatabase</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">createTable</span><span class="params">(table: SQLTable.<span class="keyword">Type</span>)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">let</span> createTableStatement = <span class="keyword">try</span> prepareStatement(sql: table.createStatement)</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">      sqlite3_finalize(createTableStatement)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">guard</span> sqlite3_step(createTableStatement) == <span class="type">SQLITE_DONE</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">SQLiteError</span>.<span class="type">Step</span>(message: errorMessage)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\(table) table created.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里来分析发生了什么：</p>
<ol>
<li><code>prepareStatement()</code> 会抛出错误，所以你必须使用 <code>try</code> 语句。你并没有在 <code>do-try-catch</code> 块儿中执行此操作，因为这个方法本身会抛出错误，所以任何来自 <code>prepareStatement()</code> 的错误都会简单的抛出给调用者 <code>createTable()</code>；</li>
<li>凭借 <code>defer</code> 的力量，无论此方法如何退出其执行范围，你都可以确保你的 <code>sqlite3_finalize</code> 语句始终最终执行；</li>
<li><code>guard</code> 能让你写的检查 SQL 状态代码更具可读性。</li>
</ol>
<p>通过将以下的代码添加到 Playground 来尝试尝试新的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> db.createTable(table: <span class="type">Contact</span>.<span class="keyword">self</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(db.errorMessage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，您只需尝试创建联系人，并捕获错误（如果有的话）。</p>
<p>运行你的 Playground；你将会在你的控制台看到如下的输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Contact</span> table created.</span><br></pre></td></tr></table></figure>

<p>太棒了！这不是一个更清洁的 API 吗？</p>
<h2 id="包装数据插入"><a href="#包装数据插入" class="headerlink" title="包装数据插入"></a>包装数据插入</h2><hr>
<p>沿着右边移动，是时候向你的 <code>Contact</code> 表中插入一条数据了。添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SQLiteDatabase</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">insertContact</span><span class="params">(contact: Contact)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> insertSql = <span class="string">&quot;INSERT INTO Contact (Id, Name) VALUES (?, ?);&quot;</span></span><br><span class="line">    <span class="keyword">let</span> insertStatement = <span class="keyword">try</span> prepareStatement(sql: insertSql)</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">      sqlite3_finalize(insertStatement)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">NSString</span> = contact.name</span><br><span class="line">    <span class="keyword">guard</span> sqlite3_bind_int(insertStatement, <span class="number">1</span>, contact.id) == <span class="type">SQLITE_OK</span>  &amp;&amp;</span><br><span class="line">      sqlite3_bind_text(insertStatement, <span class="number">2</span>, name.utf8String, -<span class="number">1</span>, <span class="literal">nil</span>) == <span class="type">SQLITE_OK</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">SQLiteError</span>.<span class="type">Bind</span>(message: errorMessage)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> sqlite3_step(insertStatement) == <span class="type">SQLITE_DONE</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">SQLiteError</span>.<span class="type">Step</span>(message: errorMessage)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Successfully inserted row.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然你已经得到了你的 SQLegs - 看看我在那里做了什么？:] - 这段代码不应该太令人惊讶。给定一个 <code>Contact</code> 实例，你准备一个语句，绑定值，执行然后 <code>finalize</code> 操作。同样，使用 <code>defer</code>，<code>guard</code> 和 <code>throw</code> 的强大组合可以让您充分利用现代语言 Swift 的功能。</p>
<p>编写代码来调用这个新方法，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> db.insertContact(contact: <span class="type">Contact</span>(id: <span class="number">1</span>, name: <span class="string">&quot;Ray&quot;</span>))</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(db.errorMessage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行你的 Playground；你将会在你的控制台看到如下的输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Successfully</span> inserted row.</span><br></pre></td></tr></table></figure>

<h2 id="包装读的操作"><a href="#包装读的操作" class="headerlink" title="包装读的操作"></a>包装读的操作</h2><hr>
<p>包装起来（抱歉，我无法抗拒！）的这部分是用 Swift 创建的数据库查询。</p>
<p>添加以下方法以查询联系人的数据库：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SQLiteDatabase</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">contact</span><span class="params">(id: Int32)</span></span> -&gt; <span class="type">Contact?</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> querySql = <span class="string">&quot;SELECT * FROM Contact WHERE Id = ?;&quot;</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> queryStatement = <span class="keyword">try</span>? prepareStatement(sql: querySql) <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">      sqlite3_finalize(queryStatement)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> sqlite3_bind_int(queryStatement, <span class="number">1</span>, id) == <span class="type">SQLITE_OK</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> sqlite3_step(queryStatement) == <span class="type">SQLITE_ROW</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> id = sqlite3_column_int(queryStatement, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> queryResultCol1 = sqlite3_column_text(queryStatement, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> name = <span class="type">String</span>(cString: queryResultCol1!) <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">Contact</span>(id: id, name: name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法只接受联系人的 <code>id</code> 并返回该联系人，如果没有该 <code>id</code> 的联系人，则返回 <code>nil</code>。同样，这些语句现在应该有些熟悉了。</p>
<p>写一个查询第一个联系人的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> first = db.contact(id: <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\(first?.id) \(first?.name)&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行你的 Playground；你应该能在控制台看到如下的输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Optional</span>(<span class="number">1</span>) <span class="type">Optional</span>(<span class="type">Ray</span>)</span><br></pre></td></tr></table></figure>

<p>到目前为止，您可能已经确定了一些可以用通用方式创建的调用，并将它们应用于完全不同的表。上述练习的目的是展示如何使用 Swift 来包装低级 C 的 API。对于 SQLite 来说，这不是一项简单的任务；SQLite 有很多错综复杂的内容，这里没有涉及。</p>
<p>你可能会想“没有人已经为此创建了一个包装器吗？” - 让我现在回答你的问题！</p>
<h2 id="SQLite-swift-的介绍"><a href="#SQLite-swift-的介绍" class="headerlink" title="SQLite.swift 的介绍"></a>SQLite.swift 的介绍</h2><hr>
<p>Stephen Celis 慷慨地为 SQLite 编写了一个名为 SQLite.swift 的全功能 Swift 包装器。如果您认为 SQLite 适合您应用中的数据存储，我强烈建议您查看一下。</p>
<p>SQLite.swift 提供了一种表示表的表达方式，让您可以开始使用 SQLite - 而无需担心 SQLite 的许多底层细节和特性。您甚至可以考虑包装SQLite.swift 本身，为您的应用程序的域模型创建一个高级 API。</p>
<p>查看编写良好的 <a href="https://github.com/stephencelis/SQLite.swift/blob/master/README.md">README.md for SQLite.swift</a>，并自行决定它是否在您的个人代码工具箱中占有一席之地。</p>
<p>原文地址：<a href="https://www.raywenderlich.com/167743/sqlite-swift-tutorial-getting-started">SQLite With Swift Tutorial: Getting Started</a></p>
]]></content>
      <categories>
        <category>文章翻译</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>翻译</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 页面卡死，但并不是 Crash 的问题解决</title>
    <url>/2018/09/27/2018-09-27-iOS%E9%A1%B5%E9%9D%A2%E5%8D%A1%E6%AD%BB%EF%BC%8C%E4%BD%86%E5%B9%B6%E4%B8%8D%E6%98%AFCrash%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>最近在做的一款 App 测试中出现了一个非常诡异的问题，偶尔的界面卡死，但是又并不是 Crash，没有抛出任何异常，把 App 切到后台然后在点开又恢复了，只不过转场的时候十分诡异，似乎完全没有动画，转场背景还是黑的。</p>
<p>什么原因呢？死循环？不可能；内存泄漏？也不可能？😂；手势冲突？很有可能🧐。无意中我发现了，在 UINavigationController 根视图上进行右滑返回上级页面时，页面就会卡死。原因找到了，一定是手势冲突。</p>
<h2 id="问题原因描述"><a href="#问题原因描述" class="headerlink" title="问题原因描述"></a>问题原因描述</h2><hr>
<p>在我的项目中有一个基类 <code>BaseViewController</code>，由于项目中有时候需要隐藏 <code>NavigationBar</code> 所以我使用了 <code>setNavigationBarHidden()</code> 方法，使用这个方法会导致右滑返回上级页面的操作失效。所以我在 <code>BaseViewController</code> 中加入了如下的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.navigationController?.interactivePopGestureRecognizer?.delegate = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BaseViewController</span>: <span class="title">UIGestureRecognizerDelegate</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我没有实现任何 <code>UIGestureRecognizerDelegate</code> 的方法，也就是用的都是默认情况。右滑时，具体的操作是将导航栏堆栈最顶部的 <code>Controller</code> 进行 <code>pop</code> 操作，但是当栈顶没有 <code>Controller</code> 时，也就是 <code>Controller</code> 为 <code>rootViewController</code> 时，这时候去开启右滑就会出问题了。导致页面完全卡死。</p>
<a id="more"></a>

<h2 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h2><hr>
<p>我们为我们的控制器基类 <code>BaseViewController</code> 添加一个 <code>public</code> 的属性，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> disableSideSliding = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>我们实现 <code>UIGestureRecognizerDelegate</code> 代理中的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BaseViewController</span>: <span class="title">UIGestureRecognizerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">gestureRecognizerShouldBegin</span><span class="params">(<span class="keyword">_</span> gestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !disableSideSliding</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们所有的根视图，也就是 <code>rootViewController</code> 的 <code>viewDidLoad()</code> 方法中将右滑操作禁止，即设置 <code>disableSideSliding</code> 属性值为 <code>true</code>。</p>
<p>Ok，问题解决。</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>iOS工作日志</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>observeOn vs. subscribeOn【译】</title>
    <url>/2018/09/29/2018-09-29-observeOnvssubscribeOn%E3%80%90%E8%AF%91%E3%80%91/</url>
    <content><![CDATA[<p>跨线程订阅的问题似乎在 <code>RxSwift Slack</code> 上一次又一次的被提到。这个解释起来也是非常的简单所以我觉得放在博客当中是一个好主意，无论你在何时需要，都可以通过连接进行访问，我也不用一次又一次的回复。</p>
<h2 id="可观察序列的订阅（Observable-subscriptions）"><a href="#可观察序列的订阅（Observable-subscriptions）" class="headerlink" title="可观察序列的订阅（Observable subscriptions）"></a>可观察序列的订阅（Observable subscriptions）</h2><hr>
<p><code>subscribing</code>（订阅） 和 <code>observing</code>（观察） 方面的术语还有一点混乱，所以让我们先来解决这个问题（不要跳过本章节！）。</p>
<p>让我们看看 <code>observable subscription</code> 的工作原理。我们可以将订阅分成 3 个部分：</p>
<p><img src="/my_pictures/observeOnvssubscribeOn-1.png"></p>
<a id="more"></a>

<ol>
<li>首先，你定义了一个 <code>Observable</code>，在某些情况下，你在闭包中提供一些代码来执行工作并向任何观察者（observers）发出元素。当你创建了一个可观察序列的时候，代码将会被保存以供将来使用，但是不会立即执行。如果没有观察者 - <code>Observable</code> 只是坐着等待并不做任何事情。</li>
<li>在为订阅建模时，你可以使用一些运算符（如 <code>map</code>，<code>filter</code> 等）来处理发出的元素。</li>
<li>只有当你在一个 <code>Observable</code> 上调用 <code>subscribe(...)</code> 方法时，你才能“打开它”。调用 <code>subscribe(...)</code> 实际上将执行你在第1部分（上面）的块中提供的代码。</li>
</ol>
<p>所以从这个意义上说，这里有两个要点：</p>
<ol>
<li><code>subscription code</code> 是从你的 <code>subscribe()</code> 中调用并且位于 <code>Observable.create &#123; ... &#125;</code> 中的代码。这是创建订阅并且生成元素的代码。</li>
<li><code>observation code</code> 是你观察元素的地方 - 这是你在 <code>onNext: &#123; ... &#125;</code>，<code>onCompleted: &#123;...&#125;</code> 等提供的代码。这是你进行观察的地方。</li>
</ol>
<p><img src="/my_pictures/observeOnvssubscribeOn-2.png"></p>
<h2 id="调度程序（Schedulers）"><a href="#调度程序（Schedulers）" class="headerlink" title="调度程序（Schedulers）"></a>调度程序（Schedulers）</h2><hr>
<p>RxSwift 附带了许多预定义的调度程序，可以在大多数情况下满足你的所有需求。这个主题有一个简短的文档：<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Schedulers.md">schedulers at RxSwift repo.</a></p>
<p>在这片文章中，我们将使用两个调度程序：</p>
<ul>
<li><code>MainScheduler.instance</code> 工作于主线程上。</li>
<li><code>ConcurrentDispatchQueueScheduler</code> 它使用 GCD 在给定队列上执行工作。</li>
</ul>
<h2 id="Subscribing-and-subscribeOn"><a href="#Subscribing-and-subscribeOn" class="headerlink" title="Subscribing and subscribeOn"></a>Subscribing and subscribeOn</h2><hr>
<p>接下来让我们来看一下 <code>subscribeOn</code> 操作 - 它允许你更改将在其上执行订阅代码（subscription code）的调度程序。</p>
<p><img src="/my_pictures/observeOnvssubscribeOn-3.png"></p>
<p>默认情况下，订阅代码将在与调用 <code>subscribe()</code> 的代码相同的线程上运行，除非你使用 <code>subscribeOn(...)</code> 更改上下文。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.create &#123; observer <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="number">1</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    observer.onNext(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br><span class="line">.subscribe(onNext: &#123; el <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="type">Thread</span>.isMainThread)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果将此代码放在 <code>viewDidLoad</code> 中，则会因为在订阅代码中使用了 <code>sleep</code> 而阻塞主线程。</p>
<p>你的 <code>onNext</code> 中的代码将会输出 <code>true</code>，因为它一直在主线程上运行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[main] subscribe() -&gt; [main] create&#123; ... &#125; -&gt; [main] onNext &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>现在你可以通过插入 <code>subscribeOn</code> 来更改你订阅的调度程序：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.create &#123; observer <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="number">1</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    observer.onNext(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br><span class="line">.subscribeOn(<span class="type">ConcurrentDispatchQueueScheduler</span>(qos: .background))</span><br><span class="line">.subscribe(onNext: &#123; el <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="type">Thread</span>.isMainThread)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这次你将在订阅时切换线程：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[main] subscribe() -&gt; [background] create&#123; ... &#125; -&gt; [background] onNext &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><code>onNext</code> 将会输出 <code>false</code>。</p>
<h2 id="Observing-and-observeOn"><a href="#Observing-and-observeOn" class="headerlink" title="Observing and observeOn"></a>Observing and observeOn</h2><hr>
<p>现在让我们来观察序列的元素。这部分涉及你的观察代码。</p>
<p><img src="/my_pictures/observeOnvssubscribeOn-4.png"></p>
<p>在我们之前的例子中，你将订阅切换到了后台，因为它执行了一些阻塞线程的操作。但你实际上想要的是在主线程上运行 <code>onNext &#123;..&#125;</code> 中的代码，以便更新应用程序的 UI。</p>
<p>这可以通过使用 <code>observeOn</code> 来实现。顺便说一句，你可以将 <code>observeOn</code> 和 <code>subscribeOn</code> 放在响应链的任何地方 - 顺序并不重要。</p>
<p>RxSwift 包含一个使用主线程 <code>MainScheduler.instance</code> 的共享调度程序，因此你可以使用它来轻松地观察元素：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.create &#123; observer <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="number">1</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    observer.onNext(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br><span class="line">.observeOn(<span class="type">MainScheduler</span>.instance)</span><br><span class="line">.subscribeOn(<span class="type">ConcurrentDispatchQueueScheduler</span>(qos: .background))</span><br><span class="line">.subscribe(onNext: &#123; el <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="type">Thread</span>.isMainThread)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这将执行如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[main] subscribe() -&gt; [background] create&#123; ... &#125; -&gt; [main] onNext &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>如果你做了很多异步工作，那么这是一种你经常会使用的模式，，所以早点习惯它 - 最好。</p>
<p>我希望这篇简短的文章能够清楚地说明命名和用法。</p>
<p>原文地址：<a href="http://rx-marin.com/post/observeon-vs-subscribeon/">observeOn vs. subscribeOn</a></p>
]]></content>
      <categories>
        <category>文章翻译</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>WKWebView 加载 TXT 文件编码问题</title>
    <url>/2018/10/11/2018-10-11-WKWebView%E5%8A%A0%E8%BD%BDTXT%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天在做在线预览功能的时候碰到了一个蛋疼的问题，office 格式都可以完美的适配，但是 txt 格式出现了乱码。没办法只能进行一个转码，然后再输出内容。</p>
<h2 id="提取-TXT-文件内容并转码-utf8"><a href="#提取-TXT-文件内容并转码-utf8" class="headerlink" title="提取 TXT 文件内容并转码 utf8"></a>提取 TXT 文件内容并转码 utf8</h2><hr>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> encoding: <span class="type">String</span>.<span class="type">Encoding</span> = .utf8</span><br><span class="line">	<span class="keyword">let</span> body = <span class="keyword">try</span> <span class="type">String</span>(contentsOf: url, usedEncoding: &amp;encoding)</span><br><span class="line">	<span class="keyword">return</span> body</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们的 body 就是我们获取的内容，默认的我们用了 <code>utf8</code> 编码格式，如果转码错误，说明文件的编码格式为其他格式。</p>
<a id="more"></a>

<h2 id="对应中文编码"><a href="#对应中文编码" class="headerlink" title="对应中文编码"></a>对应中文编码</h2><hr>
<p>由于在 Swift 中，我并没有找到有关 <code>GBK</code>，<code>GBK18030</code> 等的转码写法，所以，这里我们使用 <code>NSString</code> 来进行中文简体和繁体的转码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> body = <span class="keyword">try</span>? <span class="type">NSString</span>(contentsOf: url, encoding: <span class="type">SimplifiedChinese</span>.<span class="type">GBK</span>) &#123;</span><br><span class="line">	<span class="comment">/// GBK &amp; GB2312</span></span><br><span class="line">	<span class="keyword">return</span> body <span class="keyword">as</span> <span class="type">String</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> body = <span class="keyword">try</span>? <span class="type">NSString</span>(contentsOf: url, encoding: <span class="type">SimplifiedChinese</span>.<span class="type">GBK18030</span>) &#123;</span><br><span class="line">	<span class="comment">/// GBK18030</span></span><br><span class="line">	<span class="keyword">return</span> body <span class="keyword">as</span> <span class="type">String</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> body = <span class="keyword">try</span>? <span class="type">NSString</span>(contentsOf: url, encoding: <span class="type">TraditionalChinese</span>.<span class="type">Big5</span>) &#123;</span><br><span class="line">	<span class="comment">/// Big5</span></span><br><span class="line">	<span class="keyword">return</span> body <span class="keyword">as</span> <span class="type">String</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> body = <span class="keyword">try</span>? <span class="type">NSString</span>(contentsOf: url, encoding: <span class="type">TraditionalChinese</span>.<span class="type">Big5HKSCS</span>) &#123;</span><br><span class="line">	<span class="comment">/// Big5 HKSCS</span></span><br><span class="line">	<span class="keyword">return</span> body <span class="keyword">as</span> <span class="type">String</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相应编码的 <code>encoding</code> 如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 中文简体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimplifiedChinese</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">GBK</span>: <span class="type">UInt</span> = <span class="number">0x80000632</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">GBK18030</span>: <span class="type">UInt</span> = <span class="number">0x80000631</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 中文繁体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TraditionalChinese</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Big5</span>: <span class="type">UInt</span> = <span class="number">0x80000A03</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Big5HKSCS</span>: <span class="type">UInt</span> = <span class="number">0x80000A06</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="显示-HTML"><a href="#显示-HTML" class="headerlink" title="显示 HTML"></a>显示 HTML</h2><hr>
<p>在显示内容的时候我发现字体格外的小，所以这个需要进行一个对应。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&lt;html&gt;&lt;header&gt;&lt;meta name=&#x27;viewport&#x27; content=&#x27;width=device-width, initial-scale=1.0, maximum-scale=2.0, minimum-scale=1.0, user-scalable=no&#x27;&gt;&lt;/header&gt;&lt;body&gt;\(body)&lt;/body&gt;&lt;/html&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>重要的是 <code>viewport meta</code> 标签，这里可以进行一个缩放。</p>
<p><code>device-width</code>：设备宽度<br><code>initial-scale</code>：初始缩放<br><code>maximum-scale</code>：最大缩放<br><code>minimum-scale</code>：最小缩放<br><code>user-scalable</code>：是否允许使用者缩放</p>
<p>OK，显示完美。</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>iOS工作日志</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>一键安装最新内核并开启 BBR 脚本</title>
    <url>/2018/10/20/2018-10-20-%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E5%86%85%E6%A0%B8%E5%B9%B6%E5%BC%80%E5%90%AF%20BBR%20%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p><img src="/my_pictures/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E5%86%85%E6%A0%B8%E5%B9%B6%E5%BC%80%E5%90%AFBBR%E8%84%9A%E6%9C%AC.jpg"></p>
<p>最近，Google 开源了其 TCP BBR 拥塞控制算法，并提交到了 Linux 内核，从 4.9 开始，Linux 内核已经用上了该算法。根据以往的传统，Google 总是先在自家的生产环境上线运用后，才会将代码开源，此次也不例外。<br>根据实地测试，在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。<br>于是我根据目前三大发行版的最新内核，开发了一键安装最新内核并开启 TCP BBR 脚本。</p>
<a id="more"></a>

<h2 id="本脚本适用环境"><a href="#本脚本适用环境" class="headerlink" title="本脚本适用环境"></a>本脚本适用环境</h2><hr>
<p>系统支持：CentOS 6+，Debian 7+，Ubuntu 12+<br>虚拟技术：OpenVZ 以外的，比如 KVM、Xen、VMware 等<br>内存要求：≥128M<br>日期　　：2018 年 06 月 09 日</p>
<h2 id="关于本脚本"><a href="#关于本脚本" class="headerlink" title="关于本脚本"></a>关于本脚本</h2><hr>
<p>1、本脚本已在 <a href="https://teddysun.com/t/vultr">Vultr</a> 上的 VPS 全部测试通过。<br>2、当脚本检测到 VPS 的虚拟方式为 OpenVZ 时，会提示错误，并自动退出安装。<br>3、脚本运行完重启发现开不了机的，打开 VPS 后台控制面板的 VNC, 开机卡在 grub 引导, 手动选择内核即可。<br>4、由于是使用最新版系统内核，最好请勿在生产环境安装，以免产生不可预测之后果。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><hr>
<p>使用 root 用户登录，运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh</span><br></pre></td></tr></table></figure>

<p>安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。<br>重启完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>

<p>查看内核版本，显示为最新版就表示 OK 了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure>

<p>返回值一般为：</p>
<p><strong>net.ipv4.tcp_available_congestion_control = bbr cubic reno</strong></p>
<p>或者为：</p>
<p><strong>net.ipv4.tcp_available_congestion_control = reno cubic bbr</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure>

<p>返回值一般为：</p>
<p><strong>net.ipv4.tcp_congestion_control = bbr</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl net.core.default_qdisc</span><br></pre></td></tr></table></figure>

<p>返回值一般为：</p>
<p><strong>net.core.default_qdisc = fq</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>

<p>返回值有 <code>tcp_bbr</code> 模块即说明 <code>bbr</code> 已启动。注意：并不是所有的 VPS 都会有此返回值，若没有也属正常。</p>
<h2 id="CentOS-下最新版内核-headers-安装方法"><a href="#CentOS-下最新版内核-headers-安装方法" class="headerlink" title="CentOS 下最新版内核 headers 安装方法"></a>CentOS 下最新版内核 headers 安装方法</h2><hr>
<p>本来打算在脚本里直接安装 <code>kernel-ml-headers</code>，但会出现和原版内核 <code>headers</code> 冲突的问题。因此在这里添加一个脚本执行完后，手动安装最新版内核 <code>headers</code> 之教程。<br>执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum --enablerepo=elrepo-kernel -y install kernel-ml-headers</span><br></pre></td></tr></table></figure>

<p>根据 CentOS 版本的不同，此时一般会出现类似于以下的错误提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: kernel-ml-headers conflicts with kernel-headers-2.6.32-696.20.1.el6.x86_64</span><br><span class="line">Error: kernel-ml-headers conflicts with kernel-headers-3.10.0-693.17.1.el7.x86_64</span><br></pre></td></tr></table></figure>

<p>因此需要先卸载原版内核 <code>headers</code> ，然后再安装最新版内核 <code>headers</code>。执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove kernel-headers</span><br></pre></td></tr></table></figure>

<p>确认无误后，输入 <code>y</code>，回车开始卸载。注意，有时候这么操作还会卸载一些对内核 <code>headers</code> 依赖的安装包，比如 <code>gcc</code>、<code>gcc-c++</code> 之类的。不过不要紧，我们可以在安装完最新版内核 <code>headers</code> 后再重新安装回来即可。<br>卸载完成后，再次执行上面给出的安装命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum --enablerepo=elrepo-kernel -y install kernel-ml-headers</span><br></pre></td></tr></table></figure>

<p>成功安装后，再把那些之前对内核 <code>headers</code> 依赖的安装包，比如 <code>gcc</code>、<code>gcc-c++</code> 之类的再安装一次即可。</p>
<p>为什么要安装最新版内核 <code>headers</code> 呢？<br>这是因为 <code>shadowsocks-libev</code> 版有个 <code>tcp fast open</code> 功能，如果不安装的话，这个功能是无法开启的。</p>
<h2 id="内核升级方法"><a href="#内核升级方法" class="headerlink" title="内核升级方法"></a>内核升级方法</h2><hr>
<p>如果是 CentOS 系统，执行如下命令即可升级内核：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install kernel-ml kernel-ml-devel</span><br></pre></td></tr></table></figure>

<p>如果你还手动安装了新版内核 <code>headers</code> ，那么还需要以下命令来升级 <code>headers</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install kernel-ml-headers</span><br></pre></td></tr></table></figure>

<p>CentOS 6 的话，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/^default=.*/default=0/g&#x27;</span> /boot/grub/grub.conf</span><br></pre></td></tr></table></figure>

<p>CentOS 7 的话，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub2-set-default 0</span><br></pre></td></tr></table></figure>

<p>如果是 Debian/Ubuntu 系统，则需要手动下载最新版内核来安装升级。<br>去这里下载最新版的内核 deb 安装包。<br>如果系统是 64 位，则下载 amd64 的 <code>linux-image</code> 中含有 <code>generic</code> 这个 <code>deb</code> 包；<br>如果系统是 32 位，则下载 i386 的 <code>linux-image</code> 中含有 <code>generic</code> 这个 <code>deb</code> 包；<br>安装的命令如下（以最新版的 64 位 4.12.4 举例而已，请替换为下载好的 deb 包）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -i linux-image-4.12.4-041204-generic_4.12.4-041204.201707271932_amd64.deb</span><br></pre></td></tr></table></figure>

<p>安装完成后，再执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/sbin/update-grub</span><br></pre></td></tr></table></figure>

<p>最后，重启 VPS 即可。</p>
<h2 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h2><hr>
<p>如果你使用的是 Google Cloud Platform （GCP）更换内核，有时会遇到重启后，整个磁盘变为只读的情况。只需执行以下命令即可恢复：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -o remount rw /</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS Mojave：invalid active developer path【译】</title>
    <url>/2018/11/03/2018-11-03-macOS%20Mojave-%20invalid%20active%20developer%20path%E3%80%90%E8%AF%91%E3%80%91/</url>
    <content><![CDATA[<p>我升级到 macOS Sierra（以及后来的 Mojave），我试着在终端运行 <code>git</code> 命令，但是它一直显示如下的错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br></pre></td></tr></table></figure>

<p>我该如何解决？</p>
<a id="more"></a>

<h2 id="答"><a href="#答" class="headerlink" title="答"></a>答</h2><hr>
<p>打开终端并且运行如下的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>

<p>这将会下载并且安装 Xcode 开发工具并且解决这个问题。安装的时候需要同意许可协议。作为后续步骤，如果你有多个版本或者希望<a href="https://apple.stackexchange.com/a/310470/5472">命令行工具在没有 Xcode 的情况下运行</a>，则可能需要重置 Xcode 的路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcode-select --switch /Applications/Xcode.app</span><br><span class="line">xcode-select --switch /Library/Developer/CommandLineTools</span><br></pre></td></tr></table></figure>

<p>我在这个问题中找到了解决方案，<a href="https://stackoverflow.com/a/32894314/1325575%20">命令行工具无效</a>。</p>
<p>您可能会收到一条错误消息：“无法安装该软件，因为它当前无法从软件更新服务器获得”。在这种情况下，<code>xcode-select --reset</code> 的工作方式与 akozin 相同</p>
<h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><hr>
<p><a href="https://apple.stackexchange.com/questions/254380/macos-mojave-invalid-active-developer-path">macOS Mojave: invalid active developer path</a></p>
]]></content>
      <categories>
        <category>系统设置</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS 安装/配置 Jenkins 小记</title>
    <url>/2019/01/16/2019-01-16-macOS%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEJenkins%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>前阵子忙疯了，最近得空，来更新一下自己的博客 - 记一次 macOS 安装/配置 Jenkins 的过程，方便以后使用。</p>
<p>由于 macOS 新系统 Mojave 字体实在让人看着眼疼，昨天重新装回了 <code>macOS High Sierra</code>，并且机智的用 <code>ThinBackup</code> 备份了自己的项目配置，避免麻烦，配置上面的东西还是挺多的。</p>
<a id="more"></a>

<h3 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h3><p>去官网下载 JDK 安装就行，太简单，略。</p>
<h3 id="安装-Jenkins"><a href="#安装-Jenkins" class="headerlink" title="安装 Jenkins"></a>安装 Jenkins</h3><p>建议用 <code>Homebrew</code> 安装，方便配置环境，方便启动与关闭。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install jenkins</span><br></pre></td></tr></table></figure>

<p>安装完成之后会默认启动，直接打开浏览器进入 <code>http://localhost:8080</code>，这时会让你输入初始密码，密码已经在终端显示出来，直接粘过来就行。接下来选择插件，由于我的配置已经在恢复文件中，所以这一步什么都不需要装，直接下一步，创建管理员账号，随便填，保存进入 <code>Jenkins</code>。</p>
<h3 id="恢复配置"><a href="#恢复配置" class="headerlink" title="恢复配置"></a>恢复配置</h3><ol>
<li>安装 <code>ThinBackup</code> 插件。</li>
<li>设置 <code>Backup directory</code>。</li>
<li>将备份文件夹放入第二步设置的路径。</li>
<li>进入 <code>Restore</code> 页面，勾选 <code>Restore next build number file (if found in backup)</code> 和 <code>Restore plugins</code> 两个选项。</li>
<li>点击 <code>Restore</code>。开始恢复。</li>
<li>备份完成后，终端关闭 <code>Jenkins</code> 并运行如下命令启动 <code>Jenkins</code>。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> java -jar /usr/<span class="built_in">local</span>/Cellar/jenkins/2.159/libexec/jenkins.war --httpPort=8080</span><br></pre></td></tr></table></figure>

<p>2.159 为安装的 Jenkins 版本号，根据具体情况更改。</p>
<p>进行打包之前，请确认 Xcode 已经登录开发者账号并且相关证书齐全。</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="1、执行-xcodebuild-命令报错："><a href="#1、执行-xcodebuild-命令报错：" class="headerlink" title="1、执行 xcodebuild 命令报错："></a>1、执行 <code>xcodebuild</code> 命令报错：</h4><p>xcode-select: error: tool ‘xcodebuild’ requires Xcode, but active developer directory </p>
<p><code>/Library/Developer/CommandLineTools</code></p>
<p>is a command line tools instance</p>
<p>原因如下：</p>
<p>This problem happens when xcode-select developer directory was pointing to </p>
<p><code>/Library/Developer/CommandLineTools</code></p>
<p>when a full regular Xcode was required (happens when CommandLineTools are installed after Xcode)</p>
<p>这里我们需要手动指定 Xcode，运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcode-select -s /Applications/Xcode.app/Contents/Developer</span><br></pre></td></tr></table></figure>

<h4 id="2、-jenkins-文件夹下没有工作空间目录"><a href="#2、-jenkins-文件夹下没有工作空间目录" class="headerlink" title="2、.jenkins 文件夹下没有工作空间目录"></a>2、.jenkins 文件夹下没有工作空间目录</h4><p>在进行编译的时候，Jenkins 会首先去 git 上拉取最新的代码，并将代码保存到工作空间（workspace）文件夹中，但是项目安装并且恢复完毕后，并没有自动新建 <code>workspace</code> 文件夹，这里我们只需要手动的新建一个 <code>workspace</code> 文件夹即可。目录结构为 <code>~/.jenkins/workspace</code>。</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>环境设置</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义数据结构 Multiset</title>
    <url>/2019/01/21/2019-01-21-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Multiset/</url>
    <content><![CDATA[<p>实现一个名叫 <code>Multiset</code> 的集合数据结构，要具有如下的方法</p>
<ol>
<li><code>count(for:)</code> 返回相应数据的存储个数；</li>
<li><code>add(_:)</code> 添加数据；</li>
<li>删除数据<code>remove(_:)</code>。</li>
</ol>
<p>举例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> m = <span class="type">Multiset</span>()</span><br><span class="line">m.add(<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">m.add(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line">m.add(<span class="string">&quot;cat&quot;</span>)</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">count</span>(<span class="keyword">for</span>: <span class="string">&quot;cat&quot;</span>) -&gt; <span class="number">2</span></span><br><span class="line">m.remove(<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">m.<span class="built_in">count</span>(<span class="keyword">for</span>: <span class="string">&quot;cat&quot;</span>) -&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h3><p>我的第一感觉是像一个数组一样的数据结构，所以并没有考虑时间复杂度方面的问题，就直接往下继续了，实现细节如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Multiset</span>&lt;<span class="title">T</span>: <span class="title">Equatable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ary: [<span class="type">T</span>] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="keyword">_</span> element: T)</span></span> &#123;</span><br><span class="line">        ary.append(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(<span class="keyword">for</span> element: T)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> filterResult = ary.<span class="built_in">filter</span> &#123; $<span class="number">0</span> == element &#125;</span><br><span class="line">        <span class="keyword">return</span> filterResult.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="keyword">_</span> element: T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> idx = ary.firstIndex(of: element) &#123;</span><br><span class="line">            ary.remove(at: idx)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里时间复杂度确实有待优化的地方，下面我们换成字典的形式再来一次。</p>
<h3 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Multiset</span>&lt;<span class="title">T</span>: <span class="title">Hashable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dict: [<span class="type">T</span>: <span class="type">Int</span>] = [:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="keyword">_</span> element: T)</span></span> &#123;</span><br><span class="line">        dict[element, <span class="keyword">default</span>: <span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(<span class="keyword">for</span> element: T)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dict[element] ?? <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="keyword">_</span> element: T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">var</span> <span class="built_in">count</span> = dict[element] <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="built_in">count</span> -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            dict[element] = <span class="built_in">count</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dict.removeValue(forKey: element)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这回好多了。</p>
<p>路漫漫其修远兮，吾将上下而求索。</p>
<p>我写的可能有点简略，更详细的叙述请看这里：<a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Multiset">Multiset</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS Mojave 中的字体</title>
    <url>/2019/01/30/2019-01-30-macOS%20Mojave%20%E4%B8%AD%E7%9A%84%E5%AD%97%E4%BD%93/</url>
    <content><![CDATA[<p>我想在之前升级到 macOS Mojave 的同学都会经历过一条命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">defaults write -g CGFontRenderingFontSmoothingDisabled -bool NO</span><br></pre></td></tr></table></figure>

<p>执行如上命令会开启苹果之前的字体渲染方式 – <strong><a href="https://en.wikipedia.org/wiki/Subpixel_rendering">子像素抗锯齿</a>**。因为苹果在 Mojave 系统上启用了新的</strong>灰度抗锯齿<strong>模式，导致 Chrome 浏览器的字体实在无法直视，</strong>有幸今天 Chrome 浏览器更新到 72 版本后修复了这个问题**。</p>
<a id="more"></a>


<h3 id="灰度抗锯齿与子像素抗锯齿科普"><a href="#灰度抗锯齿与子像素抗锯齿科普" class="headerlink" title="灰度抗锯齿与子像素抗锯齿科普"></a>灰度抗锯齿与子像素抗锯齿科普</h3><h4 id="macOS-10-14-Mojave-The-Ars-Technica-review"><a href="#macOS-10-14-Mojave-The-Ars-Technica-review" class="headerlink" title="macOS 10.14 Mojave: The Ars Technica review"></a><a href="https://arstechnica.com/features/2018/09/macos-10-14-mojave-the-ars-technica-review/12/#h3">macOS 10.14 Mojave: The Ars Technica review</a></h4><p><img src="/my_pictures/mojave-1.png"></p>
<h4 id="Understanding-Sub-Pixel-LCD-Screen-Anti-Aliased-Font-Rendering"><a href="#Understanding-Sub-Pixel-LCD-Screen-Anti-Aliased-Font-Rendering" class="headerlink" title="Understanding Sub-Pixel (LCD Screen) Anti-Aliased Font Rendering"></a><a href="http://alienryderflex.com/sub_pixel/">Understanding Sub-Pixel (LCD Screen) Anti-Aliased Font Rendering</a></h4><p><img src="/my_pictures/mojave-2.png"></p>
<h4 id="Antialiasing-101"><a href="#Antialiasing-101" class="headerlink" title="Antialiasing 101"></a><a href="https://www.html5rocks.com/en/tutorials/internals/antialiasing-101/">Antialiasing 101</a></h4><p><img src="/my_pictures/mojave-3.png"></p>
<h4 id="MDN-web-docs-font-smooth"><a href="#MDN-web-docs-font-smooth" class="headerlink" title="MDN web docs : font-smooth"></a><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth">MDN web docs : font-smooth</a></h4><blockquote>
<p><code>subpixel-antialiased</code> - On most <strong>non-retina</strong> displays, this will give the <strong>sharpest</strong> text.</p>
<p><code>grayscale</code> - Render text with grayscale antialiasing, <strong>as opposed to the</strong> subpixel.</p>
</blockquote>
<h4 id="Emacs-里面不同级别的-次像素抗锯齿-渲染效果动图：LCD-Font-Smoothing-17"><a href="#Emacs-里面不同级别的-次像素抗锯齿-渲染效果动图：LCD-Font-Smoothing-17" class="headerlink" title="Emacs 里面不同级别的 次像素抗锯齿 渲染效果动图：LCD Font Smoothing #17"></a>Emacs 里面不同级别的 <strong>次像素抗锯齿</strong> 渲染效果动图：<a href="https://github.com/kevinSuttle/macOS-Defaults/issues/17#issuecomment-266633501">LCD Font Smoothing #17</a></h4><p><img src="/my_pictures/mojave-4.gif"></p>
<p>参考：</p>
<p><a href="https://lvii.github.io/system/2018-09-26-setting-macos-mojave-font-rendering-from-grayscale-to-subpixel-antialiasing/">macOS Mojave 字体渲染由默认的灰度抗锯齿改回之前的次像素抗锯齿</a></p>
]]></content>
      <categories>
        <category>科普</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习一之基础</title>
    <url>/2019/02/07/2019-02-07-Python%20%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B9%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><code>ord()</code> 函数获取字符的 ASCII 码值</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">print(<span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>))</span><br><span class="line"></span><br><span class="line">output: <span class="number">97</span></span><br><span class="line">output: <span class="number">65</span></span><br></pre></td></tr></table></figure>

<p><code>chr()</code> 函数把 ASCII 转换为对应的字符</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">chr</span>(<span class="number">66</span>))</span><br><span class="line">print(<span class="built_in">chr</span>(<span class="number">97</span>))</span><br><span class="line"></span><br><span class="line">output: B</span><br><span class="line">output: a</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>由于 Python 的字符串类型是 <code>str</code>，在内存中以 Unicode 表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把 <code>str</code> 变为以字节为单位的 <code>bytes</code>。<code>Python</code> 对 <code>bytes</code> 类型的数据用带b前缀的单引号或双引号表示：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">type</span>(<span class="string">b&quot;a&quot;</span>))</span><br><span class="line">print(<span class="built_in">type</span>(<span class="string">&quot;a&quot;</span>))</span><br><span class="line"></span><br><span class="line">output: &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">bytes</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">output</span>:</span> &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>简写的方式是用 <code>ASCII</code> 编码为 <code>bytes</code> 所以不能用于中文，如果是中文需要 <code>UTF-8</code> 编码</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">type</span>(<span class="string">b&quot;中文&quot;</span>))</span><br><span class="line"></span><br><span class="line">output:  </span><br><span class="line">File <span class="string">&quot;基础.py&quot;</span>, line <span class="number">19</span></span><br><span class="line">    print(<span class="built_in">type</span>(<span class="string">b&quot;中文&quot;</span>))</span><br><span class="line">              ^</span><br><span class="line">SyntaxError: <span class="built_in">bytes</span> can only contain ASCII literal characters.</span><br></pre></td></tr></table></figure>

<p>以 <code>Unicode</code> 表示的 <code>str</code> 通过 <code>encode()</code> 方法可以编码为指定的 <code>bytes</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">type</span>(<span class="string">&quot;中文&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"></span><br><span class="line">output: &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">bytes</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>要计算 <code>str</code> 包含多少个字符，可以用 <code>len()</code> 函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">len</span>(<span class="string">&quot;abc中文&quot;</span>))</span><br><span class="line"></span><br><span class="line">output: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><code>len()</code> 函数计算的是 <code>str</code> 的字符数，如果换成 <code>bytes</code>，<code>len()</code> 函数就计算字节数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">len</span>(<span class="string">&quot;abc中文&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"></span><br><span class="line">output: <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><code>%</code> 运算符就是用来格式化字符串的</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;hello %s, I&#x27;m %s, %d years old.&quot;</span> % (<span class="string">&quot;world&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">output: hello world, I<span class="string">&#x27;m Tom, 20 years old.</span></span><br></pre></td></tr></table></figure>

<h3 id="list-类型"><a href="#list-类型" class="headerlink" title="list 类型"></a>list 类型</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>获取最后一个和倒数第二个元素</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ary[-<span class="number">1</span>]</span><br><span class="line">ary[-<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>添加元素</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ary.append(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>删除最后一个元素</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ary.pop()</span><br></pre></td></tr></table></figure>

<p>删除指定元素</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ary.pop(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>初始化字符数组</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">strAry = <span class="built_in">list</span>(<span class="string">&quot;ary&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(t[<span class="number">0</span>])</span><br><span class="line">print(t[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>只有 1 个元素的 <code>tuple</code> 定义时必须加一个逗号 <code>,</code> ，来消除歧义。<br>因为，括号 <code>()</code> 既可以表示 <code>tuple</code>，又可以表示数学公式中的小括号，这就产生了歧义。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>,)</span><br><span class="line">print(t1[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">output: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">age = <span class="number">13</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">	print(<span class="string">&quot;adult&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt; <span class="number">6</span>:</span><br><span class="line">	print(<span class="string">&quot;teenager&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">&quot;kid&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>input()</code> 返回的数据类型是 <code>str</code>，所以这里需要转换为 <code>int</code> 类型。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">birth = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;birth: &quot;</span>))</span><br><span class="line"><span class="keyword">if</span> birth &lt; <span class="number">2000</span>:</span><br><span class="line">	print(<span class="string">&#x27;00前&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">&#x27;00后&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">20</span>, <span class="number">2</span>)):</span><br><span class="line">	print(num)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">	print(num)</span><br></pre></td></tr></table></figure>

<h3 id="字典类型，dict"><a href="#字典类型，dict" class="headerlink" title="字典类型，dict"></a>字典类型，dict</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Bob&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125; <span class="comment"># 大括号声明</span></span><br><span class="line">print(d[<span class="string">&#x27;Bob&#x27;</span>])</span><br><span class="line">print(<span class="string">&quot;Bob&quot;</span> <span class="keyword">in</span> d) <span class="comment"># 判断 Bob是否在 d 中</span></span><br><span class="line">d.pop(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment"># 用数组初始化</span></span><br><span class="line">print(s)</span><br><span class="line">print(<span class="built_in">type</span>(s))</span><br><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment"># 大括号声明为 set</span></span><br><span class="line">print(<span class="built_in">type</span>(s1))</span><br><span class="line">s1.add(<span class="number">4</span>)</span><br><span class="line">print(s1)</span><br><span class="line">s1.remove(<span class="number">4</span>)</span><br><span class="line">print(s1)</span><br><span class="line"></span><br><span class="line">s1.add(<span class="number">8</span>)</span><br><span class="line">s1.add(<span class="number">9</span>)</span><br><span class="line">print(s1 &amp; s) <span class="comment"># 交集</span></span><br><span class="line">print(s1 | s) <span class="comment"># 并集</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习二之函数</title>
    <url>/2019/02/08/2019-02-08-Python%20%E5%AD%A6%E4%B9%A0%E4%BA%8C%E4%B9%8B%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">abs</span></span><br><span class="line">print(a(-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">output: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>pass</code> 定义空函数，目的是为了让程序能够跑起来。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>():</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span>(<span class="params">x</span>):</span></span><br><span class="line">	<span class="comment"># 检查传入的参数是否正确，只允许 int 和 float 类型的参数</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, (<span class="built_in">int</span>, <span class="built_in">float</span>)):</span><br><span class="line">		<span class="keyword">raise</span> TypeError(<span class="string">&#x27;bad operand type&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">x, y, step, angle=<span class="number">0</span></span>):</span></span><br><span class="line">	nx = x + step * math.cos(angle)</span><br><span class="line">	ny = y - step * math.sin(angle)</span><br><span class="line">	<span class="keyword">return</span> nx, ny</span><br></pre></td></tr></table></figure>

<p>返回值是一个 <code>tuple</code>。<br>返回一个 <code>tuple</code> 可以省略括号，而多个变量可以同时接收一个 <code>tuple</code>，按位置赋给对应的值。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x, y = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;x:&quot;</span>, x)</span><br><span class="line">print(<span class="string">&quot;y:&quot;</span>, y)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;x: &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(x))</span><br><span class="line">print(<span class="string">&quot;y: &#123;yValue&#125;&quot;</span>.<span class="built_in">format</span>(yValue=y))</span><br><span class="line"></span><br><span class="line">coor = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</span><br><span class="line">print(coor)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">x: <span class="number">151.96152422706632</span></span><br><span class="line">y: <span class="number">70.0</span></span><br><span class="line">x: <span class="number">151.96152422706632</span></span><br><span class="line">y: <span class="number">70.0</span></span><br><span class="line">(<span class="number">151.96152422706632</span>, <span class="number">70.0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="comment">#	if not isinstance(x, (int, float)):</span></span><br><span class="line"><span class="comment">#		raise TypeError(&#x27;bad operand type&#x27;)</span></span><br><span class="line">	<span class="keyword">return</span> x * x</span><br><span class="line">	</span><br><span class="line">print(power(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power1</span>(<span class="params">x, n</span>):</span></span><br><span class="line">	s = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">		n -= <span class="number">1</span></span><br><span class="line">		s = s * x</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">print(power1(<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>设置默认参数时，有几点要注意</p>
<ol>
<li>是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）</li>
<li>是如何设置默认参数</li>
</ol>
<p>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p>
<p>使用默认参数有什么好处？最大的好处是能降低调用函数的难度。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power2</span>(<span class="params">x, n=<span class="number">2</span></span>):</span></span><br><span class="line">	s = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">		n -= <span class="number">1</span></span><br><span class="line">		s = s * x</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">print(power2(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h4 id="为什么默认参数不能放在必选参数的前面"><a href="#为什么默认参数不能放在必选参数的前面" class="headerlink" title="为什么默认参数不能放在必选参数的前面"></a>为什么默认参数不能放在必选参数的前面</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">p1, p2=<span class="number">6</span>, p3</span>):</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>因为调用函数时可能会产生歧义，比如调用上面的函数 <code>foo(1, 2)</code>，是该调用 <code>foo(1, 6, 2)</code> 呢？还是该调用 <code>foo(1, 6)</code> 呢？或者其它的什么呢？…</p>
<h4 id="默认参数的坑"><a href="#默认参数的坑" class="headerlink" title="默认参数的坑"></a>默认参数的坑</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span>(<span class="params">L=[]</span>):</span></span><br><span class="line">	L.append(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line">	<span class="keyword">return</span> L</span><br><span class="line">print(add_end())</span><br><span class="line">print(add_end())</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>原因解释如下：</p>
<p>Python 函数在定义的时候，默认参数L的值就被计算出来了，即 <code>[]</code>，因为默认参数L也是一个变量，它指向对象 <code>[]</code>，每次调用该函数，如果改变了 <code>L</code> 的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的 <code>[]</code> 了。</p>
<p><strong>所以，定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></p>
<p>要修改上面的例子，我们可以用 <code>None</code> 这个不变对象来实现：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end1</span>(<span class="params">L=<span class="literal">None</span></span>):</span></span><br><span class="line">	<span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">		L = []</span><br><span class="line">	L.append(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line">	<span class="keyword">return</span> L</span><br><span class="line">print(add_end1())</span><br><span class="line">print(add_end1())</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>定义可变参数和定义一个 <code>list</code> 或 <code>tuple</code> 参数相比，仅仅在参数前面加了一个 <code>*</code> 号。<br>在函数内部，参数 <code>numbers</code> 接收到的是一个 <code>tuple</code> ，因此，函数代码完全不变。<br>但是，调用该函数时，可以传入任意个参数，包括 0 个参数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">*numbers</span>):</span></span><br><span class="line">	<span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">		<span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line">print(calc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>Python 允许你在 <code>list</code> 或 <code>tuple</code> 前面加一个 <code>*</code> 号，把 <code>list</code> 或 <code>tuple</code> 的元素变成可变参数传进去。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">demo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">print(calc(*demo))</span><br></pre></td></tr></table></figure>

<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数允许你传入 0 个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个 <code>dict</code>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, age, **kw</span>):</span></span><br><span class="line">	print(<span class="string">&#x27;name:&#x27;</span>, name, <span class="string">&#x27;age:&#x27;</span>, age, <span class="string">&#x27;other:&#x27;</span>, kw)</span><br><span class="line">	</span><br><span class="line">person(<span class="string">&quot;Michael&quot;</span>, <span class="number">11</span>)</span><br><span class="line">person(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">35</span>, city=<span class="string">&#x27;Beijing&#x27;</span>)</span><br><span class="line">extra = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>**extra</code> 表示把 <code>extra</code> 这个 <code>dict</code> 的所有 <code>key-value</code> 用关键字参数传入到函数的 <code>**kw</code> 参数， <code>kw</code> 将获得一个 <code>dict</code>，注意 <code>kw</code> 获得的 <code>dict</code> 是 <code>extra</code> 的一份拷贝，对 <code>kw</code> 的改动不会影响到函数外的 <code>extra</code>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, **extra)</span><br></pre></td></tr></table></figure>

<h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收 <code>city</code> 和 <code>job</code> 作为关键字参数。这种方式定义的函数如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, age, *, city, job</span>):</span></span><br><span class="line">	print(name, age, city, job)</span><br><span class="line">person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, city=<span class="string">&#x27;Beijing&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符 <code>*</code> 了。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person1</span>(<span class="params">name, age, *args, city, job</span>):</span></span><br><span class="line">	print(name, age, args, city, job)</span><br><span class="line">person1(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, city=<span class="string">&#x27;Beijing&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span><br><span class="line">person1(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, <span class="string">&quot;a&quot;</span>, city=<span class="string">&#x27;Beijing&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>命名关键字参数可以有缺省值，从而简化调用：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person2</span>(<span class="params">name, age, *, city=<span class="string">&#x27;Beijing&#x27;</span>, job</span>):</span></span><br><span class="line">	print(name, age, city, job)</span><br><span class="line">person2(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个 <code>*</code> 作为特殊分隔符。如果缺少 <code>*</code>，Python 解释器将无法识别位置参数和命名关键字参数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, age, city, job</span>):</span></span><br><span class="line">	<span class="comment"># 缺少 *，city和job被视为位置参数</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h3><p>在 Python 中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。<br>但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">a, b, c=<span class="number">0</span>, *args, **kw</span>):</span></span><br><span class="line">	print(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;b =&#x27;</span>, b, <span class="string">&#x27;c =&#x27;</span>, c, <span class="string">&#x27;args =&#x27;</span>, args, <span class="string">&#x27;kw =&#x27;</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">a, b, c=<span class="number">0</span>, *, d, **kw</span>):</span></span><br><span class="line">	print(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;b =&#x27;</span>, b, <span class="string">&#x27;c =&#x27;</span>, c, <span class="string">&#x27;d =&#x27;</span>, d, <span class="string">&#x27;kw =&#x27;</span>, kw)</span><br><span class="line"></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, x=<span class="number">99</span>)</span><br><span class="line">f2(<span class="number">1</span>, <span class="number">2</span>, d=<span class="number">99</span>, ext=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">kw = &#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">99</span>, <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;</span><br><span class="line">f1(*args, **kw)</span><br><span class="line"></span><br><span class="line">args1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">kw1 = &#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">88</span>, <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;</span><br><span class="line">f2(*args1, **kw1)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> args = () kw = &#123;&#125;</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = () kw = &#123;&#125;</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) kw = &#123;&#125;</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) kw = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">99</span>&#125;</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> d = <span class="number">99</span> kw = &#123;<span class="string">&#x27;ext&#x27;</span>: <span class="literal">None</span>&#125;</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="number">4</span>,) kw = &#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">99</span>, <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> d = <span class="number">88</span> kw = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span>(<span class="params">n</span>):</span></span><br><span class="line">	<span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br><span class="line">print(fact(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>使用递归函数需要注意防止栈溢出</p>
<p>在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</p>
<p>解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p>
<p>尾递归是指，在函数返回的时候，调用自身本身，并且，<code>return</code> 语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>
<p>上面的 <code>fact(n)</code> 函数由于 <code>return n * fact(n - 1)</code> 引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact1</span>(<span class="params">n</span>):</span></span><br><span class="line">	<span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact_iter</span>(<span class="params">num, product</span>):</span></span><br><span class="line">	<span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> product</span><br><span class="line">	<span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</span><br><span class="line">print(fact1(<span class="number">6</span>))</span><br></pre></td></tr></table></figure>

<p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p>
<p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python 解释器也没有做优化，所以，即使把上面的 <code>fact(n)</code> 函数改成尾递归方式，也会导致栈溢出。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Carthage 新手教程</title>
    <url>/2019/03/09/2019-03-09-Carthage%20%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Carthage-与-Cocoapods-的不同"><a href="#Carthage-与-Cocoapods-的不同" class="headerlink" title="Carthage 与 Cocoapods 的不同"></a>Carthage 与 Cocoapods 的不同</h2><p>Cocoapods 是由来已久的 Cocoa 依赖管理工具，那么为什么 Carthage 项目被创建？</p>
<p>首先，Cocoapods（默认情况下）会自动的为你的应用程序和所有依赖创建和更新 <code>Xcode workspace</code>。Carthage 用 <code>xcodebuild</code> 构建框架（framework）的二进制文件，但是并没有将他们整合到用户项目中。Cocoapods 的目的是让用户使用起来更简单，而 Carthage 则是更灵活，减少对项目的侵入性。</p>
<p>Cocoapods 的目标在其<a href="https://github.com/CocoaPods/CocoaPods/blob/1703a3464674baecf54bd7e766f4b37ed8fc43f7/README.md">README</a>文件中有如下描述：</p>
<blockquote>
<p>… to improve discoverability of, and engagement in, third party open-source libraries, by creating a more centralized ecosystem.</p>
</blockquote>
<p>对比之下，Carthage 被创建成一个松散（decentralized）的依赖管理者，没有中心项目清单，这减少了维护工作并避免了任何中心故障点（通俗的讲就是去中心化）。然而，项目被发现就变的更加困难 – 用户必须去使用 GitHub 的 <a href="https://github.com/trending?l=swift">Trending</a> 页面或者其他类似的页面（Cocoapods 就比较简单的可以在终端搜索需要使用的库）。</p>
<p>Cocoapods 项目还必须具有所谓的 <code>podspec</code> 文件，其中包括有关项目的元数据，并指定应如何构建它。Carthage 使用 <code>xcodebuild</code> 去构建依赖，而不是将它们集成到单个工作区中，它没有类似的规范文件，但你的依赖项必须包含到自己的 Xcode 项目中，该项目描述了如何构建其产品。</p>
<p>最终，我们创建了 Carthage，因为我们想要一个最简单的工具 – 一个可以完成工作而不必承担 Xcode 责任的依赖管理器，并且并没有为框架作者创造额外的工作。Cocoapods 提供了许多惊人的功能，但是在 Carthage 中，这些功能永远不会出现，因为这会增加额外的复杂性。</p>
<a id="more"></a>

<h2 id="Carthage-安装"><a href="#Carthage-安装" class="headerlink" title="Carthage 安装"></a>Carthage 安装</h2><h3 id="使用-homebrew-安装"><a href="#使用-homebrew-安装" class="headerlink" title="使用 homebrew 安装"></a>使用 homebrew 安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install carthage</span><br></pre></td></tr></table></figure>

<h3 id="查看版本和升级"><a href="#查看版本和升级" class="headerlink" title="查看版本和升级"></a>查看版本和升级</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看版本：</span><br><span class="line">carthage version</span><br><span class="line">&#x2F;&#x2F; 升级：</span><br><span class="line">brew upgrade carthage</span><br></pre></td></tr></table></figure>

<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew uninstall carthage</span><br></pre></td></tr></table></figure>

<h2 id="Carthage-配置第三方库（iOS，tvOS，watchOS）"><a href="#Carthage-配置第三方库（iOS，tvOS，watchOS）" class="headerlink" title="Carthage 配置第三方库（iOS，tvOS，watchOS）"></a>Carthage 配置第三方库（iOS，tvOS，watchOS）</h2><h3 id="创建-Cartfile-文件"><a href="#创建-Cartfile-文件" class="headerlink" title="创建 Cartfile 文件"></a>创建 Cartfile 文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd to your project</span><br><span class="line">touch Cartfile</span><br></pre></td></tr></table></figure>

<h3 id="用-Xcode-打开-编辑-Cartfile"><a href="#用-Xcode-打开-编辑-Cartfile" class="headerlink" title="用 Xcode 打开/编辑 Cartfile"></a>用 Xcode 打开/编辑 Cartfile</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open -a Xcode Cartfile</span><br></pre></td></tr></table></figure>

<h3 id="添加依赖库"><a href="#添加依赖库" class="headerlink" title="添加依赖库"></a>添加依赖库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github &quot;Alamofire&#x2F;Alamofire&quot; &#x3D;&#x3D; 4.5</span><br><span class="line">github &quot;Alamofire&#x2F;AlamofireImage&quot; ~&gt; 3.2</span><br></pre></td></tr></table></figure>

<p>现在支持的三个来源是 GitHub 存储库，Git 存储库和通过 https 提供的仅二进制框架。未来可能会添加其他可能的来源。如果你想看到具体的东西，请提 <a href="https://github.com/Carthage/Carthage/issues/new">issue</a>。</p>
<h4 id="GitHub-Repositories"><a href="#GitHub-Repositories" class="headerlink" title="GitHub Repositories"></a>GitHub Repositories</h4><p>使用 <code>github</code> 关键字指定 GitHub 存储库（<code>GitHub.com</code> 和 <code>GitHub Enterprise</code>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github &quot;ReactiveCocoa&#x2F;ReactiveCocoa&quot; # GitHub.com</span><br><span class="line">github &quot;https:&#x2F;&#x2F;enterprise.local&#x2F;ghe&#x2F;desktop&#x2F;git-error-translations&quot; # GitHub Enterprise</span><br></pre></td></tr></table></figure>

<p><code>github</code> 源是用于 <code>owner/repo</code> 表单指定或通过其 <code>web API</code> 使用预构建的二进制下载功能，因此对 <code>github</code> 源 使用 <code>git</code> 或 <code>ssh</code> 协议是没有意义的，并且这是一个错误。</p>
<h4 id="Git-repositories"><a href="#Git-repositories" class="headerlink" title="Git repositories"></a>Git repositories</h4><p>其他 Git 存储库使用 <code>git</code> 关键字指定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git &quot;https:&#x2F;&#x2F;enterprise.local&#x2F;desktop&#x2F;git-error-translations2.git&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Binary-only-frameworks"><a href="#Binary-only-frameworks" class="headerlink" title="Binary only frameworks"></a>Binary only frameworks</h4><p>仅作为已编译的二进制文件 <code>.frameworks</code> 提供的依赖项使用 <code>binary</code> 关键字和 <code>https：//</code> 链接，<code>file：//</code> 链接，或没有方案的相对或绝对路径，返回<a href="https://github.com/Carthage/Carthage/blob/master/Documentation/Artifacts.md#binary-project-specification">二进制项目规范</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binary &quot;https:&#x2F;&#x2F;my.domain.com&#x2F;release&#x2F;MyFramework.json&quot;   &#x2F;&#x2F; Remote Hosted</span><br><span class="line">binary &quot;file:&#x2F;&#x2F;&#x2F;some&#x2F;Path&#x2F;MyFramework.json&quot;               &#x2F;&#x2F; Locally hosted at file path</span><br><span class="line">binary &quot;relative&#x2F;path&#x2F;MyFramework.json&quot;                   &#x2F;&#x2F; Locally hosted at relative path to CWD</span><br><span class="line">binary &quot;&#x2F;absolute&#x2F;path&#x2F;MyFramework.json&quot;                  &#x2F;&#x2F; Locally hosted at absolute path</span><br></pre></td></tr></table></figure>

<h3 id="版本要求"><a href="#版本要求" class="headerlink" title="版本要求"></a>版本要求</h3><p>Carthage 支持多种版本要求：</p>
<ol>
<li><code>&gt;= 1.0</code> 指“1.0 及以上版本”。</li>
<li><code>~&gt; 1.0</code> 指“1.x 版本”</li>
<li><code>== 1.0</code> 指“版本为 1.0”</li>
<li><code>&quot;some-branch-or-tag-or-commit&quot;</code> 特指 <code>git</code> 对象（<code>git rev-parse</code> 任何内容都被允许）。<ul>
<li>Note：<code>二进制源</code> 不支持这种形式。 </li>
</ul>
</li>
</ol>
<p>如果没有指定任何版本，任何版本的依赖都将被允许（默认使用最新版本）。</p>
<h3 id="Example-Cartfile"><a href="#Example-Cartfile" class="headerlink" title="Example Cartfile"></a>Example Cartfile</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Require version 2.3.1 or later</span><br><span class="line">github &quot;ReactiveCocoa&#x2F;ReactiveCocoa&quot; &gt;&#x3D; 2.3.1</span><br><span class="line"></span><br><span class="line"># Require version 1.x</span><br><span class="line">github &quot;Mantle&#x2F;Mantle&quot; ~&gt; 1.0    # (1.0 or later, but less than 2.0)</span><br><span class="line"></span><br><span class="line"># Require exactly version 0.4.1</span><br><span class="line">github &quot;jspahrsummers&#x2F;libextobjc&quot; &#x3D;&#x3D; 0.4.1</span><br><span class="line"></span><br><span class="line"># Use the latest version</span><br><span class="line">github &quot;jspahrsummers&#x2F;xcconfigs&quot;</span><br><span class="line"></span><br><span class="line"># Use the branch</span><br><span class="line">github &quot;jspahrsummers&#x2F;xcconfigs&quot; &quot;branch&quot;</span><br><span class="line"></span><br><span class="line"># Use a project from GitHub Enterprise</span><br><span class="line">github &quot;https:&#x2F;&#x2F;enterprise.local&#x2F;ghe&#x2F;desktop&#x2F;git-error-translations&quot;</span><br><span class="line"></span><br><span class="line"># Use a project from any arbitrary server, on the &quot;development&quot; branch</span><br><span class="line">git &quot;https:&#x2F;&#x2F;enterprise.local&#x2F;desktop&#x2F;git-error-translations2.git&quot; &quot;development&quot;</span><br><span class="line"></span><br><span class="line"># Use a local project</span><br><span class="line">git &quot;file:&#x2F;&#x2F;&#x2F;directory&#x2F;to&#x2F;project&quot; &quot;branch&quot;</span><br><span class="line"></span><br><span class="line"># A binary only framework</span><br><span class="line">binary &quot;https:&#x2F;&#x2F;my.domain.com&#x2F;release&#x2F;MyFramework.json&quot; ~&gt; 2.3</span><br><span class="line"></span><br><span class="line"># A binary only framework via file: url</span><br><span class="line">binary &quot;file:&#x2F;&#x2F;&#x2F;some&#x2F;local&#x2F;path&#x2F;MyFramework.json&quot; ~&gt; 2.3</span><br><span class="line"></span><br><span class="line"># A binary only framework via local relative path from Current Working Directory to binary project specification</span><br><span class="line">binary &quot;relative&#x2F;path&#x2F;MyFramework.json&quot; ~&gt; 2.3</span><br><span class="line"></span><br><span class="line"># A binary only framework via absolute path to binary project specification</span><br><span class="line">binary &quot;&#x2F;absolute&#x2F;path&#x2F;MyFramework.json&quot; ~&gt; 2.3</span><br></pre></td></tr></table></figure>

<h2 id="安装-编辑-Cartfile-中的项目"><a href="#安装-编辑-Cartfile-中的项目" class="headerlink" title="安装/编辑 Cartfile 中的项目"></a>安装/编辑 Cartfile 中的项目</h2><h3 id="clone-项目，然后编译成-framework："><a href="#clone-项目，然后编译成-framework：" class="headerlink" title="clone 项目，然后编译成 framework："></a>clone 项目，然后编译成 <code>framework</code>：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 不指定 platform 会为所有的平台编译（Mac &#x2F; iOS &#x2F; tvOS &#x2F; watchOS）</span><br><span class="line">&#x2F;&#x2F; 查看更多关于 update 命令的选项：&#96;carthage help update&#96;</span><br><span class="line">carthage update --platform iOS</span><br></pre></td></tr></table></figure>

<p>Cartfile 利用 <code>xcode-select</code> 命令来编译 <code>framework</code>，如果你想用其他版的 Xcode 进行编译，执行下面这条命令，把 <code>xcode-select</code> 的路径改为另一版本 Xcode 就可以。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo xcode-select -s &#x2F;Applications&#x2F;Xcode-beta.app&#x2F;Contents&#x2F;Developer</span><br></pre></td></tr></table></figure>

<p>所有的文件会被编译到当前路径的 Carthage 文件夹中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 打开文件夹</span><br><span class="line">open Carthage</span><br></pre></td></tr></table></figure>

<h3 id="Carthage-文件夹中文件说明"><a href="#Carthage-文件夹中文件说明" class="headerlink" title="Carthage 文件夹中文件说明:"></a>Carthage 文件夹中文件说明:</h3><p><img src="/my_pictures/Carthage%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B-1.png"></p>
<h4 id="Cartfile-resolved"><a href="#Cartfile-resolved" class="headerlink" title="Cartfile.resolved"></a>Cartfile.resolved</h4><p>运行 <code>carthage update --platform iOS</code> 命令后，一个叫 <code>Cartfile.resolved</code> 的文件将会被创建到 Cartfile 同级目录下。此文件准确指定了每个依赖项选择的版本，并列出了所有依赖项（甚至是嵌套的版本）。</p>
<p>强烈建议将该文件加入到版本控制中，告知其他开发者，当前使用的版本。</p>
<p>虽然 <code>Cartfile.resolved</code> 文件是人类可读和可扩展的，但你不能修改它。文件的格式非常严格，列出依赖项的顺序对于构建过程很重要。</p>
<h4 id="Carthage-文件夹"><a href="#Carthage-文件夹" class="headerlink" title="Carthage 文件夹"></a>Carthage 文件夹</h4><ul>
<li>Build<br>  包含对应平台编译好的Framework</li>
<li>Checkouts<br>  包含编译 <code>framework</code> 所使用的源代码（除非你使用 <a href="https://github.com/Carthage/Carthage/blob/master/Documentation/Artifacts.md#with-submodules">submodules</a> ，否则不要修改这里的代码，<code>carthage update</code> 和 <code>carthage checkout</code> 会覆盖这里的代码，清除你的修改）。</li>
</ul>
<h4 id="With-submodules"><a href="#With-submodules" class="headerlink" title="With submodules"></a>With submodules</h4><p>如果在引导项目的依赖项时给出了 <code>--use-submodules</code> 标志，<code>updated</code> 或者 <code>checked out</code> <code>Carthage/Checkouts</code> 中的依赖项将作为 <code>Git</code> 子模块（submodules）提供。这允许你对依赖项进行更改，并提交这些更改。</p>
<h2 id="更新Framework的版本"><a href="#更新Framework的版本" class="headerlink" title="更新Framework的版本"></a>更新Framework的版本</h2><h3 id="打开-Cartfile"><a href="#打开-Cartfile" class="headerlink" title="打开 Cartfile"></a>打开 Cartfile</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open -a Xcode Cartfile</span><br></pre></td></tr></table></figure>

<h3 id="修改版本"><a href="#修改版本" class="headerlink" title="修改版本"></a>修改版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; github &quot;Alamofire&#x2F;Alamofire&quot; &#x3D;&#x3D; 4.5</span><br><span class="line">github &quot;Alamofire&#x2F;Alamofire&quot; ~&gt; 4.5.0</span><br></pre></td></tr></table></figure>

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">carthage update --platform iOS</span><br></pre></td></tr></table></figure>

<h3 id="更新指定库"><a href="#更新指定库" class="headerlink" title="更新指定库"></a>更新指定库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">carthage update SVProgressHUD --platform iOS</span><br></pre></td></tr></table></figure>

<h2 id="引入-Carthage-依赖库到-Xcode"><a href="#引入-Carthage-依赖库到-Xcode" class="headerlink" title="引入 Carthage 依赖库到 Xcode"></a>引入 Carthage 依赖库到 Xcode</h2><ol>
<li>在 <code>Carthage -&gt; Build</code> 中找到需要添加的 <code>framework</code>。</li>
<li>拖拽对应的 <code>framework</code> 到 Xcode 工程的 <code>Linked Frameworks and Libraries</code> 中。</li>
</ol>
<p><img src="/my_pictures/Carthage%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B-2.gif"></p>
<ol start="3">
<li> 进入工程的 <code>target -&gt; Build Phases</code>，点击 <code>+</code>，添加 <code>New Run Script Phase</code>:</li>
</ol>
<p><img src="/my_pictures/Carthage%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B-3.png"></p>
<p>添加如下脚本命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;carthage copy-frameworks</span><br></pre></td></tr></table></figure>

<p>在 <code>Input Files</code> 下添加要使用的框架的路径。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(SRCROOT)&#x2F;Carthage&#x2F;Build&#x2F;iOS&#x2F;Alamofire.framework</span><br></pre></td></tr></table></figure>

<p>将复制框架的路径添加到 <code>Output Files</code>。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(BUILT_PRODUCTS_DIR)&#x2F;$(FRAMEWORKS_FOLDER_PATH)&#x2F;Alamofire.framework</span><br></pre></td></tr></table></figure>

<p>为什么需要指定 <code>Output Files</code>。</p>
<p>使用 Carthage 来管理第三方库，在编译并运行 App 的时候，会有一个阶段叫：<code>Carthage Copy Frameworks</code>。这个阶段通过跑一个脚本的形式把所有依赖的第三方库都复制到 App 的目录里。</p>
<p>这个阶段通常会花 1~x 秒不等，这取决于你的 App 依赖的第三方库数量。默认情况下，每次你 <code>Build &amp; Run</code> 的时候，都会进行一次这个操作——尽管你的第三方库没有任何改变。</p>
<p>所以我们需要指定 <code>Output Files</code>，在 <code>Output Files</code> 指定输出文件的情况下，Xcode 只会在 <code>framework</code> 发生更改时去进行 <code>copy framework</code> 操作，这样就节省了时间。</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>iOS工作日志</tag>
      </tags>
  </entry>
  <entry>
    <title>layerClass</title>
    <url>/2019/04/02/2019-04-02-layerClass/</url>
    <content><![CDATA[<p>今天在工作中遇到了需要让 <code>AVPlayerLayer</code> 支持 <code>autolayout</code> 的问题。因为我播放器的 <code>playerView</code> 是通过约束决定大小的，目的为了适应小屏手机。我需要让我的 <code>AVPlayerLayer</code> 充满我的 <code>playerView</code>，如果有 <code>autolayout</code> 这个问题就非常好解决，但是 <code>layer</code> 是不支持 <code>autolayout</code> 的，我想到了两种解决方式。</p>
<a id="more"></a>

<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>自定义 <code>PlayerView</code> 继承自 <code>UIView</code>，然后重写 <code>layoutSubviews</code> 方法，让 <code>layoutSubviews </code> 去执行一个回调 <code>layoutCallback</code>，我们在这个回调中调整 <code>playerLayer</code> 的 <code>frame</code>。</p>
<p>代码大致如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayerView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> layoutCallback: ((<span class="type">UIView</span>) -&gt; <span class="type">Void</span>)?</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">    layoutCallback?(<span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@IBOutlet</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">weak</span> <span class="keyword">var</span> playerView: <span class="type">PlayerView!</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> playerLayer: <span class="type">AVPlayerLayer!</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> player = <span class="type">AVPlayer</span>(url: <span class="type">URL</span>(string: <span class="string">&quot;&quot;</span>)!)</span><br><span class="line">    playerLayer = <span class="type">AVPlayerLayer</span>(player: player)</span><br><span class="line">    playerView.layoutCallback = &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">self</span>?.playerLayer.frame = $<span class="number">0</span>.frame</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样虽然能够解决问题，但是在加载的时候会明显看到 <code>playerLayer</code> 的 <code>frame</code> 被调整。这自然不是我们想要的。</p>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>我们将 <code>UIView</code> 的 <code>layer</code> 直接替换成 <code>AVPlayerLayer</code> 然后就不需要设置 <code>layer</code> 的 <code>frame</code> 它会自动充满整个 <code>View</code>。这样我们完全不需要去初始化一个新的 <code>AVPlayerLayer</code>，用起来也方便不少。</p>
<p>想要替换 <code>View</code> 的 <code>layer</code> 我们需要重写 <code>layerClass</code> 属性。官方对 <code>layerClass</code> 的解释如下：</p>
<blockquote>
<p>这个方法默认返回 <code>CALayer</code> 类对象。子类可以覆盖此方法，并根据需要返回不同的 <code>layer class</code>。例如，如果你的视图使用平铺显示一个大的可滚动区域，您可能希望覆盖此属性并返回 <code>CATiledLayer</code> 类。</p>
<p>在创建视图的早期只调用此方法一次，以便创建相应的 <code>layer</code> 对象。</p>
</blockquote>
<p>最后代码大致如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayerView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">layerClass</span>: <span class="title">AnyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">AVPlayerLayer</span>.<span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> playerLayer: <span class="type">AVPlayerLayer?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.layer <span class="keyword">as</span>? <span class="type">AVPlayerLayer</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@IBOutlet</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">weak</span> <span class="keyword">var</span> playerView: <span class="type">PlayerView!</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    playerView.playerLayer?.player = <span class="type">AVPlayer</span>(url: <span class="type">URL</span>(string: <span class="string">&quot;&quot;</span>)!)</span><br><span class="line">    playerView.playerLayer?.videoGravity = .resizeAspectFill</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题完美解决。</p>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 数组中如何存储弱引用</title>
    <url>/2019/08/21/2019-08-21-iOS%E6%95%B0%E7%BB%84%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%BC%B1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>今天在项目中遇到了一个有趣的问题。项目中有一个监听的服务，监听需要将控制器放入一个数组中为其进行相应的操作。不过这引发了一个循环引用的问题。那么问题就变成了，如何在数组中存储弱引用呢？</p>
<p>数组中存储弱引用我们可以有两种解决方式：</p>
<ul>
<li>设置一个类来存储我们的控制器，这个类的中用于存储的属性自然是 <code>weak</code> 类型。</li>
<li>使用 <code>NSPointerArray</code>。</li>
</ul>
<a id="more"></a>

<h3 id="使用自定义类存储控制器"><a href="#使用自定义类存储控制器" class="headerlink" title="使用自定义类存储控制器"></a>使用自定义类存储控制器</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakObject</span>&lt;<span class="title">T</span>: <span class="title">AnyObject</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> value: <span class="type">T?</span></span><br><span class="line">  <span class="keyword">init</span>(value: <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就不会出现相互持有的情况。详细代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> manager = <span class="type">ControllerManager</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    setupUI()</span><br><span class="line">    </span><br><span class="line">    manager.addListener(to: <span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DemoViewController deinit&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DemoViewController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = .white</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ControllerManager</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> viewControllers = [<span class="type">WeakObject</span>&lt;<span class="type">UIViewController</span>&gt;]()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">addListener</span><span class="params">(to viewController: UIViewController)</span></span> &#123;</span><br><span class="line">    viewControllers.append(<span class="type">WeakObject</span>(value: viewController))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakObject</span>&lt;<span class="title">T</span>: <span class="title">AnyObject</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> value: <span class="type">T?</span></span><br><span class="line">  <span class="keyword">init</span>(value: <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-NSPointerArray"><a href="#使用-NSPointerArray" class="headerlink" title="使用 NSPointerArray"></a>使用 NSPointerArray</h3><p><code>NSPointerArray</code> 类是一个稀疏数组，工作起来与 <code>NSMutableArray</code> 相似，但可以存储 <code>NULL</code> 值，并且 <code>count</code> 方法会反应这些空点。可以用 <code>NSPointerFunctions</code> 对其进行各种设置，也有应对常见的使用场景的快捷构造函数 <code>strongObjectsPointerArray</code> 和 <code>weakObjectsPointerArray</code>。</p>
<p>在能使用 <code>insertPointer:atIndex:</code> 之前，我们需要通过直接设置 <code>count</code> 属性来申请空间，否则会产生一个异常。另一种选择是使用 <code>addPointer:</code>，这个方法可以自动根据需要增加数组的大小。</p>
<p>你可以通过 <code>allObjects</code> 将一个 <code>NSPointerArray</code> 转换成常规的 <code>NSArray</code>。这时所有的 <code>NULL</code> 值会被去掉，只有真正存在的对象被加入到数组 — 因此数组的对象索引很有可能会跟指针数组的不同。注意：如果向指针数组中存入任何非对象的东西，试图执行 <code>allObjects</code> 都会造成 <code>EXC_BAD_ACCESS</code> 崩溃，因为它会一个一个地去 <code>retain</code> 对象。</p>
<p>从调试的角度讲，<code>NSPointerArray</code> 没有受到太多欢迎。<code>description</code> 方法只是简单的返回了<code>&lt;NSConcretePointerArray: 0x17015ac50&gt;</code>。为了得到所有的对象需要执行 <code>[pointerArray allObjects]</code>，当然，如果存在 <code>NULL</code> 的话会改变索引。</p>
<p>这里我们只需要将上述的 <code>var viewControllers = [WeakObject&lt;UIViewController&gt;]()</code> 设置成 <code>var viewControllers = NSPointerArray(options: .weakMemory)</code> 即可。详细代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> manager = <span class="type">ControllerManager</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    setupUI()</span><br><span class="line">    </span><br><span class="line">    manager.addListener(to: <span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DemoViewController deinit&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DemoViewController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = .white</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ControllerManager</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> viewControllers = <span class="type">NSPointerArray</span>(options: .weakMemory)</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">addListener</span><span class="params">(to viewController: UIViewController)</span></span> &#123;</span><br><span class="line">    viewControllers.addPointer(<span class="type">Unmanaged</span>.passUnretained(<span class="keyword">self</span>).toOpaque())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这里使用 <code>NSPointerArray</code> 非常的方便，不过就性能来说，<code>NSPointerArray</code> 真的非常非常慢(不过这里数据量很小，到看不出与 <code>Array</code> 的差别)。</p>
<p>当你打算在一个很大的数据集合上使用它的时候一定要三思。在本测试中我们比较了使用 <code>NSNull</code> 作为空标记的 <code>NSMutableArray</code> ，而对 <code>NSPointerArray</code> 我们用 <code>NSPointerFunctionsStrongMemory</code> 来进行设置 (这样对象会被适当的 <code>retain</code>)。在一个有 10,000 个元素的数组中，我们每隔十个插入一个字符串 <code>Entry %d</code>。此测试包括了用 <code>NSNull.null</code> 填充 <code>NSMutableArray</code> 的总时间。对于 <code>NSPointerArray</code>，我们使用 <code>setCount:</code> 来代替:</p>
<table>
<thead>
<tr>
<th>类 / 时间 [ms]</th>
<th align="center">10.000 elements</th>
</tr>
</thead>
<tbody><tr>
<td>NSMutableArray, adding</td>
<td align="center">15.28</td>
</tr>
<tr>
<td>NSPointerArray, adding</td>
<td align="center">3851.51</td>
</tr>
<tr>
<td>NSMutableArray, random access</td>
<td align="center">0.23</td>
</tr>
<tr>
<td>NSPointerArray, random access</td>
<td align="center">0.34</td>
</tr>
</tbody></table>
<p>注意 <code>NSPointerArray</code> 需要的时间比 <code>NSMutableArray</code> 多了超过 250 倍(!) 。这非常奇怪和意外。跟踪内存是比较困难的，所以按理说 <code>NSPointerArray</code> 会更高效才对。不过由于我们使用的是同一个 <code>NSNull</code> 来标记空对象，所以除了指针也没有什么更多的消耗。</p>
<h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><ul>
<li><a href="https://objccn.io/issue-7-1/">基础集合类</a></li>
</ul>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言回顾之指针常量与常量指针</title>
    <url>/2020/05/24/2020-05-24-C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE%E4%B9%8B%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>C 语言中的指针是非常基础也是非常复杂难懂的概念，其中配合 <code>const</code> 使用更会让初学者一头雾水，今天我们就来看看 C 语言中的常量指针和指针常量。</p>
<h3 id="一、常量指针：指针指向的对象是常量。代码表示如下："><a href="#一、常量指针：指针指向的对象是常量。代码表示如下：" class="headerlink" title="一、常量指针：指针指向的对象是常量。代码表示如下："></a>一、常量指针：指针指向的对象是常量。代码表示如下：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt = &amp;a;</span><br></pre></td></tr></table></figure>

<p>因为 <code>const</code> 修饰的是 <code>int</code>，所以 <code>pt</code> 所指向的内存地址所对应的值是常量不可修改。故，如下写法编译器会报错：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*pt = <span class="number">10</span>; <span class="comment">// Read-only variable is not assignable</span></span><br></pre></td></tr></table></figure>

<p>虽然 <code>pt</code> 指向的内容是不可变的，但是指针本身并没有被 <code>const</code> 修饰，所以指针本身是可变的，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">pt = &amp;b;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="二、指针常量：指针本身是一个常量，所以指针的指向不允许被修改。"><a href="#二、指针常量：指针本身是一个常量，所以指针的指向不允许被修改。" class="headerlink" title="二、指针常量：指针本身是一个常量，所以指针的指向不允许被修改。"></a>二、指针常量：指针本身是一个常量，所以指针的指向不允许被修改。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> pr = &amp;a;</span><br></pre></td></tr></table></figure>

<p>因为 <code>const</code> 修饰的是指针 <code>pr</code>，所以指针所指向的地址是不可以被修改的，如下代码编译器会报错：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pr = &amp;b; <span class="comment">// Cannot assign to variable &#x27;pr&#x27; with const-qualified type &#x27;int *const&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是变量 <code>a</code> 并不是常量，所以其值可以被修改，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*pr = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<h3 id="三、其他写法"><a href="#三、其他写法" class="headerlink" title="三、其他写法"></a>三、其他写法</h3><h4 id="如下均表示常量指针，意义相同："><a href="#如下均表示常量指针，意义相同：" class="headerlink" title="如下均表示常量指针，意义相同："></a>如下均表示常量指针，意义相同：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * p;</span><br></pre></td></tr></table></figure>

<h4 id="如下两行代码均表示的是常量指针-p-指向一个-int-常量"><a href="#如下两行代码均表示的是常量指针-p-指向一个-int-常量" class="headerlink" title="如下两行代码均表示的是常量指针 p 指向一个 int 常量"></a>如下两行代码均表示的是常量指针 p 指向一个 int 常量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C 语言</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
      </tags>
  </entry>
  <entry>
    <title>XCFramework 采坑记</title>
    <url>/2020/12/21/2020-12-21-XCFramework%20%E9%87%87%E5%9D%91%E8%AE%B0/</url>
    <content><![CDATA[<p>Building for iOS Simulator, but the embedded framework ‘xxx.framework’ was built for iOS + iOS Simulator.</p>
<p>升级 Xcode 后就悲剧了，以上报错苹果在 Xcode 11 中已经给出 warring，在 Xcode 12.3 版本后会直接 error。</p>
<a id="more"></a>

<p>来自苹果工程师的回复：</p>
<blockquote>
<p>This framework isn’t built with a supported configuration – iOS and iOS Simulator code has never been supported in the same binary. The linker in Xcode 11 began identifying these incorrect configurations and issuing warnings, and Xcode 12 goes further in identifying these issues.</p>
<p>The only correct way to resolve this is to <a href="https://developer.apple.com/videos/play/wwdc2019/416/">rebuild the framework as an XCFramework.</a> If this is your framework, or owned by another group in your company, follow the information in the video and <a href="https://help.apple.com/xcode/mac/current/#/dev544efab96">the Xcode Help article.</a></p>
<p>If this framework is from a vendor, then you need to work with the vendor to get an updated version of the framework built with supported configuration.</p>
<p>In the discussion of this thread, there is a build script that attempts to resolve this error. Scripts like that – anything that tries to manipulate the output with commands like lipo – still produces an unsupported configuration in the binary. XCFrameworks are the way to go.</p>
</blockquote>
<p><strong>官方推荐方式（需要 new build system 支持）：</strong></p>
<p>将库打包成 xcframework 格式。</p>
<p>有关于 xcframework 内容可以参考苹果的 WWDC 视频 <a href="https://developer.apple.com/videos/play/wwdc2019/416/">Binary Frameworks in Swift</a></p>
<p>Carthage 目前通过 homebrew 安装方式还不支持打包成 xcframework 格式，所以需要我们手动调用 xcodebuild 命令。为了使用方便，我们可以在工程中添加 Aggregated target，然后创建 script 方便我们生成 xcframework。完整的 script 如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">WORKSPACE_NAME=&quot;$&#123;PROJECT&#125;.xcworkspace&quot;</span><br><span class="line">SCHEME_NAME=$&#123;PROJECT&#125;</span><br><span class="line">FRAMEWORK_NAME=$&#123;PROJECT&#125;</span><br><span class="line">SIMULATOR_ARCHIVE_PATH=&quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;/$&#123;FRAMEWORK_NAME&#125;-iphonesimulator.xcarchive&quot;</span><br><span class="line">DEVICE_ARCHIVE_PATH=&quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;/$&#123;FRAMEWORK_NAME&#125;-iphoneos.xcarchive&quot;</span><br><span class="line">OUTPUT_DIC=&quot;./xcframework/&quot;</span><br><span class="line"> </span><br><span class="line">script=&quot;./xcodebuild.sh&quot;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> Simulator xcarchieve</span></span><br><span class="line">/bin/sh $&#123;script&#125; archive \</span><br><span class="line">  -workspace $&#123;WORKSPACE_NAME&#125; \</span><br><span class="line">  -scheme $&#123;SCHEME_NAME&#125; \</span><br><span class="line">  -archivePath $&#123;SIMULATOR_ARCHIVE_PATH&#125; \</span><br><span class="line">  -sdk iphonesimulator \</span><br><span class="line">  SKIP_INSTALL=NO</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> Device xcarchieve</span></span><br><span class="line">xcodebuild archive \</span><br><span class="line">  -workspace $&#123;WORKSPACE_NAME&#125; \</span><br><span class="line">  -scheme $&#123;SCHEME_NAME&#125; \</span><br><span class="line">  -archivePath $&#123;DEVICE_ARCHIVE_PATH&#125; \</span><br><span class="line">  -sdk iphoneos \</span><br><span class="line">  SKIP_INSTALL=NO</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> Clean up old output directory</span></span><br><span class="line">rm -rf &quot;$&#123;OUTPUT_DIC&#125;&quot;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> Create xcframwork combine of all frameworks</span></span><br><span class="line">xcodebuild -create-xcframework \</span><br><span class="line">  -framework $&#123;SIMULATOR_ARCHIVE_PATH&#125;/Products/Library/Frameworks/$&#123;FRAMEWORK_NAME&#125;.framework \</span><br><span class="line">  -framework $&#123;DEVICE_ARCHIVE_PATH&#125;/Products/Library/Frameworks/$&#123;FRAMEWORK_NAME&#125;.framework \</span><br><span class="line">  -output $&#123;OUTPUT_DIC&#125;/$&#123;FRAMEWORK_NAME&#125;.xcframework</span><br></pre></td></tr></table></figure>

<p>由于模拟器的编译在 Xcode 12.x 中有问题，所以新建了一个 xcodebuild.sh 文件，代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> xcodebuild.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Usage example: ./xcodebuild.sh archive</span></span><br><span class="line"> </span><br><span class="line">set -euo pipefail</span><br><span class="line"> </span><br><span class="line">xcconfig=$(mktemp /tmp/static.xcconfig.XXXXXX)</span><br><span class="line">trap &#x27;rm -f &quot;$xcconfig&quot;&#x27; INT TERM HUP EXIT</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> For Xcode 12 make sure EXCLUDED_ARCHS is <span class="built_in">set</span> to arm architectures otherwise</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the build will fail on lipo due to duplicate architectures.</span></span><br><span class="line">echo &#x27;EXCLUDED_ARCHS__EFFECTIVE_PLATFORM_SUFFIX_simulator__NATIVE_ARCH_64_BIT_x86_64__XCODE_1200 = arm64 arm64e armv7 armv7s armv6 armv8&#x27; &gt;&gt; $xcconfig</span><br><span class="line">echo &#x27;EXCLUDED_ARCHS = $(inherited) $(EXCLUDED_ARCHS__EFFECTIVE_PLATFORM_SUFFIX_$(EFFECTIVE_PLATFORM_SUFFIX)__NATIVE_ARCH_64_BIT_$(NATIVE_ARCH_64_BIT)__XCODE_$(XCODE_VERSION_MAJOR))&#x27; &gt;&gt; $xcconfig</span><br><span class="line"> </span><br><span class="line">export XCODE_XCCONFIG_FILE=&quot;$xcconfig&quot;</span><br><span class="line">xcodebuild &quot;$@&quot;</span><br></pre></td></tr></table></figure>

<h4 id="两个临时修复方案："><a href="#两个临时修复方案：" class="headerlink" title="两个临时修复方案："></a>两个临时修复方案：</h4><ul>
<li>不使用 Xcode 12.3，换成 Xcode 12.2。</li>
<li>将工程的 Validate Workspace 设置成为 YES。</li>
</ul>
<h4 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h4><ul>
<li><a href="https://github.com/Carthage/Carthage/issues/2799">Catalyst support</a></li>
<li><a href="https://developer.apple.com/forums/thread/669411?answerId=652489022#652489022">Xcode 12.3 failed on some 3rd framework and librarys?</a></li>
<li><a href="https://github.com/Carthage/Carthage/issues/3019">Workaround that works with both Xcode 11 and 12</a></li>
<li><a href="https://github.com/Carthage/Carthage/issues/2890">Roadmap Q4 2019 - Q1 2020</a></li>
</ul>
]]></content>
      <categories>
        <category>工作日志</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg Xcode 环境搭建</title>
    <url>/2021/06/29/2021-06-29-FFmpeg%20Xcode%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="安装-FFmpeg"><a href="#安装-FFmpeg" class="headerlink" title="安装 FFmpeg"></a>安装 FFmpeg</h1><p>根据 <a href="https://trac.ffmpeg.org/wiki/CompilationGuide/macOS">官方文档</a> 的描述，有三种安装 FFmpeg 的方式，这里我们选择最简单快速的一种，使用 <code>Homebrew</code> 命令安装。</p>
<p>如果还没有安装 <code>Homebrew</code> 的话，请先安装 <code>Homebrew</code>，<a href="https://brew.sh/">点击跳转官方网站</a></p>
<p>我们执行如下命令即可安装好 FFmpeg：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install ffmpeg</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="Xcode-相关配置"><a href="#Xcode-相关配置" class="headerlink" title="Xcode 相关配置"></a>Xcode 相关配置</h1><h2 id="Build-Settings"><a href="#Build-Settings" class="headerlink" title="Build Settings"></a>Build Settings</h2><p>我们通过如下命令即可查看 FFmpeg 的相关信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew info ffmpeg</span><br></pre></td></tr></table></figure>

<p>会输出类似下面一样的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg: stable 4.4 (bottled), HEAD</span><br><span class="line">Play, record, convert, and stream audio and video</span><br><span class="line">https://ffmpeg.org/</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/ffmpeg/4.4_2 (276 files, 52.7MB) *</span><br><span class="line">  Poured from bottle on 2021-06-25 at 00:50:35</span><br><span class="line">From: https://github.com/Homebrew/homebrew-core/blob/HEAD/Formula/ffmpeg.rb</span><br><span class="line">License: GPL-2.0-or-later</span><br><span class="line">==&gt; Dependencies</span><br><span class="line">Build: nasm ✔, pkg-config ✔</span><br><span class="line">Required: aom ✔, dav1d ✔, fontconfig ✔, freetype ✔, frei0r ✔, gnutls ✔, lame ✔, libass ✔, libbluray ✔, libsoxr ✔, libvidstab ✔, libvorbis ✔, libvpx ✔, opencore-amr ✔, openjpeg ✔, opus ✔, rav1e ✔, rubberband ✔, sdl2 ✔, snappy ✔, speex ✔, srt ✔, tesseract ✔, theora ✔, webp ✔, x264 ✔, x265 ✔, xvid ✔, xz ✔, zeromq ✔, zimg ✔</span><br><span class="line">==&gt; Options</span><br><span class="line">--HEAD</span><br><span class="line">	Install HEAD version</span><br><span class="line">==&gt; Analytics</span><br><span class="line">install: 124,147 (30 days), 436,612 (90 days), 1,751,038 (365 days)</span><br><span class="line">install-on-request: 102,817 (30 days), 366,434 (90 days), 1,443,249 (365 days)</span><br><span class="line">build-error: 0 (30 days)</span><br></pre></td></tr></table></figure>

<p>我们在信息中可以找到 FFmpeg 的安装目录如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/Cellar/ffmpeg/4.4_2</span><br></pre></td></tr></table></figure>

<p>目录中包括两个文件夹 <code>lib</code> 和 <code>include</code>，这两个文件夹我们需要在 <code>Xcode</code> 中配置相关搜索路径。我们打开 <code>Xcode</code> 的 <code>Build Settings</code> 界面，配置 <code>Header Search Paths</code> 和 <code>Library Search Paths</code>。我的本地环境配置如下图所示：</p>
<p><img src="/my_pictures/Xnip2021-06-29_21-52-35.png"></p>
<h2 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h2><p>我们切换到 <code>General</code> 或 <code>Build Phases</code>，将 <code>FFmpeg</code> 目录下的 <code>lib</code> 文件夹中的 <code>.a</code> 文件按需添加，如下图：</p>
<p><img src="/my_pictures/Xnip2021-06-29_21-59-11.png"><br><img src="/my_pictures/Xnip2021-06-29_21-59-56.png"><br><img src="/my_pictures/Xnip2021-06-29_21-58-14.png"></p>
<p>此时我们的环境就算是配置完毕。</p>
<p>我们在类中随便加点代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Cocoa</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">NSViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        av_log_set_flags(<span class="type">AV_LOG_SKIP_REPEATED</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">#if</span> <span class="type">CONFIG_AVDEVICE</span></span><br><span class="line">            avdevice_register_all();</span><br><span class="line">        <span class="keyword">#endif</span></span><br><span class="line">        avformat_network_init()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> representedObject: <span class="type">Any?</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>桥接文件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;libavutil/avstring.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libavutil/eval.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libavutil/mathematics.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libavutil/pixdesc.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libavutil/imgutils.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libavutil/dict.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libavutil/fifo.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libavutil/parseutils.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libavutil/samplefmt.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libavutil/avassert.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libavutil/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libavutil/bprint.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libavdevice/avdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libavutil/opt.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libavcodec/avfft.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libswresample/swresample.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>此时我们 <code>Build</code> 一下，发现是可以编译通过的。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p><code>Build</code> 没问题了，我们 <code>run</code> 一下。此时我们可能碰到 <code>crash</code>，提示信息如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dyld: Library not loaded: /usr/<span class="built_in">local</span>/opt/ffmpeg/lib/libswscale.5.dylib</span><br><span class="line">  Referenced from: /Users/jiafengwu/Library/Developer/Xcode/DerivedData/ffdemo-gqmgjyhlyiyktmdpikmfktmubkzg/Build/Products/Debug/ffdemo.app/Contents/MacOS/ffdemo</span><br><span class="line">  Reason: no suitable image found.  Did find:</span><br><span class="line">	/usr/<span class="built_in">local</span>/opt/ffmpeg/lib/libswscale.5.dylib: code signature <span class="keyword">in</span> (/usr/<span class="built_in">local</span>/opt/ffmpeg/lib/libswscale.5.dylib) not valid <span class="keyword">for</span> use <span class="keyword">in</span> process using Library Validation: mapped file has no cdhash, completely unsigned? Code has to be at least ad-hoc signed.</span><br><span class="line">	/usr/<span class="built_in">local</span>/lib/libswscale.5.dylib: code signature <span class="keyword">in</span> (/usr/<span class="built_in">local</span>/lib/libswscale.5.dylib) not valid <span class="keyword">for</span> use <span class="keyword">in</span> process using Library Validation: mapped file has no cdhash, completely unsigned? Code has to be at least ad-hoc signed.</span><br><span class="line">	/usr/<span class="built_in">local</span>/Cellar/ffmpeg/4.4_2/lib/libswscale.5.9.100.dylib: code signature <span class="keyword">in</span> (/usr/<span class="built_in">local</span>/Cellar/ffmpeg/4.4_2/lib/libswscale.5.9.100.dylib) not valid <span class="keyword">for</span> use <span class="keyword">in</span> process using Library Validation: mapped file has no cdhash, completely unsigned? Code has to be at least ad-hoc signed.</span><br></pre></td></tr></table></figure>

<p>从提示信息我们可知，是动态库没有签名。我们还需将其手动签名一下。顺便说一句，上面的报错是在 <code>FFmpeg</code> 目录中的 <code>lib</code> 目录下，我们将其签名后可能还有其他库需要签名，我的解决方式是，直接吧报错目录下的所有动态库批量签名。</p>
<p>我们从钥匙串中找到我们证书的名字，类似于：<code>Apple Development: xxx</code>。</p>
<p>我们打开终端，进入对应目录，执行如下签名命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codesign -f -s <span class="string">&quot;Apple Development: xxx&quot;</span> *.dylib</span><br></pre></td></tr></table></figure>

<p><strong>引号中的证书信息需要替换成自己的</strong></p>
<p>因为 <code>Xcode</code> 运行代码使用了系统的库，所以我就批量的进行了签名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codesign -f -s <span class="string">&quot;Mac Developer: xxx&quot;</span> /usr/<span class="built_in">local</span>/opt/*/lib/*.dylib</span><br></pre></td></tr></table></figure>

<p>当我们签名完成之后，再次进行 <code>run</code>，发现就能跑起来了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>签名的相关命令</p>
<p>1、清除动态库的签名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codesign --remove-signature xxx.dylib</span><br></pre></td></tr></table></figure>

<p>2、查看签名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codesign -vv -d xxx.dylib</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codesign -dvvv xxx.dylib</span><br></pre></td></tr></table></figure>

<p>3、重新签名</p>
<p><code>codesign</code> 的 <code>-f</code> 参数就是强制签名的意思，本文使用的 <code>codesign -f -s</code> 就能直接重新签名。如果不想覆盖原来的签名，可以把 <code>-f</code> 参数去掉。</p>
]]></content>
      <categories>
        <category>macOS 开发</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
</search>
