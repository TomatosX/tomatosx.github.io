<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=SF+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="Judging by the number of talks, articles and discussions related to reactive programming in Swift, it looks like the community has been taken by the storm. It’s not that the concept of reactiveness it">
<meta property="og:type" content="article">
<meta property="og:title" content="8 Mistakes to Avoid while Using RxSwift">
<meta property="og:url" content="http://example.com/2018/03/19/2018-03-19-8%20Mistakes%20to%20Avoid%20while%20Using%20RxSwift/index.html">
<meta property="og:site_name" content="CX330">
<meta property="og:description" content="Judging by the number of talks, articles and discussions related to reactive programming in Swift, it looks like the community has been taken by the storm. It’s not that the concept of reactiveness it">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-03-18T16:00:00.000Z">
<meta property="article:modified_time" content="2021-06-16T03:22:25.874Z">
<meta property="article:author" content="CX330">
<meta property="article:tag" content="RxSwift专题">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2018/03/19/2018-03-19-8%20Mistakes%20to%20Avoid%20while%20Using%20RxSwift/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>8 Mistakes to Avoid while Using RxSwift | CX330</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">CX330</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Not-disposing-a-subscription"><span class="nav-number">1.</span> <span class="nav-text">Not disposing a subscription</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-mental-model-for-subscription-memory-management"><span class="nav-number">2.</span> <span class="nav-text">The mental model for subscription memory-management</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-implementation-of-the-subscribe-method"><span class="nav-number">3.</span> <span class="nav-text">The implementation of the subscribe method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sinking-in-the-sea-of-Observables"><span class="nav-number">4.</span> <span class="nav-text">Sinking in the sea of Observables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sink-full-of-knowledge"><span class="nav-number">5.</span> <span class="nav-text">Sink full of knowledge</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Producer%E2%80%98s-reference-cycle-Sink-and-SinkDisposer"><span class="nav-number">6.</span> <span class="nav-text">The Producer‘s reference cycle: Sink and SinkDisposer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-road-goes-ever-on-and-on"><span class="nav-number">7.</span> <span class="nav-text">The road goes ever on and on</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CX330"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">CX330</p>
  <div class="site-description" itemprop="description">Stay hungry. Stay foolish.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">94</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/TomatosX" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TomatosX" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wujiafengwork@gmail.com" title="E-Mail → mailto:wujiafengwork@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/03/19/2018-03-19-8%20Mistakes%20to%20Avoid%20while%20Using%20RxSwift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="CX330">
      <meta itemprop="description" content="Stay hungry. Stay foolish.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CX330">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          8 Mistakes to Avoid while Using RxSwift
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-03-19 00:00:00" itemprop="dateCreated datePublished" datetime="2018-03-19T00:00:00+08:00">2018-03-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-16 11:22:25" itemprop="dateModified" datetime="2021-06-16T11:22:25+08:00">2021-06-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">技术学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Judging by the number of talks, articles and discussions related to reactive programming in Swift, it looks like the community has been taken by the storm. It’s not that the concept of <em>reactiveness</em> itself is a new shiny thing. The idea of using it for the development within the Apple ecosystem had been played with for a long time. Frameworks like <a target="_blank" rel="noopener" href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> have existed for years and did an awesome job at bringing the reactive programming to the Objective-C. However, the new and exciting features of Swift make it even more convenient to go full in on the “signals as your apps’ building blocks” model.</p>
<p>Here at Polidea, we’ve also embraced the reactive paradigm, mostly in the form of <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift">RxSwift</a>, the port of C#-originated <a target="_blank" rel="noopener" href="http://reactivex.io/">Reactive Extensions</a>. And we couldn’t be happier! It helps us build more expressive and better-architectured apps faster and easier. Unifying various patterns (target-action, completion block, notification) under a universal API that is easy to use, easy to compose and easy to test has so many benefits. Also, introducing new team members is way easier now, when so much logic is written with methods familiar either from sequences (map, filter, zip, flatMap) or from other languages that Reactive Extensions had been ported to.</p>
<a id="more"></a>

<p>The process of learning RxSwift, however, hasn’t been painless. We’ve made many mistakes, fallen into many traps and eventually arrived at the other end to share what we’ve learned along the way. This is what this series is about: showing you the most common pitfalls to avoid when going reactive. They all come from the everyday practical use of RxSwift in non-trivial applications. It took us many hours to learn our lessons and we hope that with our help it’s going to take you only few minutes to enjoy the benefits of reactive programming without ever encountering its dark side.</p>
<p>So, let’s start!</p>
<h3 id="Not-disposing-a-subscription"><a href="#Not-disposing-a-subscription" class="headerlink" title="Not disposing a subscription"></a>Not disposing a subscription</h3><p>When you started using RxSwift for the first time, you’ve probably tried to observe some events by writing:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">observable</span><br><span class="line">    .subscribe(onNext: &#123; ... &#125;)</span><br></pre></td></tr></table></figure>

<p>Such an expression was, however, openly criticized by Xcode with the default <code>Result to call to &#39;subscribe&#39; is unused</code> warning. Luckily, there’s an easy fix available just around the corner. Telling the compiler that we ignore the call result with <code>_ =</code> would be enough, right? So now it’s:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">_</span> = observable</span><br><span class="line">        .subscribe(onNext: &#123; ... &#125;)</span><br></pre></td></tr></table></figure>

<p>and everything is fixed, isn’t it? If you think so, prepare yourself for a treat. There’re probably a whole lot of low-hanging fruits of undisposed subscriptions just waiting to be picked from your memory-management tree. Ignoring the subscription’s result is a clear path to memory leaks. While there are situations in which you’ll be spared any problems, in the worst-case scenario both your <code>observable</code> and the observer closure will never be released. The bad news is that by ignoring the value returned from <code>subscribe</code> method you’re giving away the control over which scenario is going to happen.</p>
<p>To understand the problem, I’ll show you the mental model of the subscription process in terms of memory-management first. Then, I’ll derive the best practices. Finally, I’m going to peek into RxSwift source code to understand what is actually happening in the current (v3.X/4.0) implementation and how it relates to the mental model presented earlier.</p>
<h3 id="The-mental-model-for-subscription-memory-management"><a href="#The-mental-model-for-subscription-memory-management" class="headerlink" title="The mental model for subscription memory-management"></a>The mental model for subscription memory-management</h3><p><em>Calling <code>subscribe</code> creates a reference cycle that retains both the <code>observable</code> and the <code>observer</code></em>. Neither of them is going to be released unless the cycle is broken, and it’s broken only in two situations:</p>
<ul>
<li>when the observable sequence completes, either with <code>.completed</code> or <code>.error</code> event,</li>
<li>when someone explicitly calls <code>.dispose()</code> on the <em>reference cycle manager</em> returned by <code>subscribe</code> method.</li>
</ul>
<p>![](/my_pictures/8 Mistakes to Avoid while Using RxSwift-1.jpeg)</p>
<p>The details may vary, but the basic idea of what it means to <em>subscribe</em> holds regardless of your particular observable, observer or subscription. The crucial thing to spot is that ignoring the <em>reference cycle manager</em>, aka <code>disposable</code>, strips you of the possibility to break reference cycle yourself. It is your gateway drug into the memory arrangement, and once it’s not available, there is no going back. If you use the <code>_ =</code> syntax, you basically state that the only way for the <code>observable</code> and <code>observer</code> to be released is by completing the observable sequence.</p>
<p>This might sometimes be exactly what you want! For example, if you’re calling <code>Observable.just</code>, it doesn’t really matter that you won’t ensure breaking the cycle. The single element is being emitted instantaneously, followed by <code>.completed</code> event. There are, however, many situations in which you might not be entirely sure of the completion possibilities for observable in question:</p>
<ul>
<li>you’re given the <code>Observable</code> from another object and the documentation doesn’t state whether it completes,</li>
<li>you’re given the <code>Observable</code> from another object and the documentation does state it completes, but there have been some changes in the internal implementation of that object along the way and no one remembered to update documentation,</li>
<li>the <code>Observable</code> is explicitly not completing (examples include <code>Variable</code>, <code>Observable.interval</code>, subjects),</li>
<li>there is an error in observable implementation, such as forgetting to send <code>.completed</code> event in <code>Observable.create</code> closure.<br>Since you’re rarely in control of all the observables in your app, and even then there’s a possibility for a mistake, the rule of thumb is to ensure yourself that the reference cycle will be broken. Either keep the reference to <code>disposable</code> and call the <code>.dispose()</code> method when the time comes, or use a handy helper like <code>DisposeBag</code> that’s gonna do it for you. You might also provide a separate cycle-breaking observable with <code>.takeUntil</code> operator. What way to choose depends on your particular situation, but always remember that:</li>
</ul>
<blockquote>
<p>Subscription creates a reference cycle between the observable and the observer. It might be broken implicitly, when observable completes, or explicitly, via <code>.dispose()</code>call. If you’re not 100% sure when or whether observable will complete, break the subscription reference cycle yourself!   </p>
</blockquote>
<p>Now that we’ve cleared things up, I feel like I owe you a little bit of explanation. The mental model I’ve drawn above is, well, a mental model, and therefore not strictly correct. What’s happening in the current RxSwift implementation (version 3.x/4.x at the time of writing) is a little bit more complicated. To understand the actual behavior, let us have a deeper dive into the RxSwift internals.</p>
<h3 id="The-implementation-of-the-subscribe-method"><a href="#The-implementation-of-the-subscribe-method" class="headerlink" title="The implementation of the subscribe method"></a>The implementation of the <code>subscribe</code> method</h3><p>Where is the <code>subscribe</code> method implemented? First place to search would be, unsurprisingly, the <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/ObservableType.swift">ObservableType.swift</a> file. It contains declaration of <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/ObservableType.swift#L39">subscribe</a> method as a part of the <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/ObservableType.swift#L10">ObservableType</a> protocol:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObservableType.swift</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;O: ObserverType&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">_</span> observer: O</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> == <span class="type">E</span></span><br></pre></td></tr></table></figure>

<p>What implements this protocol? Basically, all the various types of observables. Let’s concentrate on the major implementation called <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observable.swift">Observable</a>, since it’s a base class for all but one of the observables defined in RxSwift. Its version of <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observable.swift#L22">subscribe</a> method is short and simple:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Observable.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;O: ObserverType&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">_</span> observer: O</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> == <span class="type">E</span> &#123;</span><br><span class="line">    rxAbstractMethod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Oh, the abstract method. We need to look into the <code>Observable</code> subclasses then. A quick search reveals that there are 14 different overridden <code>subscribe</code> methods within the RxSwift source code at the time of writing. We can put each of them in one of three buckets:</p>
<ul>
<li>implementations in subjects, which provide their own subscription logic due to the extraordinary place they occupy in the RxSwift lore,</li>
<li>implementations in connectable observables, which must deal with subscriptions in a special way due to their ability of multicasting,</li>
<li>implementation in <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift">Producer</a>, a subclass of <code>Observable</code> which provides the subscription logic for most of the operators you’ve grown to love and use.</li>
</ul>
<p>![](/my_pictures/8 Mistakes to Avoid while Using RxSwift-2.jpeg)</p>
<p>Let’s concentrate on <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift">Producer</a> type, since it represents the variant of observable that is simplest to reason about: the emitter of the sequence of events, from the single source to single recipient. It’s definitely the most common use case. Almost all the operators are derived from <code>Producer</code> base class. While a few of them provide a dedicated subscription logic that’s optimized further to their particular needs (see <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Just.swift">Just</a>, <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Empty.swift">Empty</a> or <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Error.swift">Error</a> for basic examples), the vast majority use the following implementation of <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L14">subscribe</a> from <code>Producer</code> (some scheduler-related logic was stripped for better readability):</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Producer.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;O : ObserverType&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">_</span> observer: O</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> == <span class="type">Element</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">    <span class="keyword">let</span> sinkAndSubscription = run(observer, cancel: disposer)</span><br><span class="line">    disposer.setSinkAndSubscription(</span><br><span class="line">        sink: sinkAndSubscription.sink,</span><br><span class="line">        subscription: sinkAndSubscription.subscription</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> disposer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So, what’s happening here? First, the observable creates a <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L39">SinkDisposer</a> object. Then it uses the <code>SinkDisposer</code> instance to create two additional objects: <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L18">sink and subscription</a>. They both have the same type: <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Disposable.swift">Disposable</a>, which is a protocol exposing a single <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Disposable.swift#L12">dispose</a> method. These two objects are being passed back to <code>SinkDisposer</code> via a setter method, which suggests, correctly, that their references will be kept. After all that setup is done, the <code>SinkDisposer</code> is being returned. So, when we’re calling <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L76">.dispose()</a> on the object returned from the <code>subscribe</code> method to break the subscription, we’re actually calling it on <code>SinkDisposer</code> instance.</p>
<p>So far, so good. One mystery down, still a few to go. Let’s dive into two crucial steps performed here: <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L17">let sinkAndSubscription = run(observer, cancel: disposer)</a> and <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L18">disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</a> methods. They are, as you’ll see, the essential parts of creating the reference cycle that keeps the subscription alive.</p>
<h3 id="Sinking-in-the-sea-of-Observables"><a href="#Sinking-in-the-sea-of-Observables" class="headerlink" title="Sinking in the sea of Observables"></a>Sinking in the sea of Observables</h3><p>The <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L34">run</a> method is provided by the <code>Producer</code>, but only in an abstract variant:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Producer.swift</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span>&lt;O : ObserverType&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">_</span> observer: O, cancel: Cancelable</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>)</span><br><span class="line"><span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> == <span class="type">Element</span> &#123;</span><br><span class="line">    rxAbstractMethod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The actual logic is specific to the particular <code>Producer</code> subclass. Before we check them, it’s crucial to understand the pattern that is very common across the RxSwift operators implementation: <em>sink</em>. This is the way that RxSwift deals with the complexity of observable streams and how it separates the creation of the observable from the logic that is being run the moment you <code>subscribe</code> to it.</p>
<p>The idea is simple: when you use the particular operator (say you <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Map.swift#L20">map</a> the existing observable), it returns an instance of a particular observable type dedicated to the task at hand. So calling <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Just.swift#L18">Observable.just(1)</a> gives you back the instance of <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Just.swift#L75">Just</a> class, which is a subclass of the <code>Producer</code> optimized for returning just one element and then completing. When you call <code>Observable&lt;Int&gt;.just(1).map &#123; $0 == 42 &#125;</code>, you’re being given back the instance of <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Map.swift#L142">Map</a> class, which is a subclass of the <code>Producer</code> optimized for applying the closure to each element in the <code>.next</code> event. However, at the very moment you create an observable, there’s nothing being actually sent to anyone yet, because no one has subscribed. The actual work of passing the events starts during the <code>subscribe</code> method, more precisely: in the <code>run</code> method that we’re so interested in.</p>
<p>That’s where the sink pattern shines. Each observable type has its own dedicated <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Sink.swift">Sink</a> subclass. For the <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Timer.swift#L19">interval</a> operator, represented by the <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Timer.swift#L88">Timer</a> observable, there is the <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Timer.swift#L49">TimerSink</a>. For the <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Merge.swift#L19">flatMap</a> operator, represented by the <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Merge.swift#L546">FlatMap</a> observable, there is the <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Merge.swift#L355">FlatMapSink</a>. For the <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Catch.swift#L32">catchErrorJustReturn</a> operator, represented by the <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Catch.swift#L151">Catch</a> observable, there is the <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Catch.swift#L108">CatchSink</a>. I think you get the idea!</p>
<p>But what is this <code>Sink</code> object, exactly? It is the place that stores the actual operator logic. So, for the <code>interval</code>, the <code>TimerSink</code> is the place that schedules sending events after each period and keeps track of the internal state (i.e. how many events were already sent). For the <code>flatMap</code>, the <code>FlatMapSink</code> (and its superclass, <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Merge.swift#L438">MergeSink</a> ) is the place that subscribes to the observables returned from flatmapping closure, keeps track of them and passes their events further. You may basically think of a <code>Sink</code> as a wrapper for the observer. It listens for the events from observable, applies the operator-related logic and then passes those transformed events further down the stream.</p>
<p>This is how RxSwift isolates the creation of observables from the execution of subscription logic for <code>Producer</code> -based observables. The former is encapsulated in the <code>Observable</code> subclass, the latter is provided by the <code>Sink</code> subclass. The separation of responsibilities greatly simplifies the actual objects’ implementations and makes it possible to write multiple variants of <code>Sink</code> optimized for different scenarios.</p>
<h3 id="Sink-full-of-knowledge"><a href="#Sink-full-of-knowledge" class="headerlink" title="Sink full of knowledge"></a><code>Sink</code> full of knowledge</h3><p>Now that we know what the <em>sink</em> pattern is, let’s go back to the <code>run</code> method. Each of these <code>Producer</code> subclasses provides its own <code>run</code> implementation. While details may vary, it usually can be abstracted into three steps:</p>
<ul>
<li>create a <code>sink</code> object as an instance of a class that derives from <code>Sink</code> type,</li>
<li>create a subscription instance, usually by running <code>sink.run</code> method,</li>
<li>return both instances wrapped in a tuple.<br>To clarify things further, please look at the <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Merge.swift#L558">FlatMap.run</a> example:</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Merge.swift, FlatMap observable class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span>&lt;O: ObserverType&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">_</span> observer: O, cancel: Cancelable</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>)</span><br><span class="line"><span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> == <span class="type">SourceSequence</span>.<span class="type">E</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sink = <span class="type">FlatMapSink</span>(</span><br><span class="line">      selector: _selector,</span><br><span class="line">      observer: observer,</span><br><span class="line">      cancel: cancel</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">let</span> subscription = sink.run(_source)</span><br><span class="line">  <span class="keyword">return</span> (sink: sink, subscription: subscription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The most important thing from the memory-management perspective is that in the moment of subscription the <code>sink</code> is given everything that’s needed to do the job:</p>
<ul>
<li>the events source (aka <em>Observable</em> ),</li>
<li>the event recipient (called <code>observer</code> ),</li>
<li>the operator-related data (for example, the flatmapping closure),</li>
<li>and the <code>SinkDisposer</code> instance (under the name <code>cancel</code> ).<br><code>sink</code> is free to store as many of these references as it sees fit for providing the required behavior of the operator. At the minimum, it’s gonna store the <code>observer</code> and, what’s gonna be crucial later, the <code>SinkDisposer</code>. Possibly more! Looking at the memory graph, <code>sink</code> quickly becomes the Northern Star in the constellation of objects related to the subscription.</li>
</ul>
<p>There is, however, one more object returned from observable’s <code>run</code> method. It’s <code>subscription</code>. This is the object that takes care of the logic that should be run when the subscription is being disposed of. Remember <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Create.swift#L20">create</a> operator? It takes a closure that returns <code>Disposable</code>, an object responsible for performing the cleanup. This is the same <code>Disposable</code> that’s returned from <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Create.swift#L25">AnonymousObservableSink</a>‘s <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Create.swift#L59">run</a> method as <code>subscription</code>. For each operator there might be some tasks to cancel, some resources to free, some internal subscription to dispose of. They’re all enclosed in the <code>subscription</code> object, and the ability to perform the cleanup is exposed via <code>subscription.dispose</code> method.</p>
<h3 id="The-Producer‘s-reference-cycle-Sink-and-SinkDisposer"><a href="#The-Producer‘s-reference-cycle-Sink-and-SinkDisposer" class="headerlink" title="The Producer‘s reference cycle: Sink and SinkDisposer"></a>The <code>Producer</code>‘s reference cycle: Sink and SinkDisposer</h3><p>Knowing that, let’s get back to the last component of the <code>subscribe</code> method implementation. Before the <code>SinkDisposer</code> is returned, the <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L59">setSinkAndSubscription</a> method is called. It does exactly what you might expect: the <code>sink</code> and <code>subscription</code> objects are passed via setter and kept in the <code>SinkDisposer</code> properties. They are referenced strongly, but wrapped into Optionals, which makes it possible set the references to <code>nil</code> later.</p>
<p>Have you already spotted the reference cycle from our mental model? It’s hidden in the plain sight! <code>sink</code> <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Sink.swift#L11">stores the reference</a> to <code>SinkDisposer</code>, and <code>SinkDisposer</code> <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L52">stores the reference</a> to <code>sink</code>. That’s why the subscription doesn’t release itself on the scope exit. Two objects keep each other alive, in an eternal hug of memory-lockup, until the end of the app. And since <code>sink</code> keeps <code>SinkDisposer</code> as non-Optional property, the one and only way of breaking the cycle is by asking the <code>SinkDisposer</code> to set the <code>sink</code> Optional reference to <code>nil</code>. And guess what? This is exactly what’s happening in the <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L76">SinkDisposer.dispose</a> method. It calls <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L91">dispose</a> on <code>sink</code>, then it calls <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L92">dispose</a> on subscription and then it <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Producer.swift#L94">nils out references</a> to break the retain cycle. So for the <code>Producer</code> -based observables, the <code>SinkDisposer</code> is the <em>reference cycle manager</em> from the mental model that we’ve introduced earlier.</p>
<p>After all those details, you might wonder how come the reference cycle breaks itself when observable completes? Well, we’ve just stated that it requires <code>SinkDisposer.dispose()</code> method, so the answer is simple. The central point of subscription process, <code>sink</code> object, keeps the reference to <code>SinkDisposer</code> and also receives all the events from the observable. So once it gets either <code>.completed</code> or <code>.error</code> event and once its own logic determines that this is the sequence completion, it simply calls <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Sink.swift#L48">dispose</a> method on its <code>SinkDisposer</code> reference. This way the cycle is being broken from the inside.</p>
<p>To summarize the process, here comes the diagram of the actual reference cycle in the usual <code>Producer</code> -based observable subscription:</p>
<p>![](/my_pictures/8 Mistakes to Avoid while Using RxSwift-3.jpeg)</p>
<h3 id="The-road-goes-ever-on-and-on"><a href="#The-road-goes-ever-on-and-on" class="headerlink" title="The road goes ever on and on"></a>The road goes ever on and on</h3><p>Aren’t you curious what happens in non- <code>Producer</code> -based cases, such as subjects or connectable observables? The concept is very similar. There is always a reference cycle that’s controlled by some kind of <em>reference cycle manager</em> and there is always a way of breaking this cycle by <code>dispose</code> method invocation. I encourage you to dive into RxSwift source code and see for yourself!</p>
<p>Now it is clear where the mental model comes from. The details of particular subscription vary, and each observable type has specific optimizations applied for better performance and cleaner architecture. However, the basic idea prevails: there’s a reference cycle and the only way of breaking this cycle is either by completing the observable or through <em>reference cycle manager</em>.</p>
<p>Relying on the completion of the observable, while useful in many real-life situations, should always be a road taken with much care and deliberation. If you’re not sure of how to handle the subscription’s memory management, or you simply want your code to be more resilient to the future changes, it’s always best to default to supplying a mechanism of breaking the reference cycle explicitly.</p>
<p>That’s all for this time. More ways to shoot yourself in the foot with RxSwift are coming. Next time we’re going to look at memory management from a different perspective, focusing not on the subscription process, but on what’s being passed to operators. Until then, don’t forget to <a target="_blank" rel="noopener" href="https://twitter.com/polidea">follow Polidea on Twitter</a> for more mobile development related posts!</p>
<p><a target="_blank" rel="noopener" href="https://www.polidea.com/blog/8-Mistakes-to-Avoid-while-Using-RxSwiftPart-1/">8 Mistakes to Avoid while Using RxSwift. Part 1 - Polidea</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/RxSwift%E4%B8%93%E9%A2%98/" rel="tag"># RxSwift专题</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/03/19/2018-03-19-Escaping%20Closures%20-%20Swift/" rel="prev" title="Escaping Closures - Swift">
                  <i class="fa fa-chevron-left"></i> Escaping Closures - Swift
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/03/28/2018-03-28-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E5%85%AD%E3%80%91%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81/" rel="next" title="Swift 进阶【六】编码和解码">
                  Swift 进阶【六】编码和解码 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CX330</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  




  <script src="/js/local-search.js"></script>















  








  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '93e88b99de6ef6b6ed8a',
      clientSecret: 'c256915ad919ecd79dd7f6e03507ace0b2a82a5e',
      repo        : 'gitalkissue',
      owner       : 'TomatosX',
      admin       : ['TomatosX'],
      id          : '4f9d222c2c502021b427016a20ab79ea',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
