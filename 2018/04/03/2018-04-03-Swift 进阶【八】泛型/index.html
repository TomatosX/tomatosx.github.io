<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=SF+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="和大多数先进语言一样，Swift 拥有不少能被归类于泛型编程下的特性。使用泛型代码，你可以写出可重用的函数和数据结构，只要它们满足你所定义的约束，它们就能够适用于各种类型。比如，像是 Array 和 Set 等多个类型，实际上是它们中的元素类型就是泛型抽象。我们也可以创建泛型方法，它们可以对输入或者输出的类型进行泛型处理。func identity&lt;A&gt;(input: A) -&gt;">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift 进阶【八】泛型">
<meta property="og:url" content="http://example.com/2018/04/03/2018-04-03-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E5%85%AB%E3%80%91%E6%B3%9B%E5%9E%8B/index.html">
<meta property="og:site_name" content="CX330">
<meta property="og:description" content="和大多数先进语言一样，Swift 拥有不少能被归类于泛型编程下的特性。使用泛型代码，你可以写出可重用的函数和数据结构，只要它们满足你所定义的约束，它们就能够适用于各种类型。比如，像是 Array 和 Set 等多个类型，实际上是它们中的元素类型就是泛型抽象。我们也可以创建泛型方法，它们可以对输入或者输出的类型进行泛型处理。func identity&lt;A&gt;(input: A) -&gt;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-04-02T16:00:00.000Z">
<meta property="article:modified_time" content="2021-06-16T03:22:25.877Z">
<meta property="article:author" content="CX330">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="Swift学习">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2018/04/03/2018-04-03-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E5%85%AB%E3%80%91%E6%B3%9B%E5%9E%8B/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Swift 进阶【八】泛型 | CX330</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">CX330</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD"><span class="nav-number">1.</span> <span class="nav-text">重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E7%94%B1%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">1.1.</span> <span class="nav-text">自由函数的重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">1.2.</span> <span class="nav-text">运算符的重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F%E8%BF%9B%E8%A1%8C%E9%87%8D%E8%BD%BD"><span class="nav-number">1.3.</span> <span class="nav-text">使用泛型约束进行重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%AF%B9%E8%A1%8C%E4%B8%BA%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E5%8C%96"><span class="nav-number">1.4.</span> <span class="nav-text">使用闭包对行为进行参数化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E9%9B%86%E5%90%88%E9%87%87%E7%94%A8%E6%B3%9B%E5%9E%8B%E6%93%8D%E4%BD%9C"><span class="nav-number">2.</span> <span class="nav-text">对集合采用泛型操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">2.1.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">2.2.</span> <span class="nav-text">泛型二分查找</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.</span> <span class="nav-text">使用泛型进行代码设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E5%8F%96%E5%85%B1%E9%80%9A%E5%8A%9F%E8%83%BD"><span class="nav-number">3.1.</span> <span class="nav-text">提取共通功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%B3%9B%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.</span> <span class="nav-text">创建泛型数据类型</span></a></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CX330"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">CX330</p>
  <div class="site-description" itemprop="description">Stay hungry. Stay foolish.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">94</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/TomatosX" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TomatosX" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wujiafengwork@gmail.com" title="E-Mail → mailto:wujiafengwork@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/03/2018-04-03-Swift%20%E8%BF%9B%E9%98%B6%E3%80%90%E5%85%AB%E3%80%91%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="CX330">
      <meta itemprop="description" content="Stay hungry. Stay foolish.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CX330">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Swift 进阶【八】泛型
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-03 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-03T00:00:00+08:00">2018-04-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-16 11:22:25" itemprop="dateModified" datetime="2021-06-16T11:22:25+08:00">2021-06-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">技术学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>和大多数先进语言一样，Swift 拥有不少能被归类于泛型编程下的特性。使用泛型代码，你可以写出可重用的函数和数据结构，只要它们满足你所定义的约束，它们就能够适用于各种类型。比如，像是 <code>Array</code> 和 <code>Set</code> 等多个类型，实际上是它们中的元素类型就是泛型抽象。我们也可以创建泛型方法，它们可以对输入或者输出的类型进行泛型处理。<code>func identity&lt;A&gt;(input: A) -&gt; A</code> 就定义了一个可以作用于任意类型 A 的函数。某种意义上，我们甚至可以认为带有关联类型的协议是“泛型协议”。关联类型允许我们对特定的实现进行抽象。<code>IteratorProtocol</code> 协议就是一个这样的例子：它所生成的 <code>Element</code> 就是一个泛型。</p>
<p>泛型编程的目的是表达算法或者数据结构所要求的核心接口。比如，考虑内建集合一章中的 <code>last(where:)</code> 函数。将它写为 <code>Array</code> 的一个扩展原本是最明显的选择，但是 <code>Array</code> 其实包含了很多 <code>last(where:)</code> 并不需要的特性。通过确认核心接口到底是什么，也就是说，找到想要实现的功能的最小需求，我们可以将这个函数定义在宽阔得多的类型范围内。在这个例子中，<code>last(where:)</code> 只有一个需求：它需要能够逆序遍历一系列元素。所以，将这个算法定义为 <code>Sequence</code> 的扩展是更好的选择 (我们也可以为 <code>BidirectionalCollection</code> 添加一个更高效的实现)。</p>
<a id="more"></a>

<p>在本章中，我们会研究如何书写泛型代码。我们会先看一看什么是重载 (overloading) ，因为这个概念和泛型紧密相关。然后我们会使用泛型的方式，基于不同的假设，来为一个算法提供多种实现。之后我们将讨论一些你在为集合书写泛型算法时会遇到的常见问题，了解这些问题后你就将能使用泛型数据类型来重构代码，并使它们易于测试，更加灵活。最后，我们会谈一谈编译器是如何处理泛型代码的，以及要如何优化我们的泛型代码以获取更高性能的问题。</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><hr>
<p>拥有同样名字，但是参数或返回类型不同的多个方法互相称为重载方法，方法的重载并不意味着泛型。不过和泛型类似，我们可以将多种类型使用在同一个接口上。</p>
<h4 id="自由函数的重载"><a href="#自由函数的重载" class="headerlink" title="自由函数的重载"></a>自由函数的重载</h4><p>Swift 有一系列的复杂规则来确定到底使用哪个重载函数，这套规则基于函数是否是泛型，以及传入的参数是怎样的类型来确定使用优先级。整套规则十分复杂，不过它们可以被总结为一句话，那就是“选择最具体的一个”。也就是说，<strong>非通用的函数会优先于通用函数被使用</strong>。</p>
<p>来看下面这个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span>&lt;View: UIView&gt;<span class="params">(<span class="keyword">_</span> view: View)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s a \(type(of: view)), frame: \(view.frame)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(<span class="keyword">_</span> view: UILabel)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> text = view.text ?? <span class="string">&quot;(empty)&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s a label, text: \(text)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入 <code>UILabel</code> 将会调用专门针对 <code>label</code> 的重载，而传入其他的视图将会调用到泛型函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: <span class="type">CGRect</span>(x: <span class="number">20</span>, y: <span class="number">20</span>, width: <span class="number">200</span>, height: <span class="number">32</span>))</span><br><span class="line">label.text = <span class="string">&quot;Password&quot;</span></span><br><span class="line">log(label) <span class="comment">// It&#x27;s a label, text: Password</span></span><br><span class="line"><span class="keyword">let</span> button = <span class="type">UIButton</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">50</span>))</span><br><span class="line">log(button) <span class="comment">// It&#x27;s a UIButton, frame: (0.0, 0.0, 100.0, 50.0)</span></span><br></pre></td></tr></table></figure>

<p><strong>要特别注意，重载的使用是在编译期间静态决定的。也就是说，编译器会依据变量的静态类型来决定要调用哪一个重载，而不是在运行时根据值的动态类型来决定。</strong>我们如果将上面的 <code>label</code> 和 <code>button</code> 都放到一个 <code>UIView</code> 数组中，并对它们迭代并调用 <code>log</code> 的话，使用的都是泛型重载的版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> views = [label, button] <span class="comment">// Type of views is [UIView]</span></span><br><span class="line"><span class="keyword">for</span> view <span class="keyword">in</span> views &#123;</span><br><span class="line">    log(view)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> It&#x27;s a UILabel, frame: (20.0, 20.0, 200.0, 32.0)</span></span><br><span class="line"><span class="comment"> It&#x27;s a UIButton, frame: (0.0, 0.0, 100.0, 50.0)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><code>view</code> 的静态类型是 <code>UIView</code>，<code>UILabel</code> 本来应该使用更专门的另一个重载，但是因为重载并不会考虑运行时的动态类型，所以两者都使用了 <code>UIView</code> 的泛型重载。</p>
<h4 id="运算符的重载"><a href="#运算符的重载" class="headerlink" title="运算符的重载"></a>运算符的重载</h4><p>当使用操作符重载时，编译器会表现出一些奇怪的行为。Matt Gallagher 指出，即使泛型版本应该是更好的选择（而且应该在一个普通函数调用时被选择）的时候，类型检查器也还是会去选择那些非泛型的重载，而不去选择泛型重载。</p>
<p>我们来看一个幂运算的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 幂运算比乘法运算优先级更高</span></span><br><span class="line">precedencegroup <span class="type">ExponentiationPrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span>: <span class="keyword">left</span></span><br><span class="line">    higherThan: <span class="type">MultiplicationPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> **: <span class="type">ExponentiationPrecedence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> **<span class="params">(lhs: Double, rhs: Double)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pow(lhs, rhs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> **<span class="params">(lhs: Float, rhs: Float)</span></span> -&gt; <span class="type">Float</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> powf(lhs, rhs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们添加一个整数的重载，让它对所有的整数类型有效，这里我们对所有满足 <code>BinaryInteger</code> 的类型定义了一个重载。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> **&lt;I: BinaryInteger&gt;<span class="params">(lhs: I, rhs: I)</span></span> -&gt; <span class="type">I</span> &#123;</span><br><span class="line">    <span class="comment">// 转换为 Int64，使用 Double 的重载计算结果</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="type">Double</span>(<span class="type">Int64</span>(lhs)) ** <span class="type">Double</span>(<span class="type">Int64</span>(rhs))</span><br><span class="line">    <span class="keyword">return</span> <span class="type">I</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的泛型看起来没什么问题，但是在我们使用整型调用 <code>**</code> 的时候，<strong>编译器会报错说 <code>**</code> 存在歧义</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 错误：操作符 &#x27;**&#x27; 的使用存在歧义。</span></span><br></pre></td></tr></table></figure>

<p><strong>要解释原因，我们需要回到我们在本节一开头说道的：对于重载的运算符，类型检查器会去使用非泛型版本的重载，而不考虑泛型版本。显然，编译器忽略了整数的泛型重载，因此它无法确定是去调用 <code>Double</code> 的重载还是 <code>Float</code> 的重载，因为两者对于整数字面量输入来说，是相同优先级的可选项（Swift 编译器会将整数字面量在需要时自动向上转换为 <code>Double</code> 或者 <code>Float</code> ），所以编译器报错说存在歧义。要让编译器选择正确的重载，我们需要至少将一个参数显式地声明为整数类型，或者明确提供返回值的类型：</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intResult: <span class="type">Int</span> = <span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<h4 id="使用泛型约束进行重载"><a href="#使用泛型约束进行重载" class="headerlink" title="使用泛型约束进行重载"></a>使用泛型约束进行重载</h4><p><strong>当你在写一些可以被用多种算法表达的同样的操作，并且算法对它们的泛型参数又有不同的要求的代码的时候，你可能经常会遇到带有泛型代码的重载。假设我们要写一个算法，来确定一个数组中的所有元素是不是都被包含在另一个数组中。换句话说，我们想要知道第一个数组是不是第二个数组的子集 (这里元素的顺序不重要)。标准库中提供了一个叫做 <code>isSubset(of:)</code> 的方法，不过这个方法只适用于像 <code>Set</code> 这样满足 <code>SetAlgebra</code> 协议的类型。</strong></p>
<p>我们可以写一个适用于更宽广范围的 <code>isSubset(of:)</code>，它看起来可能是这样的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 当且仅当 `self` 中的所有元素都包含在 `other` 中，返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isSubset</span><span class="params">(of other: [Element])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> other.<span class="built_in">contains</span>(element) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> oneToThree = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> fiveToOne = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">oneToThree.isSubset(of: fiveToOne) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这个 <code>isSubset</code> 的版本有一个重大缺陷，那就是性能。这里的算法的时间复杂度是 O(nm)，其中 n 和 m 分别代表两个数组的元素个数。也就是说，随着输入的增多，这个函数的最坏情况的耗时将成平方增加。这是因为 <code>contains</code> 在数组中的复杂度是线性的 O(m)，这个函数会迭代源序列中的元素，逐个检查它是够匹配给定的元素。而 <code>contains</code> 是在另一个迭代最初数组的元素的循环中被调用了，这个循环也很类似，是一个线性时间复杂度的循环。所以我们是在一个 O(n) 循环里执行了一个 O(m) 的循环，结果这个函数的复杂度就是 O(nm)。</p>
<p>我们可以通过要求元素满足 <code>Hashable</code> 来收紧序列元素类型的限制来写出性能更好的版本。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 如果 `self` 中的所有元素都包含在 `other` 中，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isSubset</span><span class="params">(of other: [Element])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> otherSet = <span class="type">Set</span>(other)</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> otherSet.<span class="built_in">contains</span>(element) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样查找操作就可以在常数时间内进行了。</p>
<p>类型检查器会使用它所能找到的最精确的重载。这里 <code>isSubset</code> 的两个版本都是泛型函数，所以非泛型函数先于泛型函数的规则并不适用。不过因为 <code>Hashable</code> 是对 <code>Equatable</code> 的扩展，所以要求 <code>Hashable</code> 的版本更加精确。有了这些约束，我们可能可以像例子中的 <code>isSubset</code> 这样写出更加高效的算法，所以编译器假设更加具体的函数会是更好的选择。</p>
<p><code>isSubset</code> 还可以更加通用，到现在位置，它只接受一个数组并对其检查。但是 <code>Array</code> 是一个具体的类型。实际上 <code>isSubset</code> 并不需要这么具体，在两个版本中只有两个函数调用，那就是两者中都有的 <code>contains</code> 以及 <code>Hashable</code> 版本中的 <code>Set.init</code>。这两种情况下，这些函数只要求输入类型满足 <code>Sequence</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 根据序列是否包含给定元素返回一个布尔值。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(<span class="keyword">_</span> element: Element)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Set</span>&lt;<span class="title">Element</span>: <span class="title">Hashable</span>&gt;:</span></span><br><span class="line"><span class="class">    <span class="title">SetAlgebra</span>, <span class="title">Hashable</span>, <span class="title">Collection</span>, <span class="title">ExpressibleByArrayLiteral</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/// 通过一个有限序列创建新的集合。</span></span><br><span class="line">    <span class="keyword">init</span>&lt;<span class="type">Source</span>: <span class="type">Sequence</span>&gt;(<span class="keyword">_</span> sequence: <span class="type">Source</span>)</span><br><span class="line">    <span class="keyword">where</span> <span class="type">Source</span>.<span class="type">Element</span> == <span class="type">Element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，<code>isSubset</code> 中 <code>other</code> 只需要是遵守 <code>Sequence</code> 的任意类型就可以了。另外，<code>self</code> 和 <code>other</code> 这两个序列类型并不需要是同样的类型。我们只需要其中的元素类型相同就能进行操作。下面是针对任意两种序列重写的 <code>Hashable</code> 版本的函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 如果 `self` 中的所有元素都包含在 `other` 中，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isSubset</span>&lt;S: Sequence&gt;<span class="params">(of other: S)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">        <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Element</span> == <span class="type">Element</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> otherSet = <span class="type">Set</span>(other)</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> otherSet.<span class="built_in">contains</span>(element) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在两个序列不需要有相同的类型了，这为我们开启了更多的可能性。比如，你可以传入一个数字的 <code>CountableRange</code> 来进行检查：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>].isSubset(of: <span class="number">1</span>...<span class="number">10</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>我们可以对可判等的元素的函数作出同样的更改。</p>
<h4 id="使用闭包对行为进行参数化"><a href="#使用闭包对行为进行参数化" class="headerlink" title="使用闭包对行为进行参数化"></a>使用闭包对行为进行参数化</h4><p>使用闭包对行为参数化，指的就是闭包表达式，类似于 <code>Array</code> 的 <code>map</code> ，<code>filter</code> ，<code>reduce</code> 这些函数。 我们的 <code>isSubset</code> 函数还有更加通用化的可能，对于那些不遵循 <code>Equatable</code> 的序列要怎么办？比如 <code>Array</code> 的元素也是 <code>Array</code> 的时候，本身 <code>Array</code> 无法遵循 <code>Equatable</code> ，因为 <code>Array</code> 元素本身就可能不能判等。</p>
<p>遇到这种情况的时候，我们可以将判等的工作交给调用者去实现，使用闭包。标准库中的 <code>contains</code> 函数就是一个很好的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 根据序列是否包含满足给定断言的元素，返回一个布尔值。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(<span class="keyword">where</span> predicate: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>)</span><br><span class="line">        <span class="keyword">rethrows</span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>contains</code> 函数很强大，你可以用它来对一个序列进行各种条件的检查。用于我们的 <code>isSubset</code> 函数上后，就像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isSubset</span>&lt;S: Sequence&gt;<span class="params">(of other: S,</span></span></span><br><span class="line"><span class="function"><span class="params">                               by areEquivalent: <span class="params">(Element, S.Element)</span></span></span> -&gt; <span class="type">Bool</span>)</span><br><span class="line">        -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> other.<span class="built_in">contains</span>(<span class="keyword">where</span>: &#123; areEquivalent(element, $<span class="number">0</span>) &#125;) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以将 <code>isSubset</code> 用在数组的数组上了，只需要为它提供一个闭包表达式，并使用 <code>==</code> 来对数组进行比较。<strong>不幸的是，如果我们导入了 <code>Foundation</code>，另一个对类型检查器的性能优化将会导致编译器不再确定到底应该使用哪个 <code>==</code>，从而使编译发生错误。我们需要在代码的某个地方加上类型标注：</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">2</span>]].isSubset(of: [[<span class="number">1</span>,<span class="number">2</span>] <span class="keyword">as</span> [<span class="type">Int</span>], [<span class="number">3</span>,<span class="number">4</span>]]) &#123; $<span class="number">0</span> == $<span class="number">1</span> &#125; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="对集合采用泛型操作"><a href="#对集合采用泛型操作" class="headerlink" title="对集合采用泛型操作"></a>对集合采用泛型操作</h3><hr>
<p>集合上的泛型算法通常会带出一些特殊的问题，特别在与索引和切片一起使用时更是如此。在这节中，我们通过两个依赖于正确处理索引和切片的例子，来看看如何解决这些问题。</p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>说到二分查找，相信大家都会马上想起自己写的最简单的二分查找法。例如下面这个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 返回 `value` 第一次出现在 `self` 中的索引值，</span></span><br><span class="line">    <span class="comment">/// 如果 `value` 不存在，返回 `nil`</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - 要求: `isOrderedBefore` 是在 `self` 中元素上</span></span><br><span class="line">    <span class="comment">/// 的严格弱序，且数组中的元素已经按它进行过排序</span></span><br><span class="line">    <span class="comment">/// - 复杂度: O(log `count`)</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">for</span> value: Element,</span></span></span><br><span class="line"><span class="function"><span class="params">                      areInIncreasingOrder: <span class="params">(Element, Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Int?</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">right</span> = <span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">left</span> &lt;= <span class="keyword">right</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> mid = (<span class="keyword">left</span> + <span class="keyword">right</span>) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">let</span> candidate = <span class="keyword">self</span>[mid]</span><br><span class="line">            <span class="keyword">if</span> areInIncreasingOrder(candidate,value) &#123;</span><br><span class="line">                <span class="keyword">left</span> = mid + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> areInIncreasingOrder(value,candidate) &#123;</span><br><span class="line">                <span class="keyword">right</span> = mid - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 由于 isOrderedBefore 的要求，如果两个元素互无顺序关系，那么它们一定相等</span></span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">for</span> value: Element)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.binarySearch(<span class="keyword">for</span>: value, areInIncreasingOrder: &lt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个简单的二分查找算法，其实有一个 Bug。</p>
<blockquote>
<p>在数组非常大的情况下，将两个索引值相加有可能会造成溢出 (比如 <code>count</code> 很接近 <code>Int.max</code>，并且要搜索的元素是数组最后一个元素时的情况)。不过，将距离的一半加到左侧索引时，这个问题就不会发生。当然了，想要触发这个 bug 的机会其实很小。  </p>
</blockquote>
<p>现在我们来改善一下既有的算法设计，以前二分查找算法都是基于普通数组的，但是在 Swift 中，有一些特殊的数组，像是 <code>ArraySlice</code> ，上面的算法是无法直接在 <code>ArraySlice</code> 数组中运行的，当我们在计算中间下标的时候，会出现一个 Bug，因为 <code>ArraySlice</code> 的下标并不一定是从 0 开始。所以我们定义二分查找算法的时候，不能定义在普通的数组 <code>Array</code> 上，我们应该定义在 <code>RandomAccessCollection</code>。</p>
<h4 id="泛型二分查找"><a href="#泛型二分查找" class="headerlink" title="泛型二分查找"></a>泛型二分查找</h4><p>如果你把 Int 索引的要求去掉，将会发生一些编译错误。原来的代码需要进行一些重写才能完全满足泛型的要求。下面是完全泛型化之后的版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">RandomAccessCollection</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">for</span> value: Element, areInIncreasingOrder: <span class="params">(Element, Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Index?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> !isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = startIndex</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">right</span> = index(before: endIndex)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">left</span> &lt;= <span class="keyword">right</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> dist = <span class="built_in">distance</span>(from: <span class="keyword">left</span>, to: <span class="keyword">right</span>)</span><br><span class="line">            <span class="keyword">let</span> mid = index(<span class="keyword">left</span>, offsetBy: dist / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> candidate = <span class="keyword">self</span>[mid]</span><br><span class="line">            <span class="keyword">if</span> areInIncreasingOrder(candidate, value) &#123;</span><br><span class="line">                <span class="keyword">left</span> = index(after: mid)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> areInIncreasingOrder(value, candidate) &#123;</span><br><span class="line">                <span class="keyword">right</span> = index(before: mid)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">RandomAccessCollection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">for</span> value: Element)</span></span> -&gt; <span class="type">Index?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(<span class="keyword">for</span>: value, areInIncreasingOrder: &lt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strAry = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span>]</span><br><span class="line">strAry.binarySearch(<span class="keyword">for</span>: <span class="string">&quot;d&quot;</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ArraySlice 并不一定是从下标为 0 开始</span></span><br><span class="line"><span class="keyword">let</span> subStrAry = strAry[<span class="number">3</span>..&lt;<span class="number">5</span>] <span class="comment">// [&quot;d&quot;, &quot;e&quot;]</span></span><br><span class="line">subStrAry.binarySearch(<span class="keyword">for</span>: <span class="string">&quot;d&quot;</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>改动虽小，意义重大。首先，<code>left</code> 和 <code>right</code> 变量现在不再是整数类型了。我们使用了起始索引和结束索引值。这些值可能是整数，但它们也可能是像是 <code>String</code> 的索引，<code>Dictionary</code> 的索引，或者是 <code>Set</code> 的索引这样的非透明索引，它们是无法随机访问的。</p>
<h3 id="使用泛型进行代码设计"><a href="#使用泛型进行代码设计" class="headerlink" title="使用泛型进行代码设计"></a>使用泛型进行代码设计</h3><hr>
<p>让我们来写一些与网络服务交互的函数。比如，获取用户列表的数据，并将它解析为 <code>User</code> 数据类型。我们创建一个 <code>loadUsers</code> 函数，它可以从网上异步加载用户，并且在完成后通过一个回调来传递获取到的用户列表。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadUsers</span><span class="params">(callback: <span class="params">([User]?)</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    <span class="keyword">let</span> usersURL = webserviceURL.appendingPathComponent(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">try</span>? <span class="type">Data</span>(contentsOf: usersURL)</span><br><span class="line">    <span class="keyword">let</span> json = data.flatMap &#123;</span><br><span class="line">        <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: $<span class="number">0</span>, options: [])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> users = (json <span class="keyword">as</span>? [<span class="type">Any</span>]).flatMap &#123; jsonObject <span class="keyword">in</span></span><br><span class="line">        jsonObject.flatMap(<span class="type">User</span>.<span class="keyword">init</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    callback(users)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数有个严重的问题，代码的重用性非常差，如果我们想要写一个相同的函数来加载其他资源，我们可能需要复制这里的大部分代码。打个比方，我们需要一个加载博客文章的函数，它看起来是这样的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadBlogPosts</span><span class="params">(callback: <span class="params">([BlogPost])</span></span></span>? -&gt; ())</span><br></pre></td></tr></table></figure>

<h4 id="提取共通功能"><a href="#提取共通功能" class="headerlink" title="提取共通功能"></a>提取共通功能</h4><p>相比于复制粘贴，将函数中 User 相关的部分提取出来，将其他部分进行重用，会是更好的方式。我们可以将 URL 路径和解析转换的函数作为参数传入。因为我们希望可以传入不同的转换函数，所以我们将 loadResource 声明为 A 的泛型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadResource</span>&lt;A&gt;<span class="params">(at path: String,</span></span></span><br><span class="line"><span class="function"><span class="params">                     parse: <span class="params">(<span class="keyword">Any</span>)</span></span></span> -&gt; <span class="type">A?</span>, callback: (<span class="type">A?</span>) -&gt; ())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> resourceURL = webserviceURL.appendingPathComponent(path)</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">try</span>? <span class="type">Data</span>(contentsOf: resourceURL)</span><br><span class="line">    <span class="keyword">let</span> json = data.flatMap &#123;</span><br><span class="line">        <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: $<span class="number">0</span>, options: [])</span><br><span class="line">    &#125;</span><br><span class="line">    callback(json.flatMap(parse))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以将 <code>loadUsers</code> 函数基于 <code>loadResource</code> 重写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadUsers</span><span class="params">(callback: <span class="params">([User]?)</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    loadResource(at: <span class="string">&quot;/users&quot;</span>, parse: jsonArray(<span class="type">User</span>.<span class="keyword">init</span>), callback: callback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用了一个辅助函数，<code>jsonArray</code>，它首先尝试将一个 <code>Any</code> 转换为一个 <code>Any</code> 的数组，接着对每个元素用提供的解析函数进行解析，如果期间任何一步发生了错误，则返回 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jsonArray</span>&lt;A&gt;<span class="params">(<span class="keyword">_</span> transform: @escaping <span class="params">(<span class="keyword">Any</span>)</span></span></span> -&gt; <span class="type">A?</span>) -&gt; (<span class="type">Any</span>) -&gt; [<span class="type">A</span>]? &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; array <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> array = array <span class="keyword">as</span>? [<span class="type">Any</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array.flatMap(transform)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于加载博客文章的函数，我们只需要替换请求路径和解析函数就行了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadBlogPosts</span><span class="params">(callback: <span class="params">([BlogPost]?)</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    loadResource(at: <span class="string">&quot;/posts&quot;</span>, parse: jsonArray(<span class="type">BlogPost</span>.<span class="keyword">init</span>), callback: callback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建泛型数据类型"><a href="#创建泛型数据类型" class="headerlink" title="创建泛型数据类型"></a>创建泛型数据类型</h4><p><code>loadResource</code> 函数中的 <code>path</code> 和 <code>parse</code> 耦合非常紧密，一旦你改变了其中一个，你很可能也需要改变另一个。我们可以将它们打包进一个结构体中，用来描述要加载的资源。和函数一样，这个结构体也可以是泛型的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resource</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> path: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> parse: (<span class="type">Any</span>) -&gt; <span class="type">A?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadSynchronously</span><span class="params">(callback: <span class="params">(A?)</span></span></span> -&gt; ()) &#123;</span><br><span class="line">        <span class="keyword">let</span> resourceURL = webserviceURL.appendingPathComponent(path)</span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">try</span>? <span class="type">Data</span>(contentsOf: resourceURL)</span><br><span class="line">        <span class="keyword">let</span> json = data.flatMap &#123;</span><br><span class="line">            <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: $<span class="number">0</span>, options: [])</span><br><span class="line">        &#125;</span><br><span class="line">        callback(json.flatMap(parse))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadAsynchronously</span><span class="params">(callback: @escaping <span class="params">(A?)</span></span></span> -&gt; ()) &#123;</span><br><span class="line">        <span class="keyword">let</span> resourceURL = webserviceURL.appendingPathComponent(path)</span><br><span class="line">        <span class="keyword">let</span> session = <span class="type">URLSession</span>.shared</span><br><span class="line">        session.dataTask(with: resourceURL) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> json = data.flatMap &#123;</span><br><span class="line">                <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: $<span class="number">0</span>, options: [])</span><br><span class="line">            &#125;</span><br><span class="line">            callback(json.flatMap(<span class="keyword">self</span>.parse))</span><br><span class="line">            &#125;.resume()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于之前的用顶层函数来定义资源，我们现在可以定义 <code>Resource</code> 结构体实例，这让我们可以很容易地添加新的资源，而不必创建新的函数。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"># iOS</a>
              <a href="/tags/Swift%E5%AD%A6%E4%B9%A0/" rel="tag"># Swift学习</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/04/02/2018-04-02-Swift%20%E6%93%8D%E4%BD%9C%E7%AC%A6/" rel="prev" title="Swift 操作符">
                  <i class="fa fa-chevron-left"></i> Swift 操作符
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/04/04/2018-04-04-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%A1%E7%89%87%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="next" title="多任务卡片动画实现原理">
                  多任务卡片动画实现原理 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CX330</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  




  <script src="/js/local-search.js"></script>















  








  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '93e88b99de6ef6b6ed8a',
      clientSecret: 'c256915ad919ecd79dd7f6e03507ace0b2a82a5e',
      repo        : 'gitalkissue',
      owner       : 'TomatosX',
      admin       : ['TomatosX'],
      id          : 'df920f8558bf3183b826e601e695b65e',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
